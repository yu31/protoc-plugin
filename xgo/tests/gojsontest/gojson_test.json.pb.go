// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: xgo/tests/gojsontest/gojson_test.proto

package gojsontest

import (
	base64 "encoding/base64"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	_ "github.com/yu31/protoc-plugin/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin/xgo/pkg/jsonencoder"
	gojsonexternal "github.com/yu31/protoc-plugin/xgo/tests/gojsonexternal"
	_ "google.golang.org/protobuf/types/descriptorpb"
	strconv "strconv"
)

// MarshalJSON for implements interface json.Marshaler.
func (this *EmptyMessage) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(2)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *EmptyMessage) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*EmptyMessage) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *StandMessage1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(44)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.StandMessage1.name1 | kind: StringKind | GoName: Name1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("name1")
	encoder.AppendString(this.Name1)
	// encode filed type of basic; | field: gojsontest.StandMessage1.name2 | kind: StringKind | GoName: Name2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("name2")
	encoder.AppendString(this.Name2)
	// encode filed type of basic; | field: gojsontest.StandMessage1.name3 | kind: StringKind | GoName: Name3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("name3")
	encoder.AppendString(this.Name3)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *StandMessage1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*StandMessage1) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "name1":
			// decode filed type of basic; | field: gojsontest.StandMessage1.name1 | kind: StringKind | GoName: Name1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Name1 = x
		case objKey == "name2":
			// decode filed type of basic; | field: gojsontest.StandMessage1.name2 | kind: StringKind | GoName: Name2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Name2 = x
		case objKey == "name3":
			// decode filed type of basic; | field: gojsontest.StandMessage1.name3 | kind: StringKind | GoName: Name3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Name3 = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *Model1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(3910)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Encode field type of oneof; | field: gojsontest.Model1.OneofType1 | GoName: OneofType1 | omitempty: false | ignore: false
	if this.OneofType1 != nil {
		switch v := this.OneofType1.(type) {
		case *Model1_Oneof1Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_double | kind: DoubleKind | GoName: Oneof1Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_double")
			encoder.AppendFloat64(v.Oneof1Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_float | kind: FloatKind | GoName: Oneof1Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_float")
			encoder.AppendFloat32(v.Oneof1Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_int32 | kind: Int32Kind | GoName: Oneof1Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_int32")
			encoder.AppendInt32(v.Oneof1Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_int64 | kind: Int64Kind | GoName: Oneof1Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_int64")
			encoder.AppendInt64(v.Oneof1Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_uint32 | kind: Uint32Kind | GoName: Oneof1Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_uint32")
			encoder.AppendUint32(v.Oneof1Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_uint64 | kind: Uint64Kind | GoName: Oneof1Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_uint64")
			encoder.AppendUint64(v.Oneof1Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_sint32 | kind: Sint32Kind | GoName: Oneof1Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_sint32")
			encoder.AppendInt32(v.Oneof1Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_sint64 | kind: Sint64Kind | GoName: Oneof1Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_sint64")
			encoder.AppendInt64(v.Oneof1Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_fixed32 | kind: Fixed32Kind | GoName: Oneof1Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_fixed32")
			encoder.AppendUint32(v.Oneof1Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_fixed64 | kind: Fixed64Kind | GoName: Oneof1Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_fixed64")
			encoder.AppendUint64(v.Oneof1Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_sfixed32 | kind: Sfixed32Kind | GoName: Oneof1Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_sfixed32")
			encoder.AppendInt32(v.Oneof1Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_sfixed64 | kind: Sfixed64Kind | GoName: Oneof1Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_sfixed64")
			encoder.AppendInt64(v.Oneof1Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_bool | kind: BoolKind | GoName: Oneof1Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_bool")
			encoder.AppendBool(v.Oneof1Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_string | kind: StringKind | GoName: Oneof1String | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_string")
			encoder.AppendString(v.Oneof1String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_bytes | kind: BytesKind | GoName: Oneof1Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_bytes")
			encoder.AppendBytes(v.Oneof1Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof1EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_embed_message | kind: MessageKind | GoName: Oneof1EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_embed_message")
			err = encoder.AppendInterface(v.Oneof1EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof1StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_stand_message | kind: MessageKind | GoName: Oneof1StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_stand_message")
			err = encoder.AppendInterface(v.Oneof1StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof1ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_external_message | kind: MessageKind | GoName: Oneof1ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_external_message")
			err = encoder.AppendInterface(v.Oneof1ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof1EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_embed_enum | kind: EnumKind | GoName: Oneof1EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_embed_enum")
			encoder.AppendInt32(int32(v.Oneof1EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof1StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_stand_enum | kind: EnumKind | GoName: Oneof1StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_stand_enum")
			encoder.AppendInt32(int32(v.Oneof1StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof1ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof1_external_enum | kind: EnumKind | GoName: Oneof1ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof1_external_enum")
			encoder.AppendInt32(int32(v.Oneof1ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: oneof_type1, goName: OneofType1, field: gojsontest.Model1.OneofType1", v)
		}
	} else {
		encoder.AppendObjectKey("oneof_type1")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.oneofType2 | GoName: OneofType2 | omitempty: false | ignore: false
	if this.OneofType2 != nil {
		switch v := this.OneofType2.(type) {
		case *Model1_Oneof2Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_double | kind: DoubleKind | GoName: Oneof2Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_double")
			encoder.AppendFloat64(v.Oneof2Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_float | kind: FloatKind | GoName: Oneof2Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_float")
			encoder.AppendFloat32(v.Oneof2Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_int32 | kind: Int32Kind | GoName: Oneof2Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_int32")
			encoder.AppendInt32(v.Oneof2Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_int64 | kind: Int64Kind | GoName: Oneof2Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_int64")
			encoder.AppendInt64(v.Oneof2Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_uint32 | kind: Uint32Kind | GoName: Oneof2Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_uint32")
			encoder.AppendUint32(v.Oneof2Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_uint64 | kind: Uint64Kind | GoName: Oneof2Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_uint64")
			encoder.AppendUint64(v.Oneof2Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_sint32 | kind: Sint32Kind | GoName: Oneof2Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_sint32")
			encoder.AppendInt32(v.Oneof2Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_sint64 | kind: Sint64Kind | GoName: Oneof2Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_sint64")
			encoder.AppendInt64(v.Oneof2Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_fixed32 | kind: Fixed32Kind | GoName: Oneof2Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_fixed32")
			encoder.AppendUint32(v.Oneof2Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_fixed64 | kind: Fixed64Kind | GoName: Oneof2Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_fixed64")
			encoder.AppendUint64(v.Oneof2Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_sfixed32 | kind: Sfixed32Kind | GoName: Oneof2Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_sfixed32")
			encoder.AppendInt32(v.Oneof2Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_sfixed64 | kind: Sfixed64Kind | GoName: Oneof2Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_sfixed64")
			encoder.AppendInt64(v.Oneof2Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_bool | kind: BoolKind | GoName: Oneof2Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_bool")
			encoder.AppendBool(v.Oneof2Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_string | kind: StringKind | GoName: Oneof2String | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_string")
			encoder.AppendString(v.Oneof2String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_bytes | kind: BytesKind | GoName: Oneof2Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_bytes")
			encoder.AppendBytes(v.Oneof2Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof2EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_embed_message | kind: MessageKind | GoName: Oneof2EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_embed_message")
			err = encoder.AppendInterface(v.Oneof2EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof2StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_stand_message | kind: MessageKind | GoName: Oneof2StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_stand_message")
			err = encoder.AppendInterface(v.Oneof2StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof2ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_external_message | kind: MessageKind | GoName: Oneof2ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_external_message")
			err = encoder.AppendInterface(v.Oneof2ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof2EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_embed_enum | kind: EnumKind | GoName: Oneof2EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_embed_enum")
			encoder.AppendInt32(int32(v.Oneof2EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof2StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_stand_enum | kind: EnumKind | GoName: Oneof2StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_stand_enum")
			encoder.AppendInt32(int32(v.Oneof2StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof2ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof2_external_enum | kind: EnumKind | GoName: Oneof2ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneofType2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof2_external_enum")
			encoder.AppendInt32(int32(v.Oneof2ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: oneofType2, goName: OneofType2, field: gojsontest.Model1.oneofType2", v)
		}
	} else {
		encoder.AppendObjectKey("oneofType2")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.OneofType3 | GoName: OneofType3 | omitempty: false | ignore: false
	if this.OneofType3 != nil {
		switch v := this.OneofType3.(type) {
		case *Model1_Oneof3Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_double | kind: DoubleKind | GoName: Oneof3Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_double")
			encoder.AppendFloat64(v.Oneof3Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_float | kind: FloatKind | GoName: Oneof3Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_float")
			encoder.AppendFloat32(v.Oneof3Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_int32 | kind: Int32Kind | GoName: Oneof3Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_int32")
			encoder.AppendInt32(v.Oneof3Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_int64 | kind: Int64Kind | GoName: Oneof3Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_int64")
			encoder.AppendInt64(v.Oneof3Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_uint32 | kind: Uint32Kind | GoName: Oneof3Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_uint32")
			encoder.AppendUint32(v.Oneof3Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_uint64 | kind: Uint64Kind | GoName: Oneof3Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_uint64")
			encoder.AppendUint64(v.Oneof3Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_sint32 | kind: Sint32Kind | GoName: Oneof3Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_sint32")
			encoder.AppendInt32(v.Oneof3Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_sint64 | kind: Sint64Kind | GoName: Oneof3Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_sint64")
			encoder.AppendInt64(v.Oneof3Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_fixed32 | kind: Fixed32Kind | GoName: Oneof3Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_fixed32")
			encoder.AppendUint32(v.Oneof3Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_fixed64 | kind: Fixed64Kind | GoName: Oneof3Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_fixed64")
			encoder.AppendUint64(v.Oneof3Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_sfixed32 | kind: Sfixed32Kind | GoName: Oneof3Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_sfixed32")
			encoder.AppendInt32(v.Oneof3Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_sfixed64 | kind: Sfixed64Kind | GoName: Oneof3Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_sfixed64")
			encoder.AppendInt64(v.Oneof3Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_bool | kind: BoolKind | GoName: Oneof3Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_bool")
			encoder.AppendBool(v.Oneof3Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_string | kind: StringKind | GoName: Oneof3String | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_string")
			encoder.AppendString(v.Oneof3String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_bytes | kind: BytesKind | GoName: Oneof3Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_bytes")
			encoder.AppendBytes(v.Oneof3Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof3EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_embed_message | kind: MessageKind | GoName: Oneof3EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_embed_message")
			err = encoder.AppendInterface(v.Oneof3EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof3StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_stand_message | kind: MessageKind | GoName: Oneof3StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_stand_message")
			err = encoder.AppendInterface(v.Oneof3StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof3ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_external_message | kind: MessageKind | GoName: Oneof3ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_external_message")
			err = encoder.AppendInterface(v.Oneof3ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof3EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_embed_enum | kind: EnumKind | GoName: Oneof3EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_embed_enum")
			encoder.AppendInt32(int32(v.Oneof3EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof3StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_stand_enum | kind: EnumKind | GoName: Oneof3StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_stand_enum")
			encoder.AppendInt32(int32(v.Oneof3StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof3ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof3_external_enum | kind: EnumKind | GoName: Oneof3ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("OneofType3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof3_external_enum")
			encoder.AppendInt32(int32(v.Oneof3ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: OneofType3, goName: OneofType3, field: gojsontest.Model1.OneofType3", v)
		}
	} else {
		encoder.AppendObjectKey("OneofType3")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type4 | GoName: Oneof_Type4 | omitempty: false | ignore: false
	if this.Oneof_Type4 != nil {
		switch v := this.Oneof_Type4.(type) {
		case *Model1_Oneof4Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_double | kind: DoubleKind | GoName: Oneof4Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_double")
			encoder.AppendFloat64(v.Oneof4Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_float | kind: FloatKind | GoName: Oneof4Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_float")
			encoder.AppendFloat32(v.Oneof4Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_int32 | kind: Int32Kind | GoName: Oneof4Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_int32")
			encoder.AppendInt32(v.Oneof4Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_int64 | kind: Int64Kind | GoName: Oneof4Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_int64")
			encoder.AppendInt64(v.Oneof4Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_uint32 | kind: Uint32Kind | GoName: Oneof4Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_uint32")
			encoder.AppendUint32(v.Oneof4Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_uint64 | kind: Uint64Kind | GoName: Oneof4Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_uint64")
			encoder.AppendUint64(v.Oneof4Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_sint32 | kind: Sint32Kind | GoName: Oneof4Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_sint32")
			encoder.AppendInt32(v.Oneof4Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_sint64 | kind: Sint64Kind | GoName: Oneof4Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_sint64")
			encoder.AppendInt64(v.Oneof4Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_fixed32 | kind: Fixed32Kind | GoName: Oneof4Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_fixed32")
			encoder.AppendUint32(v.Oneof4Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_fixed64 | kind: Fixed64Kind | GoName: Oneof4Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_fixed64")
			encoder.AppendUint64(v.Oneof4Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_sfixed32 | kind: Sfixed32Kind | GoName: Oneof4Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_sfixed32")
			encoder.AppendInt32(v.Oneof4Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_sfixed64 | kind: Sfixed64Kind | GoName: Oneof4Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_sfixed64")
			encoder.AppendInt64(v.Oneof4Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_bool | kind: BoolKind | GoName: Oneof4Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_bool")
			encoder.AppendBool(v.Oneof4Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_string | kind: StringKind | GoName: Oneof4String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_string")
			encoder.AppendString(v.Oneof4String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_bytes | kind: BytesKind | GoName: Oneof4Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_bytes")
			encoder.AppendBytes(v.Oneof4Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof4EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_embed_message | kind: MessageKind | GoName: Oneof4EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_embed_message")
			err = encoder.AppendInterface(v.Oneof4EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof4StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_stand_message | kind: MessageKind | GoName: Oneof4StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_stand_message")
			err = encoder.AppendInterface(v.Oneof4StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof4ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_external_message | kind: MessageKind | GoName: Oneof4ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_external_message")
			err = encoder.AppendInterface(v.Oneof4ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof4EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_embed_enum | kind: EnumKind | GoName: Oneof4EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_embed_enum")
			encoder.AppendInt32(int32(v.Oneof4EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof4StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_stand_enum | kind: EnumKind | GoName: Oneof4StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_stand_enum")
			encoder.AppendInt32(int32(v.Oneof4StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof4ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof4_external_enum | kind: EnumKind | GoName: Oneof4ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof4_external_enum")
			encoder.AppendInt32(int32(v.Oneof4ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type4, goName: Oneof_Type4, field: gojsontest.Model1.Oneof_Type4", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type4")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.oneof_Type5 | GoName: Oneof_Type5 | omitempty: false | ignore: false
	if this.Oneof_Type5 != nil {
		switch v := this.Oneof_Type5.(type) {
		case *Model1_Oneof5Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_double | kind: DoubleKind | GoName: Oneof5Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_double")
			encoder.AppendFloat64(v.Oneof5Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_float | kind: FloatKind | GoName: Oneof5Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_float")
			encoder.AppendFloat32(v.Oneof5Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_int32 | kind: Int32Kind | GoName: Oneof5Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_int32")
			encoder.AppendInt32(v.Oneof5Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_int64 | kind: Int64Kind | GoName: Oneof5Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_int64")
			encoder.AppendInt64(v.Oneof5Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_uint32 | kind: Uint32Kind | GoName: Oneof5Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_uint32")
			encoder.AppendUint32(v.Oneof5Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_uint64 | kind: Uint64Kind | GoName: Oneof5Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_uint64")
			encoder.AppendUint64(v.Oneof5Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_sint32 | kind: Sint32Kind | GoName: Oneof5Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_sint32")
			encoder.AppendInt32(v.Oneof5Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_sint64 | kind: Sint64Kind | GoName: Oneof5Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_sint64")
			encoder.AppendInt64(v.Oneof5Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_fixed32 | kind: Fixed32Kind | GoName: Oneof5Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_fixed32")
			encoder.AppendUint32(v.Oneof5Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_fixed64 | kind: Fixed64Kind | GoName: Oneof5Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_fixed64")
			encoder.AppendUint64(v.Oneof5Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_sfixed32 | kind: Sfixed32Kind | GoName: Oneof5Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_sfixed32")
			encoder.AppendInt32(v.Oneof5Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_sfixed64 | kind: Sfixed64Kind | GoName: Oneof5Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_sfixed64")
			encoder.AppendInt64(v.Oneof5Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_bool | kind: BoolKind | GoName: Oneof5Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_bool")
			encoder.AppendBool(v.Oneof5Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_string | kind: StringKind | GoName: Oneof5String | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_string")
			encoder.AppendString(v.Oneof5String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_bytes | kind: BytesKind | GoName: Oneof5Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_bytes")
			encoder.AppendBytes(v.Oneof5Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof5EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_embed_message | kind: MessageKind | GoName: Oneof5EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_embed_message")
			err = encoder.AppendInterface(v.Oneof5EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof5StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_stand_message | kind: MessageKind | GoName: Oneof5StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_stand_message")
			err = encoder.AppendInterface(v.Oneof5StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof5ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_external_message | kind: MessageKind | GoName: Oneof5ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_external_message")
			err = encoder.AppendInterface(v.Oneof5ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof5EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_embed_enum | kind: EnumKind | GoName: Oneof5EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_embed_enum")
			encoder.AppendInt32(int32(v.Oneof5EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof5StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_stand_enum | kind: EnumKind | GoName: Oneof5StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_stand_enum")
			encoder.AppendInt32(int32(v.Oneof5StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof5ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof5_external_enum | kind: EnumKind | GoName: Oneof5ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_Type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof5_external_enum")
			encoder.AppendInt32(int32(v.Oneof5ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: oneof_Type5, goName: Oneof_Type5, field: gojsontest.Model1.oneof_Type5", v)
		}
	} else {
		encoder.AppendObjectKey("oneof_Type5")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.oneof_type6 | GoName: OneofType6 | omitempty: false | ignore: false
	if this.OneofType6 != nil {
		switch v := this.OneofType6.(type) {
		case *Model1_Oneof6Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_double | kind: DoubleKind | GoName: Oneof6Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_double")
			encoder.AppendFloat64(v.Oneof6Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_float | kind: FloatKind | GoName: Oneof6Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_float")
			encoder.AppendFloat32(v.Oneof6Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_int32 | kind: Int32Kind | GoName: Oneof6Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_int32")
			encoder.AppendInt32(v.Oneof6Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_int64 | kind: Int64Kind | GoName: Oneof6Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_int64")
			encoder.AppendInt64(v.Oneof6Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_uint32 | kind: Uint32Kind | GoName: Oneof6Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_uint32")
			encoder.AppendUint32(v.Oneof6Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_uint64 | kind: Uint64Kind | GoName: Oneof6Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_uint64")
			encoder.AppendUint64(v.Oneof6Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_sint32 | kind: Sint32Kind | GoName: Oneof6Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_sint32")
			encoder.AppendInt32(v.Oneof6Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_sint64 | kind: Sint64Kind | GoName: Oneof6Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_sint64")
			encoder.AppendInt64(v.Oneof6Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_fixed32 | kind: Fixed32Kind | GoName: Oneof6Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_fixed32")
			encoder.AppendUint32(v.Oneof6Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_fixed64 | kind: Fixed64Kind | GoName: Oneof6Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_fixed64")
			encoder.AppendUint64(v.Oneof6Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_sfixed32 | kind: Sfixed32Kind | GoName: Oneof6Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_sfixed32")
			encoder.AppendInt32(v.Oneof6Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_sfixed64 | kind: Sfixed64Kind | GoName: Oneof6Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_sfixed64")
			encoder.AppendInt64(v.Oneof6Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_bool | kind: BoolKind | GoName: Oneof6Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_bool")
			encoder.AppendBool(v.Oneof6Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_string | kind: StringKind | GoName: Oneof6String | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_string")
			encoder.AppendString(v.Oneof6String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_bytes | kind: BytesKind | GoName: Oneof6Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_bytes")
			encoder.AppendBytes(v.Oneof6Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof6EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_embed_message | kind: MessageKind | GoName: Oneof6EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_embed_message")
			err = encoder.AppendInterface(v.Oneof6EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof6StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_stand_message | kind: MessageKind | GoName: Oneof6StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_stand_message")
			err = encoder.AppendInterface(v.Oneof6StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof6ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_external_message | kind: MessageKind | GoName: Oneof6ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_external_message")
			err = encoder.AppendInterface(v.Oneof6ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof6EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_embed_enum | kind: EnumKind | GoName: Oneof6EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_embed_enum")
			encoder.AppendInt32(int32(v.Oneof6EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof6StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_stand_enum | kind: EnumKind | GoName: Oneof6StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_stand_enum")
			encoder.AppendInt32(int32(v.Oneof6StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof6ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof6_external_enum | kind: EnumKind | GoName: Oneof6ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof6_external_enum")
			encoder.AppendInt32(int32(v.Oneof6ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: oneof_type6, goName: OneofType6, field: gojsontest.Model1.oneof_type6", v)
		}
	} else {
		encoder.AppendObjectKey("oneof_type6")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_type7 | GoName: OneofType7 | omitempty: false | ignore: false
	if this.OneofType7 != nil {
		switch v := this.OneofType7.(type) {
		case *Model1_Oneof7Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_double | kind: DoubleKind | GoName: Oneof7Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_double")
			encoder.AppendFloat64(v.Oneof7Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_float | kind: FloatKind | GoName: Oneof7Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_float")
			encoder.AppendFloat32(v.Oneof7Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_int32 | kind: Int32Kind | GoName: Oneof7Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_int32")
			encoder.AppendInt32(v.Oneof7Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_int64 | kind: Int64Kind | GoName: Oneof7Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_int64")
			encoder.AppendInt64(v.Oneof7Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_uint32 | kind: Uint32Kind | GoName: Oneof7Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_uint32")
			encoder.AppendUint32(v.Oneof7Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_uint64 | kind: Uint64Kind | GoName: Oneof7Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_uint64")
			encoder.AppendUint64(v.Oneof7Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_sint32 | kind: Sint32Kind | GoName: Oneof7Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_sint32")
			encoder.AppendInt32(v.Oneof7Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_sint64 | kind: Sint64Kind | GoName: Oneof7Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_sint64")
			encoder.AppendInt64(v.Oneof7Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_fixed32 | kind: Fixed32Kind | GoName: Oneof7Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_fixed32")
			encoder.AppendUint32(v.Oneof7Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_fixed64 | kind: Fixed64Kind | GoName: Oneof7Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_fixed64")
			encoder.AppendUint64(v.Oneof7Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_sfixed32 | kind: Sfixed32Kind | GoName: Oneof7Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_sfixed32")
			encoder.AppendInt32(v.Oneof7Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_sfixed64 | kind: Sfixed64Kind | GoName: Oneof7Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_sfixed64")
			encoder.AppendInt64(v.Oneof7Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_bool | kind: BoolKind | GoName: Oneof7Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_bool")
			encoder.AppendBool(v.Oneof7Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_string | kind: StringKind | GoName: Oneof7String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_string")
			encoder.AppendString(v.Oneof7String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_bytes | kind: BytesKind | GoName: Oneof7Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_bytes")
			encoder.AppendBytes(v.Oneof7Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof7EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_embed_message | kind: MessageKind | GoName: Oneof7EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_embed_message")
			err = encoder.AppendInterface(v.Oneof7EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof7StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_stand_message | kind: MessageKind | GoName: Oneof7StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_stand_message")
			err = encoder.AppendInterface(v.Oneof7StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof7ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_external_message | kind: MessageKind | GoName: Oneof7ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_external_message")
			err = encoder.AppendInterface(v.Oneof7ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof7EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_embed_enum | kind: EnumKind | GoName: Oneof7EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_embed_enum")
			encoder.AppendInt32(int32(v.Oneof7EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof7StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_stand_enum | kind: EnumKind | GoName: Oneof7StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_stand_enum")
			encoder.AppendInt32(int32(v.Oneof7StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof7ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof7_external_enum | kind: EnumKind | GoName: Oneof7ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof7_external_enum")
			encoder.AppendInt32(int32(v.Oneof7ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_type7, goName: OneofType7, field: gojsontest.Model1.Oneof_type7", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_type7")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type8 | GoName: Oneof_Type8 | omitempty: false | ignore: false
	if this.Oneof_Type8 != nil {
		switch v := this.Oneof_Type8.(type) {
		case *Model1_Oneof8Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_double | kind: DoubleKind | GoName: Oneof8Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_double")
			encoder.AppendFloat64(v.Oneof8Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_float | kind: FloatKind | GoName: Oneof8Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_float")
			encoder.AppendFloat32(v.Oneof8Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_int32 | kind: Int32Kind | GoName: Oneof8Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_int32")
			encoder.AppendInt32(v.Oneof8Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_int64 | kind: Int64Kind | GoName: Oneof8Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_int64")
			encoder.AppendInt64(v.Oneof8Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_uint32 | kind: Uint32Kind | GoName: Oneof8Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_uint32")
			encoder.AppendUint32(v.Oneof8Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_uint64 | kind: Uint64Kind | GoName: Oneof8Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_uint64")
			encoder.AppendUint64(v.Oneof8Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_sint32 | kind: Sint32Kind | GoName: Oneof8Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_sint32")
			encoder.AppendInt32(v.Oneof8Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_sint64 | kind: Sint64Kind | GoName: Oneof8Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_sint64")
			encoder.AppendInt64(v.Oneof8Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_fixed32 | kind: Fixed32Kind | GoName: Oneof8Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_fixed32")
			encoder.AppendUint32(v.Oneof8Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_fixed64 | kind: Fixed64Kind | GoName: Oneof8Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_fixed64")
			encoder.AppendUint64(v.Oneof8Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_sfixed32 | kind: Sfixed32Kind | GoName: Oneof8Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_sfixed32")
			encoder.AppendInt32(v.Oneof8Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_sfixed64 | kind: Sfixed64Kind | GoName: Oneof8Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_sfixed64")
			encoder.AppendInt64(v.Oneof8Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_bool | kind: BoolKind | GoName: Oneof8Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_bool")
			encoder.AppendBool(v.Oneof8Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_string | kind: StringKind | GoName: Oneof8String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_string")
			encoder.AppendString(v.Oneof8String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_bytes | kind: BytesKind | GoName: Oneof8Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_bytes")
			encoder.AppendBytes(v.Oneof8Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof8EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_embed_message | kind: MessageKind | GoName: Oneof8EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_embed_message")
			err = encoder.AppendInterface(v.Oneof8EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof8StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_stand_message | kind: MessageKind | GoName: Oneof8StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_stand_message")
			err = encoder.AppendInterface(v.Oneof8StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof8ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_external_message | kind: MessageKind | GoName: Oneof8ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_external_message")
			err = encoder.AppendInterface(v.Oneof8ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof8EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_embed_enum | kind: EnumKind | GoName: Oneof8EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_embed_enum")
			encoder.AppendInt32(int32(v.Oneof8EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof8StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_stand_enum | kind: EnumKind | GoName: Oneof8StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_stand_enum")
			encoder.AppendInt32(int32(v.Oneof8StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof8ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof8_external_enum | kind: EnumKind | GoName: Oneof8ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof8_external_enum")
			encoder.AppendInt32(int32(v.Oneof8ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type8, goName: Oneof_Type8, field: gojsontest.Model1.Oneof_Type8", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type8")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type9 | GoName: Oneof_Type9 | omitempty: false | ignore: false
	if this.Oneof_Type9 != nil {
		switch v := this.Oneof_Type9.(type) {
		case *Model1_Oneof9Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_double | kind: DoubleKind | GoName: Oneof9Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_double")
			encoder.AppendFloat64(v.Oneof9Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_float | kind: FloatKind | GoName: Oneof9Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_float")
			encoder.AppendFloat32(v.Oneof9Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_int32 | kind: Int32Kind | GoName: Oneof9Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_int32")
			encoder.AppendInt32(v.Oneof9Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_int64 | kind: Int64Kind | GoName: Oneof9Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_int64")
			encoder.AppendInt64(v.Oneof9Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_uint32 | kind: Uint32Kind | GoName: Oneof9Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_uint32")
			encoder.AppendUint32(v.Oneof9Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_uint64 | kind: Uint64Kind | GoName: Oneof9Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_uint64")
			encoder.AppendUint64(v.Oneof9Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_sint32 | kind: Sint32Kind | GoName: Oneof9Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_sint32")
			encoder.AppendInt32(v.Oneof9Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_sint64 | kind: Sint64Kind | GoName: Oneof9Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_sint64")
			encoder.AppendInt64(v.Oneof9Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_fixed32 | kind: Fixed32Kind | GoName: Oneof9Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_fixed32")
			encoder.AppendUint32(v.Oneof9Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_fixed64 | kind: Fixed64Kind | GoName: Oneof9Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_fixed64")
			encoder.AppendUint64(v.Oneof9Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_sfixed32 | kind: Sfixed32Kind | GoName: Oneof9Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_sfixed32")
			encoder.AppendInt32(v.Oneof9Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_sfixed64 | kind: Sfixed64Kind | GoName: Oneof9Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_sfixed64")
			encoder.AppendInt64(v.Oneof9Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_bool | kind: BoolKind | GoName: Oneof9Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_bool")
			encoder.AppendBool(v.Oneof9Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_string | kind: StringKind | GoName: Oneof9String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_string")
			encoder.AppendString(v.Oneof9String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_bytes | kind: BytesKind | GoName: Oneof9Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_bytes")
			encoder.AppendBytes(v.Oneof9Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof9EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_embed_message | kind: MessageKind | GoName: Oneof9EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_embed_message")
			err = encoder.AppendInterface(v.Oneof9EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof9StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_stand_message | kind: MessageKind | GoName: Oneof9StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_stand_message")
			err = encoder.AppendInterface(v.Oneof9StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof9ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_external_message | kind: MessageKind | GoName: Oneof9ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_external_message")
			err = encoder.AppendInterface(v.Oneof9ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof9EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_embed_enum | kind: EnumKind | GoName: Oneof9EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_embed_enum")
			encoder.AppendInt32(int32(v.Oneof9EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof9StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_stand_enum | kind: EnumKind | GoName: Oneof9StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_stand_enum")
			encoder.AppendInt32(int32(v.Oneof9StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof9ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof9_external_enum | kind: EnumKind | GoName: Oneof9ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type9")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof9_external_enum")
			encoder.AppendInt32(int32(v.Oneof9ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type9, goName: Oneof_Type9, field: gojsontest.Model1.Oneof_Type9", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type9")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type10 | GoName: Oneof_Type10 | omitempty: false | ignore: false
	if this.Oneof_Type10 != nil {
		switch v := this.Oneof_Type10.(type) {
		case *Model1_Oneof10Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_double | kind: DoubleKind | GoName: Oneof10Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_double")
			encoder.AppendFloat64(v.Oneof10Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_float | kind: FloatKind | GoName: Oneof10Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_float")
			encoder.AppendFloat32(v.Oneof10Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_int32 | kind: Int32Kind | GoName: Oneof10Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_int32")
			encoder.AppendInt32(v.Oneof10Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_int64 | kind: Int64Kind | GoName: Oneof10Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_int64")
			encoder.AppendInt64(v.Oneof10Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_uint32 | kind: Uint32Kind | GoName: Oneof10Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_uint32")
			encoder.AppendUint32(v.Oneof10Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_uint64 | kind: Uint64Kind | GoName: Oneof10Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_uint64")
			encoder.AppendUint64(v.Oneof10Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_sint32 | kind: Sint32Kind | GoName: Oneof10Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_sint32")
			encoder.AppendInt32(v.Oneof10Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_sint64 | kind: Sint64Kind | GoName: Oneof10Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_sint64")
			encoder.AppendInt64(v.Oneof10Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_fixed32 | kind: Fixed32Kind | GoName: Oneof10Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_fixed32")
			encoder.AppendUint32(v.Oneof10Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_fixed64 | kind: Fixed64Kind | GoName: Oneof10Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_fixed64")
			encoder.AppendUint64(v.Oneof10Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_sfixed32 | kind: Sfixed32Kind | GoName: Oneof10Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_sfixed32")
			encoder.AppendInt32(v.Oneof10Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_sfixed64 | kind: Sfixed64Kind | GoName: Oneof10Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_sfixed64")
			encoder.AppendInt64(v.Oneof10Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_bool | kind: BoolKind | GoName: Oneof10Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_bool")
			encoder.AppendBool(v.Oneof10Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_string | kind: StringKind | GoName: Oneof10String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_string")
			encoder.AppendString(v.Oneof10String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_bytes | kind: BytesKind | GoName: Oneof10Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_bytes")
			encoder.AppendBytes(v.Oneof10Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof10EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_embed_message | kind: MessageKind | GoName: Oneof10EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_embed_message")
			err = encoder.AppendInterface(v.Oneof10EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof10StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_stand_message | kind: MessageKind | GoName: Oneof10StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_stand_message")
			err = encoder.AppendInterface(v.Oneof10StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof10ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_external_message | kind: MessageKind | GoName: Oneof10ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_external_message")
			err = encoder.AppendInterface(v.Oneof10ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof10EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_embed_enum | kind: EnumKind | GoName: Oneof10EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_embed_enum")
			encoder.AppendInt32(int32(v.Oneof10EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof10StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_stand_enum | kind: EnumKind | GoName: Oneof10StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_stand_enum")
			encoder.AppendInt32(int32(v.Oneof10StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof10ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof10_external_enum | kind: EnumKind | GoName: Oneof10ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type10")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof10_external_enum")
			encoder.AppendInt32(int32(v.Oneof10ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type10, goName: Oneof_Type10, field: gojsontest.Model1.Oneof_Type10", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type10")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type11 | GoName: Oneof_Type11 | omitempty: false | ignore: false
	if this.Oneof_Type11 != nil {
		switch v := this.Oneof_Type11.(type) {
		case *Model1_Oneof11Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_double | kind: DoubleKind | GoName: Oneof11Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_double")
			encoder.AppendFloat64(v.Oneof11Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_float | kind: FloatKind | GoName: Oneof11Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_float")
			encoder.AppendFloat32(v.Oneof11Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_int32 | kind: Int32Kind | GoName: Oneof11Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_int32")
			encoder.AppendInt32(v.Oneof11Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_int64 | kind: Int64Kind | GoName: Oneof11Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_int64")
			encoder.AppendInt64(v.Oneof11Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_uint32 | kind: Uint32Kind | GoName: Oneof11Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_uint32")
			encoder.AppendUint32(v.Oneof11Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_uint64 | kind: Uint64Kind | GoName: Oneof11Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_uint64")
			encoder.AppendUint64(v.Oneof11Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_sint32 | kind: Sint32Kind | GoName: Oneof11Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_sint32")
			encoder.AppendInt32(v.Oneof11Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_sint64 | kind: Sint64Kind | GoName: Oneof11Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_sint64")
			encoder.AppendInt64(v.Oneof11Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_fixed32 | kind: Fixed32Kind | GoName: Oneof11Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_fixed32")
			encoder.AppendUint32(v.Oneof11Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_fixed64 | kind: Fixed64Kind | GoName: Oneof11Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_fixed64")
			encoder.AppendUint64(v.Oneof11Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_sfixed32 | kind: Sfixed32Kind | GoName: Oneof11Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_sfixed32")
			encoder.AppendInt32(v.Oneof11Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_sfixed64 | kind: Sfixed64Kind | GoName: Oneof11Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_sfixed64")
			encoder.AppendInt64(v.Oneof11Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_bool | kind: BoolKind | GoName: Oneof11Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_bool")
			encoder.AppendBool(v.Oneof11Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_string | kind: StringKind | GoName: Oneof11String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_string")
			encoder.AppendString(v.Oneof11String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_bytes | kind: BytesKind | GoName: Oneof11Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_bytes")
			encoder.AppendBytes(v.Oneof11Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof11EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_embed_message | kind: MessageKind | GoName: Oneof11EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_embed_message")
			err = encoder.AppendInterface(v.Oneof11EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof11StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_stand_message | kind: MessageKind | GoName: Oneof11StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_stand_message")
			err = encoder.AppendInterface(v.Oneof11StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof11ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_external_message | kind: MessageKind | GoName: Oneof11ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_external_message")
			err = encoder.AppendInterface(v.Oneof11ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof11EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_embed_enum | kind: EnumKind | GoName: Oneof11EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_embed_enum")
			encoder.AppendInt32(int32(v.Oneof11EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof11StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_stand_enum | kind: EnumKind | GoName: Oneof11StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_stand_enum")
			encoder.AppendInt32(int32(v.Oneof11StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof11ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof11_external_enum | kind: EnumKind | GoName: Oneof11ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type11")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof11_external_enum")
			encoder.AppendInt32(int32(v.Oneof11ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type11, goName: Oneof_Type11, field: gojsontest.Model1.Oneof_Type11", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type11")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type12 | GoName: Oneof_Type12 | omitempty: false | ignore: false
	if this.Oneof_Type12 != nil {
		switch v := this.Oneof_Type12.(type) {
		case *Model1_Oneof12Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_double | kind: DoubleKind | GoName: Oneof12Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_double")
			encoder.AppendFloat64(v.Oneof12Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_float | kind: FloatKind | GoName: Oneof12Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_float")
			encoder.AppendFloat32(v.Oneof12Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_int32 | kind: Int32Kind | GoName: Oneof12Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_int32")
			encoder.AppendInt32(v.Oneof12Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_int64 | kind: Int64Kind | GoName: Oneof12Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_int64")
			encoder.AppendInt64(v.Oneof12Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_uint32 | kind: Uint32Kind | GoName: Oneof12Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_uint32")
			encoder.AppendUint32(v.Oneof12Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_uint64 | kind: Uint64Kind | GoName: Oneof12Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_uint64")
			encoder.AppendUint64(v.Oneof12Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_sint32 | kind: Sint32Kind | GoName: Oneof12Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_sint32")
			encoder.AppendInt32(v.Oneof12Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_sint64 | kind: Sint64Kind | GoName: Oneof12Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_sint64")
			encoder.AppendInt64(v.Oneof12Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_fixed32 | kind: Fixed32Kind | GoName: Oneof12Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_fixed32")
			encoder.AppendUint32(v.Oneof12Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_fixed64 | kind: Fixed64Kind | GoName: Oneof12Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_fixed64")
			encoder.AppendUint64(v.Oneof12Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_sfixed32 | kind: Sfixed32Kind | GoName: Oneof12Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_sfixed32")
			encoder.AppendInt32(v.Oneof12Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_sfixed64 | kind: Sfixed64Kind | GoName: Oneof12Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_sfixed64")
			encoder.AppendInt64(v.Oneof12Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_bool | kind: BoolKind | GoName: Oneof12Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_bool")
			encoder.AppendBool(v.Oneof12Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_string | kind: StringKind | GoName: Oneof12String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_string")
			encoder.AppendString(v.Oneof12String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_bytes | kind: BytesKind | GoName: Oneof12Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_bytes")
			encoder.AppendBytes(v.Oneof12Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof12EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_embed_message | kind: MessageKind | GoName: Oneof12EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_embed_message")
			err = encoder.AppendInterface(v.Oneof12EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof12StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_stand_message | kind: MessageKind | GoName: Oneof12StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_stand_message")
			err = encoder.AppendInterface(v.Oneof12StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof12ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_external_message | kind: MessageKind | GoName: Oneof12ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_external_message")
			err = encoder.AppendInterface(v.Oneof12ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof12EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_embed_enum | kind: EnumKind | GoName: Oneof12EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_embed_enum")
			encoder.AppendInt32(int32(v.Oneof12EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof12StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_stand_enum | kind: EnumKind | GoName: Oneof12StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_stand_enum")
			encoder.AppendInt32(int32(v.Oneof12StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof12ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof12_external_enum | kind: EnumKind | GoName: Oneof12ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type12")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof12_external_enum")
			encoder.AppendInt32(int32(v.Oneof12ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type12, goName: Oneof_Type12, field: gojsontest.Model1.Oneof_Type12", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type12")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type13 | GoName: Oneof_Type13 | omitempty: false | ignore: false
	if this.Oneof_Type13 != nil {
		switch v := this.Oneof_Type13.(type) {
		case *Model1_Oneof13Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_double | kind: DoubleKind | GoName: Oneof13Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_double")
			encoder.AppendFloat64(v.Oneof13Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_float | kind: FloatKind | GoName: Oneof13Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_float")
			encoder.AppendFloat32(v.Oneof13Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_int32 | kind: Int32Kind | GoName: Oneof13Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_int32")
			encoder.AppendInt32(v.Oneof13Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_int64 | kind: Int64Kind | GoName: Oneof13Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_int64")
			encoder.AppendInt64(v.Oneof13Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_uint32 | kind: Uint32Kind | GoName: Oneof13Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_uint32")
			encoder.AppendUint32(v.Oneof13Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_uint64 | kind: Uint64Kind | GoName: Oneof13Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_uint64")
			encoder.AppendUint64(v.Oneof13Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_sint32 | kind: Sint32Kind | GoName: Oneof13Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_sint32")
			encoder.AppendInt32(v.Oneof13Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_sint64 | kind: Sint64Kind | GoName: Oneof13Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_sint64")
			encoder.AppendInt64(v.Oneof13Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_fixed32 | kind: Fixed32Kind | GoName: Oneof13Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_fixed32")
			encoder.AppendUint32(v.Oneof13Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_fixed64 | kind: Fixed64Kind | GoName: Oneof13Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_fixed64")
			encoder.AppendUint64(v.Oneof13Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_sfixed32 | kind: Sfixed32Kind | GoName: Oneof13Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_sfixed32")
			encoder.AppendInt32(v.Oneof13Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_sfixed64 | kind: Sfixed64Kind | GoName: Oneof13Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_sfixed64")
			encoder.AppendInt64(v.Oneof13Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_bool | kind: BoolKind | GoName: Oneof13Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_bool")
			encoder.AppendBool(v.Oneof13Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_string | kind: StringKind | GoName: Oneof13String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_string")
			encoder.AppendString(v.Oneof13String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_bytes | kind: BytesKind | GoName: Oneof13Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_bytes")
			encoder.AppendBytes(v.Oneof13Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof13EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_embed_message | kind: MessageKind | GoName: Oneof13EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_embed_message")
			err = encoder.AppendInterface(v.Oneof13EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof13StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_stand_message | kind: MessageKind | GoName: Oneof13StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_stand_message")
			err = encoder.AppendInterface(v.Oneof13StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof13ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_external_message | kind: MessageKind | GoName: Oneof13ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_external_message")
			err = encoder.AppendInterface(v.Oneof13ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof13EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_embed_enum | kind: EnumKind | GoName: Oneof13EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_embed_enum")
			encoder.AppendInt32(int32(v.Oneof13EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof13StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_stand_enum | kind: EnumKind | GoName: Oneof13StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_stand_enum")
			encoder.AppendInt32(int32(v.Oneof13StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof13ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof13_external_enum | kind: EnumKind | GoName: Oneof13ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type13")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof13_external_enum")
			encoder.AppendInt32(int32(v.Oneof13ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type13, goName: Oneof_Type13, field: gojsontest.Model1.Oneof_Type13", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type13")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type14 | GoName: Oneof_Type14 | omitempty: false | ignore: false
	if this.Oneof_Type14 != nil {
		switch v := this.Oneof_Type14.(type) {
		case *Model1_Oneof14Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_double | kind: DoubleKind | GoName: Oneof14Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_double")
			encoder.AppendFloat64(v.Oneof14Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_float | kind: FloatKind | GoName: Oneof14Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_float")
			encoder.AppendFloat32(v.Oneof14Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_int32 | kind: Int32Kind | GoName: Oneof14Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_int32")
			encoder.AppendInt32(v.Oneof14Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_int64 | kind: Int64Kind | GoName: Oneof14Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_int64")
			encoder.AppendInt64(v.Oneof14Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_uint32 | kind: Uint32Kind | GoName: Oneof14Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_uint32")
			encoder.AppendUint32(v.Oneof14Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_uint64 | kind: Uint64Kind | GoName: Oneof14Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_uint64")
			encoder.AppendUint64(v.Oneof14Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_sint32 | kind: Sint32Kind | GoName: Oneof14Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_sint32")
			encoder.AppendInt32(v.Oneof14Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_sint64 | kind: Sint64Kind | GoName: Oneof14Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_sint64")
			encoder.AppendInt64(v.Oneof14Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_fixed32 | kind: Fixed32Kind | GoName: Oneof14Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_fixed32")
			encoder.AppendUint32(v.Oneof14Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_fixed64 | kind: Fixed64Kind | GoName: Oneof14Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_fixed64")
			encoder.AppendUint64(v.Oneof14Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_sfixed32 | kind: Sfixed32Kind | GoName: Oneof14Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_sfixed32")
			encoder.AppendInt32(v.Oneof14Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_sfixed64 | kind: Sfixed64Kind | GoName: Oneof14Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_sfixed64")
			encoder.AppendInt64(v.Oneof14Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_bool | kind: BoolKind | GoName: Oneof14Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_bool")
			encoder.AppendBool(v.Oneof14Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_string | kind: StringKind | GoName: Oneof14String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_string")
			encoder.AppendString(v.Oneof14String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_bytes | kind: BytesKind | GoName: Oneof14Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_bytes")
			encoder.AppendBytes(v.Oneof14Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof14EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_embed_message | kind: MessageKind | GoName: Oneof14EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_embed_message")
			err = encoder.AppendInterface(v.Oneof14EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof14StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_stand_message | kind: MessageKind | GoName: Oneof14StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_stand_message")
			err = encoder.AppendInterface(v.Oneof14StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof14ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_external_message | kind: MessageKind | GoName: Oneof14ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_external_message")
			err = encoder.AppendInterface(v.Oneof14ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof14EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_embed_enum | kind: EnumKind | GoName: Oneof14EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_embed_enum")
			encoder.AppendInt32(int32(v.Oneof14EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof14StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_stand_enum | kind: EnumKind | GoName: Oneof14StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_stand_enum")
			encoder.AppendInt32(int32(v.Oneof14StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof14ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof14_external_enum | kind: EnumKind | GoName: Oneof14ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type14")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof14_external_enum")
			encoder.AppendInt32(int32(v.Oneof14ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type14, goName: Oneof_Type14, field: gojsontest.Model1.Oneof_Type14", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type14")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type15 | GoName: Oneof_Type15 | omitempty: false | ignore: false
	if this.Oneof_Type15 != nil {
		switch v := this.Oneof_Type15.(type) {
		case *Model1_Oneof15Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_double | kind: DoubleKind | GoName: Oneof15Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_double")
			encoder.AppendFloat64(v.Oneof15Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_float | kind: FloatKind | GoName: Oneof15Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_float")
			encoder.AppendFloat32(v.Oneof15Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_int32 | kind: Int32Kind | GoName: Oneof15Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_int32")
			encoder.AppendInt32(v.Oneof15Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_int64 | kind: Int64Kind | GoName: Oneof15Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_int64")
			encoder.AppendInt64(v.Oneof15Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_uint32 | kind: Uint32Kind | GoName: Oneof15Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_uint32")
			encoder.AppendUint32(v.Oneof15Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_uint64 | kind: Uint64Kind | GoName: Oneof15Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_uint64")
			encoder.AppendUint64(v.Oneof15Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_sint32 | kind: Sint32Kind | GoName: Oneof15Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_sint32")
			encoder.AppendInt32(v.Oneof15Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_sint64 | kind: Sint64Kind | GoName: Oneof15Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_sint64")
			encoder.AppendInt64(v.Oneof15Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_fixed32 | kind: Fixed32Kind | GoName: Oneof15Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_fixed32")
			encoder.AppendUint32(v.Oneof15Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_fixed64 | kind: Fixed64Kind | GoName: Oneof15Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_fixed64")
			encoder.AppendUint64(v.Oneof15Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_sfixed32 | kind: Sfixed32Kind | GoName: Oneof15Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_sfixed32")
			encoder.AppendInt32(v.Oneof15Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_sfixed64 | kind: Sfixed64Kind | GoName: Oneof15Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_sfixed64")
			encoder.AppendInt64(v.Oneof15Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_bool | kind: BoolKind | GoName: Oneof15Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_bool")
			encoder.AppendBool(v.Oneof15Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_string | kind: StringKind | GoName: Oneof15String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_string")
			encoder.AppendString(v.Oneof15String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_bytes | kind: BytesKind | GoName: Oneof15Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_bytes")
			encoder.AppendBytes(v.Oneof15Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof15EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_embed_message | kind: MessageKind | GoName: Oneof15EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_embed_message")
			err = encoder.AppendInterface(v.Oneof15EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof15StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_stand_message | kind: MessageKind | GoName: Oneof15StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_stand_message")
			err = encoder.AppendInterface(v.Oneof15StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof15ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_external_message | kind: MessageKind | GoName: Oneof15ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_external_message")
			err = encoder.AppendInterface(v.Oneof15ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof15EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_embed_enum | kind: EnumKind | GoName: Oneof15EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_embed_enum")
			encoder.AppendInt32(int32(v.Oneof15EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof15StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_stand_enum | kind: EnumKind | GoName: Oneof15StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_stand_enum")
			encoder.AppendInt32(int32(v.Oneof15StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof15ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof15_external_enum | kind: EnumKind | GoName: Oneof15ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type15")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof15_external_enum")
			encoder.AppendInt32(int32(v.Oneof15ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type15, goName: Oneof_Type15, field: gojsontest.Model1.Oneof_Type15", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type15")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type16 | GoName: Oneof_Type16 | omitempty: false | ignore: false
	if this.Oneof_Type16 != nil {
		switch v := this.Oneof_Type16.(type) {
		case *Model1_Oneof16Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_double | kind: DoubleKind | GoName: Oneof16Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_double")
			encoder.AppendFloat64(v.Oneof16Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_float | kind: FloatKind | GoName: Oneof16Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_float")
			encoder.AppendFloat32(v.Oneof16Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_int32 | kind: Int32Kind | GoName: Oneof16Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_int32")
			encoder.AppendInt32(v.Oneof16Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_int64 | kind: Int64Kind | GoName: Oneof16Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_int64")
			encoder.AppendInt64(v.Oneof16Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_uint32 | kind: Uint32Kind | GoName: Oneof16Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_uint32")
			encoder.AppendUint32(v.Oneof16Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_uint64 | kind: Uint64Kind | GoName: Oneof16Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_uint64")
			encoder.AppendUint64(v.Oneof16Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_sint32 | kind: Sint32Kind | GoName: Oneof16Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_sint32")
			encoder.AppendInt32(v.Oneof16Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_sint64 | kind: Sint64Kind | GoName: Oneof16Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_sint64")
			encoder.AppendInt64(v.Oneof16Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_fixed32 | kind: Fixed32Kind | GoName: Oneof16Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_fixed32")
			encoder.AppendUint32(v.Oneof16Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_fixed64 | kind: Fixed64Kind | GoName: Oneof16Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_fixed64")
			encoder.AppendUint64(v.Oneof16Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_sfixed32 | kind: Sfixed32Kind | GoName: Oneof16Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_sfixed32")
			encoder.AppendInt32(v.Oneof16Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_sfixed64 | kind: Sfixed64Kind | GoName: Oneof16Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_sfixed64")
			encoder.AppendInt64(v.Oneof16Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_bool | kind: BoolKind | GoName: Oneof16Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_bool")
			encoder.AppendBool(v.Oneof16Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_string | kind: StringKind | GoName: Oneof16String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_string")
			encoder.AppendString(v.Oneof16String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_bytes | kind: BytesKind | GoName: Oneof16Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_bytes")
			encoder.AppendBytes(v.Oneof16Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof16EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_embed_message | kind: MessageKind | GoName: Oneof16EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_embed_message")
			err = encoder.AppendInterface(v.Oneof16EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof16StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_stand_message | kind: MessageKind | GoName: Oneof16StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_stand_message")
			err = encoder.AppendInterface(v.Oneof16StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof16ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_external_message | kind: MessageKind | GoName: Oneof16ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_external_message")
			err = encoder.AppendInterface(v.Oneof16ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof16EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_embed_enum | kind: EnumKind | GoName: Oneof16EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_embed_enum")
			encoder.AppendInt32(int32(v.Oneof16EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof16StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_stand_enum | kind: EnumKind | GoName: Oneof16StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_stand_enum")
			encoder.AppendInt32(int32(v.Oneof16StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof16ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof16_external_enum | kind: EnumKind | GoName: Oneof16ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type16")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof16_external_enum")
			encoder.AppendInt32(int32(v.Oneof16ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type16, goName: Oneof_Type16, field: gojsontest.Model1.Oneof_Type16", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type16")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type17 | GoName: Oneof_Type17 | omitempty: false | ignore: false
	if this.Oneof_Type17 != nil {
		switch v := this.Oneof_Type17.(type) {
		case *Model1_Oneof17Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_double | kind: DoubleKind | GoName: Oneof17Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_double")
			encoder.AppendFloat64(v.Oneof17Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_float | kind: FloatKind | GoName: Oneof17Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_float")
			encoder.AppendFloat32(v.Oneof17Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_int32 | kind: Int32Kind | GoName: Oneof17Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_int32")
			encoder.AppendInt32(v.Oneof17Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_int64 | kind: Int64Kind | GoName: Oneof17Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_int64")
			encoder.AppendInt64(v.Oneof17Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_uint32 | kind: Uint32Kind | GoName: Oneof17Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_uint32")
			encoder.AppendUint32(v.Oneof17Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_uint64 | kind: Uint64Kind | GoName: Oneof17Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_uint64")
			encoder.AppendUint64(v.Oneof17Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_sint32 | kind: Sint32Kind | GoName: Oneof17Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_sint32")
			encoder.AppendInt32(v.Oneof17Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_sint64 | kind: Sint64Kind | GoName: Oneof17Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_sint64")
			encoder.AppendInt64(v.Oneof17Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_fixed32 | kind: Fixed32Kind | GoName: Oneof17Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_fixed32")
			encoder.AppendUint32(v.Oneof17Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_fixed64 | kind: Fixed64Kind | GoName: Oneof17Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_fixed64")
			encoder.AppendUint64(v.Oneof17Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_sfixed32 | kind: Sfixed32Kind | GoName: Oneof17Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_sfixed32")
			encoder.AppendInt32(v.Oneof17Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_sfixed64 | kind: Sfixed64Kind | GoName: Oneof17Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_sfixed64")
			encoder.AppendInt64(v.Oneof17Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_bool | kind: BoolKind | GoName: Oneof17Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_bool")
			encoder.AppendBool(v.Oneof17Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_string | kind: StringKind | GoName: Oneof17String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_string")
			encoder.AppendString(v.Oneof17String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_bytes | kind: BytesKind | GoName: Oneof17Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_bytes")
			encoder.AppendBytes(v.Oneof17Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof17EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_embed_message | kind: MessageKind | GoName: Oneof17EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_embed_message")
			err = encoder.AppendInterface(v.Oneof17EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof17StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_stand_message | kind: MessageKind | GoName: Oneof17StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_stand_message")
			err = encoder.AppendInterface(v.Oneof17StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof17ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_external_message | kind: MessageKind | GoName: Oneof17ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_external_message")
			err = encoder.AppendInterface(v.Oneof17ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof17EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_embed_enum | kind: EnumKind | GoName: Oneof17EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_embed_enum")
			encoder.AppendInt32(int32(v.Oneof17EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof17StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_stand_enum | kind: EnumKind | GoName: Oneof17StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_stand_enum")
			encoder.AppendInt32(int32(v.Oneof17StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof17ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof17_external_enum | kind: EnumKind | GoName: Oneof17ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type17")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof17_external_enum")
			encoder.AppendInt32(int32(v.Oneof17ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type17, goName: Oneof_Type17, field: gojsontest.Model1.Oneof_Type17", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type17")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type18 | GoName: Oneof_Type18 | omitempty: false | ignore: false
	if this.Oneof_Type18 != nil {
		switch v := this.Oneof_Type18.(type) {
		case *Model1_Oneof18Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_double | kind: DoubleKind | GoName: Oneof18Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_double")
			encoder.AppendFloat64(v.Oneof18Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_float | kind: FloatKind | GoName: Oneof18Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_float")
			encoder.AppendFloat32(v.Oneof18Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_int32 | kind: Int32Kind | GoName: Oneof18Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_int32")
			encoder.AppendInt32(v.Oneof18Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_int64 | kind: Int64Kind | GoName: Oneof18Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_int64")
			encoder.AppendInt64(v.Oneof18Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_uint32 | kind: Uint32Kind | GoName: Oneof18Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_uint32")
			encoder.AppendUint32(v.Oneof18Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_uint64 | kind: Uint64Kind | GoName: Oneof18Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_uint64")
			encoder.AppendUint64(v.Oneof18Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_sint32 | kind: Sint32Kind | GoName: Oneof18Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_sint32")
			encoder.AppendInt32(v.Oneof18Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_sint64 | kind: Sint64Kind | GoName: Oneof18Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_sint64")
			encoder.AppendInt64(v.Oneof18Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_fixed32 | kind: Fixed32Kind | GoName: Oneof18Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_fixed32")
			encoder.AppendUint32(v.Oneof18Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_fixed64 | kind: Fixed64Kind | GoName: Oneof18Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_fixed64")
			encoder.AppendUint64(v.Oneof18Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_sfixed32 | kind: Sfixed32Kind | GoName: Oneof18Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_sfixed32")
			encoder.AppendInt32(v.Oneof18Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_sfixed64 | kind: Sfixed64Kind | GoName: Oneof18Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_sfixed64")
			encoder.AppendInt64(v.Oneof18Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_bool | kind: BoolKind | GoName: Oneof18Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_bool")
			encoder.AppendBool(v.Oneof18Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_string | kind: StringKind | GoName: Oneof18String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_string")
			encoder.AppendString(v.Oneof18String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_bytes | kind: BytesKind | GoName: Oneof18Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_bytes")
			encoder.AppendBytes(v.Oneof18Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof18EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_embed_message | kind: MessageKind | GoName: Oneof18EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_embed_message")
			err = encoder.AppendInterface(v.Oneof18EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof18StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_stand_message | kind: MessageKind | GoName: Oneof18StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_stand_message")
			err = encoder.AppendInterface(v.Oneof18StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof18ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_external_message | kind: MessageKind | GoName: Oneof18ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_external_message")
			err = encoder.AppendInterface(v.Oneof18ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof18EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_embed_enum | kind: EnumKind | GoName: Oneof18EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_embed_enum")
			encoder.AppendInt32(int32(v.Oneof18EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof18StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_stand_enum | kind: EnumKind | GoName: Oneof18StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_stand_enum")
			encoder.AppendInt32(int32(v.Oneof18StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof18ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof18_external_enum | kind: EnumKind | GoName: Oneof18ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type18")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof18_external_enum")
			encoder.AppendInt32(int32(v.Oneof18ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type18, goName: Oneof_Type18, field: gojsontest.Model1.Oneof_Type18", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type18")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type19 | GoName: Oneof_Type19 | omitempty: false | ignore: false
	if this.Oneof_Type19 != nil {
		switch v := this.Oneof_Type19.(type) {
		case *Model1_Oneof19Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_double | kind: DoubleKind | GoName: Oneof19Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_double")
			encoder.AppendFloat64(v.Oneof19Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_float | kind: FloatKind | GoName: Oneof19Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_float")
			encoder.AppendFloat32(v.Oneof19Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_int32 | kind: Int32Kind | GoName: Oneof19Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_int32")
			encoder.AppendInt32(v.Oneof19Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_int64 | kind: Int64Kind | GoName: Oneof19Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_int64")
			encoder.AppendInt64(v.Oneof19Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_uint32 | kind: Uint32Kind | GoName: Oneof19Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_uint32")
			encoder.AppendUint32(v.Oneof19Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_uint64 | kind: Uint64Kind | GoName: Oneof19Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_uint64")
			encoder.AppendUint64(v.Oneof19Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_sint32 | kind: Sint32Kind | GoName: Oneof19Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_sint32")
			encoder.AppendInt32(v.Oneof19Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_sint64 | kind: Sint64Kind | GoName: Oneof19Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_sint64")
			encoder.AppendInt64(v.Oneof19Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_fixed32 | kind: Fixed32Kind | GoName: Oneof19Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_fixed32")
			encoder.AppendUint32(v.Oneof19Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_fixed64 | kind: Fixed64Kind | GoName: Oneof19Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_fixed64")
			encoder.AppendUint64(v.Oneof19Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_sfixed32 | kind: Sfixed32Kind | GoName: Oneof19Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_sfixed32")
			encoder.AppendInt32(v.Oneof19Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_sfixed64 | kind: Sfixed64Kind | GoName: Oneof19Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_sfixed64")
			encoder.AppendInt64(v.Oneof19Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_bool | kind: BoolKind | GoName: Oneof19Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_bool")
			encoder.AppendBool(v.Oneof19Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_string | kind: StringKind | GoName: Oneof19String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_string")
			encoder.AppendString(v.Oneof19String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_bytes | kind: BytesKind | GoName: Oneof19Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_bytes")
			encoder.AppendBytes(v.Oneof19Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof19EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_embed_message | kind: MessageKind | GoName: Oneof19EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_embed_message")
			err = encoder.AppendInterface(v.Oneof19EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof19StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_stand_message | kind: MessageKind | GoName: Oneof19StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_stand_message")
			err = encoder.AppendInterface(v.Oneof19StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof19ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_external_message | kind: MessageKind | GoName: Oneof19ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_external_message")
			err = encoder.AppendInterface(v.Oneof19ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof19EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_embed_enum | kind: EnumKind | GoName: Oneof19EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_embed_enum")
			encoder.AppendInt32(int32(v.Oneof19EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof19StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_stand_enum | kind: EnumKind | GoName: Oneof19StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_stand_enum")
			encoder.AppendInt32(int32(v.Oneof19StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof19ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof19_external_enum | kind: EnumKind | GoName: Oneof19ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type19")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof19_external_enum")
			encoder.AppendInt32(int32(v.Oneof19ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type19, goName: Oneof_Type19, field: gojsontest.Model1.Oneof_Type19", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type19")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type20 | GoName: Oneof_Type20 | omitempty: false | ignore: false
	if this.Oneof_Type20 != nil {
		switch v := this.Oneof_Type20.(type) {
		case *Model1_Oneof20Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_double | kind: DoubleKind | GoName: Oneof20Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_double")
			encoder.AppendFloat64(v.Oneof20Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_float | kind: FloatKind | GoName: Oneof20Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_float")
			encoder.AppendFloat32(v.Oneof20Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_int32 | kind: Int32Kind | GoName: Oneof20Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_int32")
			encoder.AppendInt32(v.Oneof20Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_int64 | kind: Int64Kind | GoName: Oneof20Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_int64")
			encoder.AppendInt64(v.Oneof20Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_uint32 | kind: Uint32Kind | GoName: Oneof20Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_uint32")
			encoder.AppendUint32(v.Oneof20Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_uint64 | kind: Uint64Kind | GoName: Oneof20Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_uint64")
			encoder.AppendUint64(v.Oneof20Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_sint32 | kind: Sint32Kind | GoName: Oneof20Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_sint32")
			encoder.AppendInt32(v.Oneof20Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_sint64 | kind: Sint64Kind | GoName: Oneof20Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_sint64")
			encoder.AppendInt64(v.Oneof20Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_fixed32 | kind: Fixed32Kind | GoName: Oneof20Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_fixed32")
			encoder.AppendUint32(v.Oneof20Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_fixed64 | kind: Fixed64Kind | GoName: Oneof20Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_fixed64")
			encoder.AppendUint64(v.Oneof20Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_sfixed32 | kind: Sfixed32Kind | GoName: Oneof20Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_sfixed32")
			encoder.AppendInt32(v.Oneof20Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_sfixed64 | kind: Sfixed64Kind | GoName: Oneof20Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_sfixed64")
			encoder.AppendInt64(v.Oneof20Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_bool | kind: BoolKind | GoName: Oneof20Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_bool")
			encoder.AppendBool(v.Oneof20Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_string | kind: StringKind | GoName: Oneof20String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_string")
			encoder.AppendString(v.Oneof20String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_bytes | kind: BytesKind | GoName: Oneof20Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_bytes")
			encoder.AppendBytes(v.Oneof20Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof20EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_embed_message | kind: MessageKind | GoName: Oneof20EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_embed_message")
			err = encoder.AppendInterface(v.Oneof20EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof20StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_stand_message | kind: MessageKind | GoName: Oneof20StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_stand_message")
			err = encoder.AppendInterface(v.Oneof20StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof20ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_external_message | kind: MessageKind | GoName: Oneof20ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_external_message")
			err = encoder.AppendInterface(v.Oneof20ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof20EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_embed_enum | kind: EnumKind | GoName: Oneof20EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_embed_enum")
			encoder.AppendInt32(int32(v.Oneof20EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof20StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_stand_enum | kind: EnumKind | GoName: Oneof20StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_stand_enum")
			encoder.AppendInt32(int32(v.Oneof20StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof20ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof20_external_enum | kind: EnumKind | GoName: Oneof20ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type20")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof20_external_enum")
			encoder.AppendInt32(int32(v.Oneof20ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type20, goName: Oneof_Type20, field: gojsontest.Model1.Oneof_Type20", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type20")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type21 | GoName: Oneof_Type21 | omitempty: false | ignore: false
	if this.Oneof_Type21 != nil {
		switch v := this.Oneof_Type21.(type) {
		case *Model1_Oneof21Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_double | kind: DoubleKind | GoName: Oneof21Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_double")
			encoder.AppendFloat64(v.Oneof21Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_float | kind: FloatKind | GoName: Oneof21Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_float")
			encoder.AppendFloat32(v.Oneof21Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_int32 | kind: Int32Kind | GoName: Oneof21Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_int32")
			encoder.AppendInt32(v.Oneof21Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_int64 | kind: Int64Kind | GoName: Oneof21Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_int64")
			encoder.AppendInt64(v.Oneof21Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_uint32 | kind: Uint32Kind | GoName: Oneof21Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_uint32")
			encoder.AppendUint32(v.Oneof21Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_uint64 | kind: Uint64Kind | GoName: Oneof21Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_uint64")
			encoder.AppendUint64(v.Oneof21Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_sint32 | kind: Sint32Kind | GoName: Oneof21Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_sint32")
			encoder.AppendInt32(v.Oneof21Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_sint64 | kind: Sint64Kind | GoName: Oneof21Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_sint64")
			encoder.AppendInt64(v.Oneof21Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_fixed32 | kind: Fixed32Kind | GoName: Oneof21Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_fixed32")
			encoder.AppendUint32(v.Oneof21Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_fixed64 | kind: Fixed64Kind | GoName: Oneof21Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_fixed64")
			encoder.AppendUint64(v.Oneof21Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_sfixed32 | kind: Sfixed32Kind | GoName: Oneof21Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_sfixed32")
			encoder.AppendInt32(v.Oneof21Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_sfixed64 | kind: Sfixed64Kind | GoName: Oneof21Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_sfixed64")
			encoder.AppendInt64(v.Oneof21Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_bool | kind: BoolKind | GoName: Oneof21Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_bool")
			encoder.AppendBool(v.Oneof21Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_string | kind: StringKind | GoName: Oneof21String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_string")
			encoder.AppendString(v.Oneof21String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_bytes | kind: BytesKind | GoName: Oneof21Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_bytes")
			encoder.AppendBytes(v.Oneof21Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof21EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_embed_message | kind: MessageKind | GoName: Oneof21EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_embed_message")
			err = encoder.AppendInterface(v.Oneof21EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof21StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_stand_message | kind: MessageKind | GoName: Oneof21StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_stand_message")
			err = encoder.AppendInterface(v.Oneof21StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof21ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_external_message | kind: MessageKind | GoName: Oneof21ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_external_message")
			err = encoder.AppendInterface(v.Oneof21ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof21EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_embed_enum | kind: EnumKind | GoName: Oneof21EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_embed_enum")
			encoder.AppendInt32(int32(v.Oneof21EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof21StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_stand_enum | kind: EnumKind | GoName: Oneof21StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_stand_enum")
			encoder.AppendInt32(int32(v.Oneof21StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof21ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof21_external_enum | kind: EnumKind | GoName: Oneof21ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type21")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof21_external_enum")
			encoder.AppendInt32(int32(v.Oneof21ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type21, goName: Oneof_Type21, field: gojsontest.Model1.Oneof_Type21", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type21")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type22_null | GoName: Oneof_Type22Null | omitempty: false | ignore: false
	if this.Oneof_Type22Null != nil {
		switch v := this.Oneof_Type22Null.(type) {
		case *Model1_Oneof22Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_double | kind: DoubleKind | GoName: Oneof22Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_double")
			encoder.AppendFloat64(v.Oneof22Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_float | kind: FloatKind | GoName: Oneof22Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_float")
			encoder.AppendFloat32(v.Oneof22Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_int32 | kind: Int32Kind | GoName: Oneof22Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_int32")
			encoder.AppendInt32(v.Oneof22Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_int64 | kind: Int64Kind | GoName: Oneof22Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_int64")
			encoder.AppendInt64(v.Oneof22Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_uint32 | kind: Uint32Kind | GoName: Oneof22Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_uint32")
			encoder.AppendUint32(v.Oneof22Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_uint64 | kind: Uint64Kind | GoName: Oneof22Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_uint64")
			encoder.AppendUint64(v.Oneof22Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_sint32 | kind: Sint32Kind | GoName: Oneof22Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_sint32")
			encoder.AppendInt32(v.Oneof22Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_sint64 | kind: Sint64Kind | GoName: Oneof22Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_sint64")
			encoder.AppendInt64(v.Oneof22Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_fixed32 | kind: Fixed32Kind | GoName: Oneof22Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_fixed32")
			encoder.AppendUint32(v.Oneof22Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_fixed64 | kind: Fixed64Kind | GoName: Oneof22Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_fixed64")
			encoder.AppendUint64(v.Oneof22Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_sfixed32 | kind: Sfixed32Kind | GoName: Oneof22Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_sfixed32")
			encoder.AppendInt32(v.Oneof22Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_sfixed64 | kind: Sfixed64Kind | GoName: Oneof22Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_sfixed64")
			encoder.AppendInt64(v.Oneof22Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_bool | kind: BoolKind | GoName: Oneof22Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_bool")
			encoder.AppendBool(v.Oneof22Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_string | kind: StringKind | GoName: Oneof22String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_string")
			encoder.AppendString(v.Oneof22String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_bytes | kind: BytesKind | GoName: Oneof22Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_bytes")
			encoder.AppendBytes(v.Oneof22Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof22EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_embed_message | kind: MessageKind | GoName: Oneof22EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_embed_message")
			err = encoder.AppendInterface(v.Oneof22EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof22StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_stand_message | kind: MessageKind | GoName: Oneof22StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_stand_message")
			err = encoder.AppendInterface(v.Oneof22StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof22ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_external_message | kind: MessageKind | GoName: Oneof22ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_external_message")
			err = encoder.AppendInterface(v.Oneof22ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof22EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_embed_enum | kind: EnumKind | GoName: Oneof22EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_embed_enum")
			encoder.AppendInt32(int32(v.Oneof22EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof22StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_stand_enum | kind: EnumKind | GoName: Oneof22StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_stand_enum")
			encoder.AppendInt32(int32(v.Oneof22StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof22ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof22_external_enum | kind: EnumKind | GoName: Oneof22ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type22_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof22_external_enum")
			encoder.AppendInt32(int32(v.Oneof22ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type22_null, goName: Oneof_Type22Null, field: gojsontest.Model1.Oneof_Type22_null", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type22_null")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.Model1.Oneof_Type23_null | GoName: Oneof_Type23Null | omitempty: false | ignore: false
	if this.Oneof_Type23Null != nil {
		switch v := this.Oneof_Type23Null.(type) {
		case *Model1_Oneof23Double:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_double | kind: DoubleKind | GoName: Oneof23Double | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_double")
			encoder.AppendFloat64(v.Oneof23Double)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Float:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_float | kind: FloatKind | GoName: Oneof23Float | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_float")
			encoder.AppendFloat32(v.Oneof23Float)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Int32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_int32 | kind: Int32Kind | GoName: Oneof23Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_int32")
			encoder.AppendInt32(v.Oneof23Int32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Int64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_int64 | kind: Int64Kind | GoName: Oneof23Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_int64")
			encoder.AppendInt64(v.Oneof23Int64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Uint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_uint32 | kind: Uint32Kind | GoName: Oneof23Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_uint32")
			encoder.AppendUint32(v.Oneof23Uint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Uint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_uint64 | kind: Uint64Kind | GoName: Oneof23Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_uint64")
			encoder.AppendUint64(v.Oneof23Uint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Sint32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_sint32 | kind: Sint32Kind | GoName: Oneof23Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_sint32")
			encoder.AppendInt32(v.Oneof23Sint32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Sint64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_sint64 | kind: Sint64Kind | GoName: Oneof23Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_sint64")
			encoder.AppendInt64(v.Oneof23Sint64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Fixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_fixed32 | kind: Fixed32Kind | GoName: Oneof23Fixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_fixed32")
			encoder.AppendUint32(v.Oneof23Fixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Fixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_fixed64 | kind: Fixed64Kind | GoName: Oneof23Fixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_fixed64")
			encoder.AppendUint64(v.Oneof23Fixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Sfixed32:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_sfixed32 | kind: Sfixed32Kind | GoName: Oneof23Sfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_sfixed32")
			encoder.AppendInt32(v.Oneof23Sfixed32)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Sfixed64:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_sfixed64 | kind: Sfixed64Kind | GoName: Oneof23Sfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_sfixed64")
			encoder.AppendInt64(v.Oneof23Sfixed64)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Bool:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_bool | kind: BoolKind | GoName: Oneof23Bool | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_bool")
			encoder.AppendBool(v.Oneof23Bool)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23String:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_string | kind: StringKind | GoName: Oneof23String | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_string")
			encoder.AppendString(v.Oneof23String)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23Bytes:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_bytes | kind: BytesKind | GoName: Oneof23Bytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_bytes")
			encoder.AppendBytes(v.Oneof23Bytes)
			encoder.AppendObjectEnd()
		case *Model1_Oneof23EmbedMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_embed_message | kind: MessageKind | GoName: Oneof23EmbedMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_embed_message")
			err = encoder.AppendInterface(v.Oneof23EmbedMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof23StandMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_stand_message | kind: MessageKind | GoName: Oneof23StandMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_stand_message")
			err = encoder.AppendInterface(v.Oneof23StandMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof23ExternalMessage:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_external_message | kind: MessageKind | GoName: Oneof23ExternalMessage | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_external_message")
			err = encoder.AppendInterface(v.Oneof23ExternalMessage)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *Model1_Oneof23EmbedEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_embed_enum | kind: EnumKind | GoName: Oneof23EmbedEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_embed_enum")
			encoder.AppendInt32(int32(v.Oneof23EmbedEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof23StandEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_stand_enum | kind: EnumKind | GoName: Oneof23StandEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_stand_enum")
			encoder.AppendInt32(int32(v.Oneof23StandEnum.Number()))
			encoder.AppendObjectEnd()
		case *Model1_Oneof23ExternalEnum:
			// encode filed type of basic; | field: gojsontest.Model1.oneof23_external_enum | kind: EnumKind | GoName: Oneof23ExternalEnum | omitempty: false | ignore: false
			encoder.AppendObjectKey("Oneof_Type23_null")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("oneof23_external_enum")
			encoder.AppendInt32(int32(v.Oneof23ExternalEnum.Number()))
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Oneof_Type23_null, goName: Oneof_Type23Null, field: gojsontest.Model1.Oneof_Type23_null", v)
		}
	} else {
		encoder.AppendObjectKey("Oneof_Type23_null")
		encoder.AppendNil()
	}
	// encode filed type of basic; | field: gojsontest.Model1.type_double1 | kind: DoubleKind | GoName: TypeDouble1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_double1")
	encoder.AppendFloat64(this.TypeDouble1)
	// encode filed type of basic; | field: gojsontest.Model1.TypeDouble2 | kind: DoubleKind | GoName: TypeDouble2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_double2")
	encoder.AppendFloat64(this.TypeDouble2)
	// encode filed type of basic; | field: gojsontest.Model1.typeDouble3 | kind: DoubleKind | GoName: TypeDouble3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("typeDouble3")
	encoder.AppendFloat64(this.TypeDouble3)
	// encode filed type of basic; | field: gojsontest.Model1.Type_double4 | kind: DoubleKind | GoName: TypeDouble4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Type_double4")
	encoder.AppendFloat64(this.TypeDouble4)
	// encode filed type of basic; | field: gojsontest.Model1.Type_Double5 | kind: DoubleKind | GoName: Type_Double5 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Type_Double5")
	encoder.AppendFloat64(this.Type_Double5)
	// encode filed type of basic; | field: gojsontest.Model1.type_float | kind: FloatKind | GoName: TypeFloat | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_float")
	encoder.AppendFloat32(this.TypeFloat)
	// encode filed type of basic; | field: gojsontest.Model1.type_int32 | kind: Int32Kind | GoName: TypeInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_int32")
	encoder.AppendInt32(this.TypeInt32)
	// encode filed type of basic; | field: gojsontest.Model1.type_int64 | kind: Int64Kind | GoName: TypeInt64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_int64")
	encoder.AppendInt64(this.TypeInt64)
	// encode filed type of basic; | field: gojsontest.Model1.type_uint32 | kind: Uint32Kind | GoName: TypeUint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_uint32")
	encoder.AppendUint32(this.TypeUint32)
	// encode filed type of basic; | field: gojsontest.Model1.type_uint64 | kind: Uint64Kind | GoName: TypeUint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_uint64")
	encoder.AppendUint64(this.TypeUint64)
	// encode filed type of basic; | field: gojsontest.Model1.type_sint32 | kind: Sint32Kind | GoName: TypeSint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_sint32")
	encoder.AppendInt32(this.TypeSint32)
	// encode filed type of basic; | field: gojsontest.Model1.type_sint64 | kind: Sint64Kind | GoName: TypeSint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_sint64")
	encoder.AppendInt64(this.TypeSint64)
	// encode filed type of basic; | field: gojsontest.Model1.type_fixed32 | kind: Fixed32Kind | GoName: TypeFixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_fixed32")
	encoder.AppendUint32(this.TypeFixed32)
	// encode filed type of basic; | field: gojsontest.Model1.type_fixed64 | kind: Fixed64Kind | GoName: TypeFixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_fixed64")
	encoder.AppendUint64(this.TypeFixed64)
	// encode filed type of basic; | field: gojsontest.Model1.type_sfixed32 | kind: Sfixed32Kind | GoName: TypeSfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_sfixed32")
	encoder.AppendInt32(this.TypeSfixed32)
	// encode filed type of basic; | field: gojsontest.Model1.type_sfixed64 | kind: Sfixed64Kind | GoName: TypeSfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_sfixed64")
	encoder.AppendInt64(this.TypeSfixed64)
	// encode filed type of basic; | field: gojsontest.Model1.type_bool1 | kind: BoolKind | GoName: TypeBool1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_bool1")
	encoder.AppendBool(this.TypeBool1)
	// encode filed type of basic; | field: gojsontest.Model1.type_bool2 | kind: BoolKind | GoName: TypeBool2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_bool2")
	encoder.AppendBool(this.TypeBool2)
	// encode filed type of basic; | field: gojsontest.Model1.type_string1 | kind: StringKind | GoName: TypeString1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string1")
	encoder.AppendString(this.TypeString1)
	// encode filed type of basic; | field: gojsontest.Model1.type_string2 | kind: StringKind | GoName: TypeString2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string2")
	encoder.AppendString(this.TypeString2)
	// encode filed type of basic; | field: gojsontest.Model1.type_string3 | kind: StringKind | GoName: TypeString3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string3")
	encoder.AppendString(this.TypeString3)
	// encode filed type of basic; | field: gojsontest.Model1.type_string4 | kind: StringKind | GoName: TypeString4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string4")
	encoder.AppendString(this.TypeString4)
	// encode filed type of basic; | field: gojsontest.Model1.type_string5 | kind: StringKind | GoName: TypeString5 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string5")
	encoder.AppendString(this.TypeString5)
	// encode filed type of basic; | field: gojsontest.Model1.type_bytes | kind: BytesKind | GoName: TypeBytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_bytes")
	encoder.AppendBytes(this.TypeBytes)
	// encode filed type of basic; | field: gojsontest.Model1.type_embed_message | kind: MessageKind | GoName: TypeEmbedMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_embed_message")
	err = encoder.AppendInterface(this.TypeEmbedMessage)
	if err != nil {
		return nil, err
	}
	// encode filed type of basic; | field: gojsontest.Model1.type_stand_message | kind: MessageKind | GoName: TypeStandMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_stand_message")
	err = encoder.AppendInterface(this.TypeStandMessage)
	if err != nil {
		return nil, err
	}
	// encode filed type of basic; | field: gojsontest.Model1.type_embed_enum | kind: EnumKind | GoName: TypeEmbedEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_embed_enum")
	encoder.AppendInt32(int32(this.TypeEmbedEnum.Number()))
	// encode filed type of basic; | field: gojsontest.Model1.type_stand_enum | kind: EnumKind | GoName: TypeStandEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_stand_enum")
	encoder.AppendInt32(int32(this.TypeStandEnum.Number()))
	// encode filed type of basic; | field: gojsontest.Model1.type_external_enum | kind: EnumKind | GoName: TypeExternalEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_external_enum")
	encoder.AppendInt32(int32(this.TypeExternalEnum.Number()))
	// encode filed type of basic; | field: gojsontest.Model1.type_external_message | kind: MessageKind | GoName: TypeExternalMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_external_message")
	err = encoder.AppendInterface(this.TypeExternalMessage)
	if err != nil {
		return nil, err
	}
	// encode filed type of basic; | field: gojsontest.Model1.type_bytes_null | kind: BytesKind | GoName: TypeBytesNull | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_bytes_null")
	encoder.AppendBytes(this.TypeBytesNull)
	// encode filed type of basic; | field: gojsontest.Model1.type_embed_message_null | kind: MessageKind | GoName: TypeEmbedMessageNull | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_embed_message_null")
	err = encoder.AppendInterface(this.TypeEmbedMessageNull)
	if err != nil {
		return nil, err
	}
	// encode filed type of basic; | field: gojsontest.Model1.type_stand_message_null | kind: MessageKind | GoName: TypeStandMessageNull | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_stand_message_null")
	err = encoder.AppendInterface(this.TypeStandMessageNull)
	if err != nil {
		return nil, err
	}
	// encode filed type of basic; | field: gojsontest.Model1.type_external_message_null | kind: MessageKind | GoName: TypeExternalMessageNull | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_external_message_null")
	err = encoder.AppendInterface(this.TypeExternalMessageNull)
	if err != nil {
		return nil, err
	}
	// encode field type of list; | field: gojsontest.Model1.array_double | kind:DoubleKind | goName: ArrayDouble | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_double")
	if this.ArrayDouble != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayDouble {
			encoder.AppendFloat64(this.ArrayDouble[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_float | kind:FloatKind | goName: ArrayFloat | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_float")
	if this.ArrayFloat != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayFloat {
			encoder.AppendFloat32(this.ArrayFloat[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_int32 | kind:Int32Kind | goName: ArrayInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_int32")
	if this.ArrayInt32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayInt32 {
			encoder.AppendInt32(this.ArrayInt32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_int64 | kind:Int64Kind | goName: ArrayInt64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_int64")
	if this.ArrayInt64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayInt64 {
			encoder.AppendInt64(this.ArrayInt64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_uint32 | kind:Uint32Kind | goName: ArrayUint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_uint32")
	if this.ArrayUint32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayUint32 {
			encoder.AppendUint32(this.ArrayUint32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_uint64 | kind:Uint64Kind | goName: ArrayUint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_uint64")
	if this.ArrayUint64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayUint64 {
			encoder.AppendUint64(this.ArrayUint64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_sint32 | kind:Sint32Kind | goName: ArraySint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sint32")
	if this.ArraySint32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySint32 {
			encoder.AppendInt32(this.ArraySint32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_sint64 | kind:Sint64Kind | goName: ArraySint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sint64")
	if this.ArraySint64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySint64 {
			encoder.AppendInt64(this.ArraySint64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_fixed32 | kind:Fixed32Kind | goName: ArrayFixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_fixed32")
	if this.ArrayFixed32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayFixed32 {
			encoder.AppendUint32(this.ArrayFixed32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_fixed64 | kind:Fixed64Kind | goName: ArrayFixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_fixed64")
	if this.ArrayFixed64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayFixed64 {
			encoder.AppendUint64(this.ArrayFixed64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_sfixed32 | kind:Sfixed32Kind | goName: ArraySfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sfixed32")
	if this.ArraySfixed32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySfixed32 {
			encoder.AppendInt32(this.ArraySfixed32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_sfixed64 | kind:Sfixed64Kind | goName: ArraySfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sfixed64")
	if this.ArraySfixed64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySfixed64 {
			encoder.AppendInt64(this.ArraySfixed64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_bool | kind:BoolKind | goName: ArrayBool | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_bool")
	if this.ArrayBool != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayBool {
			encoder.AppendBool(this.ArrayBool[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_string | kind:StringKind | goName: ArrayString | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_string")
	if this.ArrayString != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayString {
			encoder.AppendString(this.ArrayString[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_bytes | kind:BytesKind | goName: ArrayBytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_bytes")
	if this.ArrayBytes != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayBytes {
			encoder.AppendBytes(this.ArrayBytes[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_embed_message | kind:MessageKind | goName: ArrayEmbedMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_embed_message")
	if this.ArrayEmbedMessage != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayEmbedMessage {
			err = encoder.AppendInterface(this.ArrayEmbedMessage[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_stand_message | kind:MessageKind | goName: ArrayStandMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_stand_message")
	if this.ArrayStandMessage != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayStandMessage {
			err = encoder.AppendInterface(this.ArrayStandMessage[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_external_message | kind:MessageKind | goName: ArrayExternalMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_external_message")
	if this.ArrayExternalMessage != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayExternalMessage {
			err = encoder.AppendInterface(this.ArrayExternalMessage[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_embed_enum | kind:EnumKind | goName: ArrayEmbedEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_embed_enum")
	if this.ArrayEmbedEnum != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayEmbedEnum {
			encoder.AppendInt32(int32(this.ArrayEmbedEnum[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_stand_enum | kind:EnumKind | goName: ArrayStandEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_stand_enum")
	if this.ArrayStandEnum != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayStandEnum {
			encoder.AppendInt32(int32(this.ArrayStandEnum[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_external_enum | kind:EnumKind | goName: ArrayExternalEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_external_enum")
	if this.ArrayExternalEnum != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayExternalEnum {
			encoder.AppendInt32(int32(this.ArrayExternalEnum[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model1.array_stand_enum_null | kind:EnumKind | goName: ArrayStandEnumNull | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_stand_enum_null")
	if this.ArrayStandEnumNull != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayStandEnumNull {
			encoder.AppendInt32(int32(this.ArrayStandEnumNull[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_double | keyKind: int32 | valueKind: double | goName: MapInt32Double | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_double")
	if this.MapInt32Double != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Double {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendFloat64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_float | keyKind: int32 | valueKind: float | goName: MapInt32Float | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_float")
	if this.MapInt32Float != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Float {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendFloat32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_int32 | keyKind: int32 | valueKind: int32 | goName: MapInt32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_int32")
	if this.MapInt32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_int64 | keyKind: int32 | valueKind: int64 | goName: MapInt32Int64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_int64")
	if this.MapInt32Int64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Int64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_uint32 | keyKind: int32 | valueKind: uint32 | goName: MapInt32Uint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_uint32")
	if this.MapInt32Uint32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Uint32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_uint64 | keyKind: int32 | valueKind: uint64 | goName: MapInt32Uint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_uint64")
	if this.MapInt32Uint64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Uint64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_sint32 | keyKind: int32 | valueKind: sint32 | goName: MapInt32Sint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sint32")
	if this.MapInt32Sint32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sint32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_sint64 | keyKind: int32 | valueKind: sint64 | goName: MapInt32Sint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sint64")
	if this.MapInt32Sint64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sint64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_fixed32 | keyKind: int32 | valueKind: fixed32 | goName: MapInt32Fixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_fixed32")
	if this.MapInt32Fixed32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Fixed32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_fixed64 | keyKind: int32 | valueKind: fixed64 | goName: MapInt32Fixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_fixed64")
	if this.MapInt32Fixed64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Fixed64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_sfixed32 | keyKind: int32 | valueKind: sfixed32 | goName: MapInt32Sfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sfixed32")
	if this.MapInt32Sfixed32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sfixed32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_sfixed64 | keyKind: int32 | valueKind: sfixed64 | goName: MapInt32Sfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sfixed64")
	if this.MapInt32Sfixed64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sfixed64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_bool | keyKind: int32 | valueKind: bool | goName: MapInt32Bool | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_bool")
	if this.MapInt32Bool != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Bool {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendBool(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_string | keyKind: int32 | valueKind: string | goName: MapInt32String | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_string")
	if this.MapInt32String != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32String {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_bytes | keyKind: int32 | valueKind: bytes | goName: MapInt32Bytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_bytes")
	if this.MapInt32Bytes != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Bytes {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_embed_message | keyKind: int32 | valueKind: message | goName: MapInt32EmbedMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_embed_message")
	if this.MapInt32EmbedMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32EmbedMessage {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_stand_message | keyKind: int32 | valueKind: message | goName: MapInt32StandMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_stand_message")
	if this.MapInt32StandMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32StandMessage {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_embed_enum | keyKind: int32 | valueKind: enum | goName: MapInt32EmbedEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_embed_enum")
	if this.MapInt32EmbedEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32EmbedEnum {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int32_stand_enum | keyKind: int32 | valueKind: enum | goName: MapInt32StandEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_stand_enum")
	if this.MapInt32StandEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32StandEnum {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_int64_int32 | keyKind: int64 | valueKind: int32 | goName: MapInt64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int64_int32")
	if this.MapInt64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_uint32_int32 | keyKind: uint32 | valueKind: int32 | goName: MapUint32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_uint32_int32")
	if this.MapUint32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapUint32Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(uint64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_uint64_int32 | keyKind: uint64 | valueKind: int32 | goName: MapUint64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_uint64_int32")
	if this.MapUint64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapUint64Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_sint32_int32 | keyKind: sint32 | valueKind: int32 | goName: MapSint32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sint32_int32")
	if this.MapSint32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSint32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_sint64_int32 | keyKind: sint64 | valueKind: int32 | goName: MapSint64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sint64_int32")
	if this.MapSint64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSint64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_fixed32_int32 | keyKind: fixed32 | valueKind: int32 | goName: MapFixed32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_fixed32_int32")
	if this.MapFixed32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapFixed32Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(uint64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_fixed64_int32 | keyKind: fixed64 | valueKind: int32 | goName: MapFixed64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_fixed64_int32")
	if this.MapFixed64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapFixed64Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_sfixed32_int32 | keyKind: sfixed32 | valueKind: int32 | goName: MapSfixed32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sfixed32_int32")
	if this.MapSfixed32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSfixed32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_sfixed64_int32 | keyKind: sfixed64 | valueKind: int32 | goName: MapSfixed64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sfixed64_int32")
	if this.MapSfixed64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSfixed64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_string_int32 | keyKind: string | valueKind: int32 | goName: MapStringInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_int32")
	if this.MapStringInt32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringInt32 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_string_int32_null | keyKind: string | valueKind: int32 | goName: MapStringInt32Null | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_int32_null")
	if this.MapStringInt32Null != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringInt32Null {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_string_string | keyKind: string | valueKind: string | goName: MapStringString | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_string")
	if this.MapStringString != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringString {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_string_embed_message | keyKind: string | valueKind: message | goName: MapStringEmbedMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_embed_message")
	if this.MapStringEmbedMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringEmbedMessage {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_string_stand_message | keyKind: string | valueKind: message | goName: MapStringStandMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_stand_message")
	if this.MapStringStandMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringStandMessage {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_string_external_message | keyKind: string | valueKind: message | goName: MapStringExternalMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_external_message")
	if this.MapStringExternalMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringExternalMessage {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_string_embed_enum | keyKind: string | valueKind: enum | goName: MapStringEmbedEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_embed_enum")
	if this.MapStringEmbedEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringEmbedEnum {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_string_stand_enum | keyKind: string | valueKind: enum | goName: MapStringStandEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_stand_enum")
	if this.MapStringStandEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringStandEnum {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model1.map_string_external_enum | keyKind: string | valueKind: enum | goName: MapStringExternalEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_external_enum")
	if this.MapStringExternalEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringExternalEnum {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *Model1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*Model1) is nil")
	}
	var oneofOneofType1isStore bool
	var oneofOneofType2isStore bool
	var oneofOneofType3isStore bool
	var oneofOneof_Type4isStore bool
	var oneofOneof_Type5isStore bool
	var oneofOneofType6isStore bool
	var oneofOneofType7isStore bool
	var oneofOneof_Type8isStore bool
	var oneofOneof_Type9isStore bool
	var oneofOneof_Type10isStore bool
	var oneofOneof_Type11isStore bool
	var oneofOneof_Type12isStore bool
	var oneofOneof_Type13isStore bool
	var oneofOneof_Type14isStore bool
	var oneofOneof_Type15isStore bool
	var oneofOneof_Type16isStore bool
	var oneofOneof_Type17isStore bool
	var oneofOneof_Type18isStore bool
	var oneofOneof_Type19isStore bool
	var oneofOneof_Type20isStore bool
	var oneofOneof_Type21isStore bool
	var oneofOneof_Type22NullisStore bool
	var oneofOneof_Type23NullisStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "oneof_type1":
			// decode filed type of oneof; | field: gojsontest.Model1.OneofType1 | GoName: OneofType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_oneof_type1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_oneof_type1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof1_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Double)
						ot.Oneof1Double = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Float)
						ot.Oneof1Float = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Int32)
						ot.Oneof1Int32 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Int64)
						ot.Oneof1Int64 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Uint32)
						ot.Oneof1Uint32 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Uint64)
						ot.Oneof1Uint64 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Sint32)
						ot.Oneof1Sint32 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Sint64)
						ot.Oneof1Sint64 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Fixed32)
						ot.Oneof1Fixed32 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Fixed64)
						ot.Oneof1Fixed64 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Sfixed32)
						ot.Oneof1Sfixed32 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Sfixed64)
						ot.Oneof1Sfixed64 = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Bool)
						ot.Oneof1Bool = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1String)
						ot.Oneof1String = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1Bytes)
						ot.Oneof1Bytes = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1EmbedMessage)
						ot.Oneof1EmbedMessage = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1StandMessage)
						ot.Oneof1StandMessage = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1ExternalMessage)
						ot.Oneof1ExternalMessage = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1EmbedEnum)
						ot.Oneof1EmbedEnum = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1StandEnum)
						ot.Oneof1StandEnum = x
						this.OneofType1 = ot
					case oneofKey == "oneof1_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneofType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType1isStore = true
						ot := new(Model1_Oneof1ExternalEnum)
						ot.Oneof1ExternalEnum = x
						this.OneofType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_oneof_type1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "oneofType2":
			// decode filed type of oneof; | field: gojsontest.Model1.oneofType2 | GoName: OneofType2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_oneofType2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_oneofType2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof2_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Double)
						ot.Oneof2Double = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Float)
						ot.Oneof2Float = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Int32)
						ot.Oneof2Int32 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Int64)
						ot.Oneof2Int64 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Uint32)
						ot.Oneof2Uint32 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Uint64)
						ot.Oneof2Uint64 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Sint32)
						ot.Oneof2Sint32 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Sint64)
						ot.Oneof2Sint64 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Fixed32)
						ot.Oneof2Fixed32 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Fixed64)
						ot.Oneof2Fixed64 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Sfixed32)
						ot.Oneof2Sfixed32 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Sfixed64)
						ot.Oneof2Sfixed64 = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Bool)
						ot.Oneof2Bool = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2String)
						ot.Oneof2String = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2Bytes)
						ot.Oneof2Bytes = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2EmbedMessage)
						ot.Oneof2EmbedMessage = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2StandMessage)
						ot.Oneof2StandMessage = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2ExternalMessage)
						ot.Oneof2ExternalMessage = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2EmbedEnum)
						ot.Oneof2EmbedEnum = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2StandEnum)
						ot.Oneof2StandEnum = x
						this.OneofType2 = ot
					case oneofKey == "oneof2_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneofType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType2isStore = true
						ot := new(Model1_Oneof2ExternalEnum)
						ot.Oneof2ExternalEnum = x
						this.OneofType2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_oneofType2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "OneofType3":
			// decode filed type of oneof; | field: gojsontest.Model1.OneofType3 | GoName: OneofType3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_OneofType3:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_OneofType3
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof3_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Double)
						ot.Oneof3Double = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Float)
						ot.Oneof3Float = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Int32)
						ot.Oneof3Int32 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Int64)
						ot.Oneof3Int64 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Uint32)
						ot.Oneof3Uint32 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Uint64)
						ot.Oneof3Uint64 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Sint32)
						ot.Oneof3Sint32 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Sint64)
						ot.Oneof3Sint64 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Fixed32)
						ot.Oneof3Fixed32 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Fixed64)
						ot.Oneof3Fixed64 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Sfixed32)
						ot.Oneof3Sfixed32 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Sfixed64)
						ot.Oneof3Sfixed64 = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Bool)
						ot.Oneof3Bool = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3String)
						ot.Oneof3String = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3Bytes)
						ot.Oneof3Bytes = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3EmbedMessage)
						ot.Oneof3EmbedMessage = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3StandMessage)
						ot.Oneof3StandMessage = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3ExternalMessage)
						ot.Oneof3ExternalMessage = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3EmbedEnum)
						ot.Oneof3EmbedEnum = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3StandEnum)
						ot.Oneof3StandEnum = x
						this.OneofType3 = ot
					case oneofKey == "oneof3_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneofType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType3isStore = true
						ot := new(Model1_Oneof3ExternalEnum)
						ot.Oneof3ExternalEnum = x
						this.OneofType3 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_OneofType3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type4":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type4 | GoName: Oneof_Type4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type4:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type4
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof4_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Double)
						ot.Oneof4Double = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Float)
						ot.Oneof4Float = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Int32)
						ot.Oneof4Int32 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Int64)
						ot.Oneof4Int64 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Uint32)
						ot.Oneof4Uint32 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Uint64)
						ot.Oneof4Uint64 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Sint32)
						ot.Oneof4Sint32 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Sint64)
						ot.Oneof4Sint64 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Fixed32)
						ot.Oneof4Fixed32 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Fixed64)
						ot.Oneof4Fixed64 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Sfixed32)
						ot.Oneof4Sfixed32 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Sfixed64)
						ot.Oneof4Sfixed64 = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Bool)
						ot.Oneof4Bool = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4String)
						ot.Oneof4String = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4Bytes)
						ot.Oneof4Bytes = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4EmbedMessage)
						ot.Oneof4EmbedMessage = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4StandMessage)
						ot.Oneof4StandMessage = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4ExternalMessage)
						ot.Oneof4ExternalMessage = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4EmbedEnum)
						ot.Oneof4EmbedEnum = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4StandEnum)
						ot.Oneof4StandEnum = x
						this.Oneof_Type4 = ot
					case oneofKey == "oneof4_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type4isStore = true
						ot := new(Model1_Oneof4ExternalEnum)
						ot.Oneof4ExternalEnum = x
						this.Oneof_Type4 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type4
					}
				}
				decoder.ScanNext()
			}
		case objKey == "oneof_Type5":
			// decode filed type of oneof; | field: gojsontest.Model1.oneof_Type5 | GoName: Oneof_Type5
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_oneof_Type5:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_oneof_Type5
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof5_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Double)
						ot.Oneof5Double = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Float)
						ot.Oneof5Float = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Int32)
						ot.Oneof5Int32 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Int64)
						ot.Oneof5Int64 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Uint32)
						ot.Oneof5Uint32 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Uint64)
						ot.Oneof5Uint64 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Sint32)
						ot.Oneof5Sint32 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Sint64)
						ot.Oneof5Sint64 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Fixed32)
						ot.Oneof5Fixed32 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Fixed64)
						ot.Oneof5Fixed64 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Sfixed32)
						ot.Oneof5Sfixed32 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Sfixed64)
						ot.Oneof5Sfixed64 = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Bool)
						ot.Oneof5Bool = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5String)
						ot.Oneof5String = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5Bytes)
						ot.Oneof5Bytes = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5EmbedMessage)
						ot.Oneof5EmbedMessage = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5StandMessage)
						ot.Oneof5StandMessage = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5ExternalMessage)
						ot.Oneof5ExternalMessage = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5EmbedEnum)
						ot.Oneof5EmbedEnum = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5StandEnum)
						ot.Oneof5StandEnum = x
						this.Oneof_Type5 = ot
					case oneofKey == "oneof5_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type5isStore = true
						ot := new(Model1_Oneof5ExternalEnum)
						ot.Oneof5ExternalEnum = x
						this.Oneof_Type5 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_oneof_Type5
					}
				}
				decoder.ScanNext()
			}
		case objKey == "oneof_type6":
			// decode filed type of oneof; | field: gojsontest.Model1.oneof_type6 | GoName: OneofType6
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_oneof_type6:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_oneof_type6
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof6_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Double)
						ot.Oneof6Double = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Float)
						ot.Oneof6Float = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Int32)
						ot.Oneof6Int32 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Int64)
						ot.Oneof6Int64 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Uint32)
						ot.Oneof6Uint32 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Uint64)
						ot.Oneof6Uint64 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Sint32)
						ot.Oneof6Sint32 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Sint64)
						ot.Oneof6Sint64 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Fixed32)
						ot.Oneof6Fixed32 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Fixed64)
						ot.Oneof6Fixed64 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Sfixed32)
						ot.Oneof6Sfixed32 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Sfixed64)
						ot.Oneof6Sfixed64 = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Bool)
						ot.Oneof6Bool = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6String)
						ot.Oneof6String = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6Bytes)
						ot.Oneof6Bytes = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6EmbedMessage)
						ot.Oneof6EmbedMessage = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6StandMessage)
						ot.Oneof6StandMessage = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6ExternalMessage)
						ot.Oneof6ExternalMessage = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6EmbedEnum)
						ot.Oneof6EmbedEnum = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6StandEnum)
						ot.Oneof6StandEnum = x
						this.OneofType6 = ot
					case oneofKey == "oneof6_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneofType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType6isStore = true
						ot := new(Model1_Oneof6ExternalEnum)
						ot.Oneof6ExternalEnum = x
						this.OneofType6 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_oneof_type6
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_type7":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_type7 | GoName: OneofType7
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_type7:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_type7
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof7_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Double)
						ot.Oneof7Double = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Float)
						ot.Oneof7Float = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Int32)
						ot.Oneof7Int32 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Int64)
						ot.Oneof7Int64 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Uint32)
						ot.Oneof7Uint32 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Uint64)
						ot.Oneof7Uint64 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Sint32)
						ot.Oneof7Sint32 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Sint64)
						ot.Oneof7Sint64 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Fixed32)
						ot.Oneof7Fixed32 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Fixed64)
						ot.Oneof7Fixed64 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Sfixed32)
						ot.Oneof7Sfixed32 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Sfixed64)
						ot.Oneof7Sfixed64 = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Bool)
						ot.Oneof7Bool = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7String)
						ot.Oneof7String = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7Bytes)
						ot.Oneof7Bytes = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7EmbedMessage)
						ot.Oneof7EmbedMessage = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7StandMessage)
						ot.Oneof7StandMessage = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7ExternalMessage)
						ot.Oneof7ExternalMessage = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7EmbedEnum)
						ot.Oneof7EmbedEnum = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7StandEnum)
						ot.Oneof7StandEnum = x
						this.OneofType7 = ot
					case oneofKey == "oneof7_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneofType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneofType7isStore = true
						ot := new(Model1_Oneof7ExternalEnum)
						ot.Oneof7ExternalEnum = x
						this.OneofType7 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_type7
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type8":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type8 | GoName: Oneof_Type8
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type8:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type8
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof8_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Double)
						ot.Oneof8Double = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Float)
						ot.Oneof8Float = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Int32)
						ot.Oneof8Int32 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Int64)
						ot.Oneof8Int64 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Uint32)
						ot.Oneof8Uint32 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Uint64)
						ot.Oneof8Uint64 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Sint32)
						ot.Oneof8Sint32 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Sint64)
						ot.Oneof8Sint64 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Fixed32)
						ot.Oneof8Fixed32 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Fixed64)
						ot.Oneof8Fixed64 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Sfixed32)
						ot.Oneof8Sfixed32 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Sfixed64)
						ot.Oneof8Sfixed64 = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Bool)
						ot.Oneof8Bool = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8String)
						ot.Oneof8String = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8Bytes)
						ot.Oneof8Bytes = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8EmbedMessage)
						ot.Oneof8EmbedMessage = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8StandMessage)
						ot.Oneof8StandMessage = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8ExternalMessage)
						ot.Oneof8ExternalMessage = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8EmbedEnum)
						ot.Oneof8EmbedEnum = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8StandEnum)
						ot.Oneof8StandEnum = x
						this.Oneof_Type8 = ot
					case oneofKey == "oneof8_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type8isStore = true
						ot := new(Model1_Oneof8ExternalEnum)
						ot.Oneof8ExternalEnum = x
						this.Oneof_Type8 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type8
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type9":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type9 | GoName: Oneof_Type9
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type9:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type9
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof9_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Double)
						ot.Oneof9Double = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Float)
						ot.Oneof9Float = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Int32)
						ot.Oneof9Int32 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Int64)
						ot.Oneof9Int64 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Uint32)
						ot.Oneof9Uint32 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Uint64)
						ot.Oneof9Uint64 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Sint32)
						ot.Oneof9Sint32 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Sint64)
						ot.Oneof9Sint64 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Fixed32)
						ot.Oneof9Fixed32 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Fixed64)
						ot.Oneof9Fixed64 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Sfixed32)
						ot.Oneof9Sfixed32 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Sfixed64)
						ot.Oneof9Sfixed64 = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Bool)
						ot.Oneof9Bool = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9String)
						ot.Oneof9String = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9Bytes)
						ot.Oneof9Bytes = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9EmbedMessage)
						ot.Oneof9EmbedMessage = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9StandMessage)
						ot.Oneof9StandMessage = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9ExternalMessage)
						ot.Oneof9ExternalMessage = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9EmbedEnum)
						ot.Oneof9EmbedEnum = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9StandEnum)
						ot.Oneof9StandEnum = x
						this.Oneof_Type9 = ot
					case oneofKey == "oneof9_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type9isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type9isStore = true
						ot := new(Model1_Oneof9ExternalEnum)
						ot.Oneof9ExternalEnum = x
						this.Oneof_Type9 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type9
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type10":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type10 | GoName: Oneof_Type10
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type10:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type10
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof10_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Double)
						ot.Oneof10Double = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Float)
						ot.Oneof10Float = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Int32)
						ot.Oneof10Int32 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Int64)
						ot.Oneof10Int64 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Uint32)
						ot.Oneof10Uint32 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Uint64)
						ot.Oneof10Uint64 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Sint32)
						ot.Oneof10Sint32 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Sint64)
						ot.Oneof10Sint64 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Fixed32)
						ot.Oneof10Fixed32 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Fixed64)
						ot.Oneof10Fixed64 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Sfixed32)
						ot.Oneof10Sfixed32 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Sfixed64)
						ot.Oneof10Sfixed64 = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Bool)
						ot.Oneof10Bool = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10String)
						ot.Oneof10String = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10Bytes)
						ot.Oneof10Bytes = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10EmbedMessage)
						ot.Oneof10EmbedMessage = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10StandMessage)
						ot.Oneof10StandMessage = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10ExternalMessage)
						ot.Oneof10ExternalMessage = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10EmbedEnum)
						ot.Oneof10EmbedEnum = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10StandEnum)
						ot.Oneof10StandEnum = x
						this.Oneof_Type10 = ot
					case oneofKey == "oneof10_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type10isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type10isStore = true
						ot := new(Model1_Oneof10ExternalEnum)
						ot.Oneof10ExternalEnum = x
						this.Oneof_Type10 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type10
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type11":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type11 | GoName: Oneof_Type11
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type11:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type11
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof11_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Double)
						ot.Oneof11Double = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Float)
						ot.Oneof11Float = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Int32)
						ot.Oneof11Int32 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Int64)
						ot.Oneof11Int64 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Uint32)
						ot.Oneof11Uint32 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Uint64)
						ot.Oneof11Uint64 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Sint32)
						ot.Oneof11Sint32 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Sint64)
						ot.Oneof11Sint64 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Fixed32)
						ot.Oneof11Fixed32 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Fixed64)
						ot.Oneof11Fixed64 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Sfixed32)
						ot.Oneof11Sfixed32 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Sfixed64)
						ot.Oneof11Sfixed64 = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Bool)
						ot.Oneof11Bool = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11String)
						ot.Oneof11String = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11Bytes)
						ot.Oneof11Bytes = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11EmbedMessage)
						ot.Oneof11EmbedMessage = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11StandMessage)
						ot.Oneof11StandMessage = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11ExternalMessage)
						ot.Oneof11ExternalMessage = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11EmbedEnum)
						ot.Oneof11EmbedEnum = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11StandEnum)
						ot.Oneof11StandEnum = x
						this.Oneof_Type11 = ot
					case oneofKey == "oneof11_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type11isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type11isStore = true
						ot := new(Model1_Oneof11ExternalEnum)
						ot.Oneof11ExternalEnum = x
						this.Oneof_Type11 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type11
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type12":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type12 | GoName: Oneof_Type12
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type12:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type12
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof12_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Double)
						ot.Oneof12Double = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Float)
						ot.Oneof12Float = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Int32)
						ot.Oneof12Int32 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Int64)
						ot.Oneof12Int64 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Uint32)
						ot.Oneof12Uint32 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Uint64)
						ot.Oneof12Uint64 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Sint32)
						ot.Oneof12Sint32 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Sint64)
						ot.Oneof12Sint64 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Fixed32)
						ot.Oneof12Fixed32 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Fixed64)
						ot.Oneof12Fixed64 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Sfixed32)
						ot.Oneof12Sfixed32 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Sfixed64)
						ot.Oneof12Sfixed64 = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Bool)
						ot.Oneof12Bool = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12String)
						ot.Oneof12String = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12Bytes)
						ot.Oneof12Bytes = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12EmbedMessage)
						ot.Oneof12EmbedMessage = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12StandMessage)
						ot.Oneof12StandMessage = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12ExternalMessage)
						ot.Oneof12ExternalMessage = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12EmbedEnum)
						ot.Oneof12EmbedEnum = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12StandEnum)
						ot.Oneof12StandEnum = x
						this.Oneof_Type12 = ot
					case oneofKey == "oneof12_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type12isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type12isStore = true
						ot := new(Model1_Oneof12ExternalEnum)
						ot.Oneof12ExternalEnum = x
						this.Oneof_Type12 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type12
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type13":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type13 | GoName: Oneof_Type13
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type13:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type13
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof13_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Double)
						ot.Oneof13Double = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Float)
						ot.Oneof13Float = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Int32)
						ot.Oneof13Int32 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Int64)
						ot.Oneof13Int64 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Uint32)
						ot.Oneof13Uint32 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Uint64)
						ot.Oneof13Uint64 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Sint32)
						ot.Oneof13Sint32 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Sint64)
						ot.Oneof13Sint64 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Fixed32)
						ot.Oneof13Fixed32 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Fixed64)
						ot.Oneof13Fixed64 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Sfixed32)
						ot.Oneof13Sfixed32 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Sfixed64)
						ot.Oneof13Sfixed64 = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Bool)
						ot.Oneof13Bool = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13String)
						ot.Oneof13String = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13Bytes)
						ot.Oneof13Bytes = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13EmbedMessage)
						ot.Oneof13EmbedMessage = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13StandMessage)
						ot.Oneof13StandMessage = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13ExternalMessage)
						ot.Oneof13ExternalMessage = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13EmbedEnum)
						ot.Oneof13EmbedEnum = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13StandEnum)
						ot.Oneof13StandEnum = x
						this.Oneof_Type13 = ot
					case oneofKey == "oneof13_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type13isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type13isStore = true
						ot := new(Model1_Oneof13ExternalEnum)
						ot.Oneof13ExternalEnum = x
						this.Oneof_Type13 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type13
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type14":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type14 | GoName: Oneof_Type14
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type14:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type14
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof14_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Double)
						ot.Oneof14Double = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Float)
						ot.Oneof14Float = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Int32)
						ot.Oneof14Int32 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Int64)
						ot.Oneof14Int64 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Uint32)
						ot.Oneof14Uint32 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Uint64)
						ot.Oneof14Uint64 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Sint32)
						ot.Oneof14Sint32 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Sint64)
						ot.Oneof14Sint64 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Fixed32)
						ot.Oneof14Fixed32 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Fixed64)
						ot.Oneof14Fixed64 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Sfixed32)
						ot.Oneof14Sfixed32 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Sfixed64)
						ot.Oneof14Sfixed64 = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Bool)
						ot.Oneof14Bool = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14String)
						ot.Oneof14String = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14Bytes)
						ot.Oneof14Bytes = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14EmbedMessage)
						ot.Oneof14EmbedMessage = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14StandMessage)
						ot.Oneof14StandMessage = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14ExternalMessage)
						ot.Oneof14ExternalMessage = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14EmbedEnum)
						ot.Oneof14EmbedEnum = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14StandEnum)
						ot.Oneof14StandEnum = x
						this.Oneof_Type14 = ot
					case oneofKey == "oneof14_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type14isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type14isStore = true
						ot := new(Model1_Oneof14ExternalEnum)
						ot.Oneof14ExternalEnum = x
						this.Oneof_Type14 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type14
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type15":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type15 | GoName: Oneof_Type15
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type15:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type15
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof15_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Double)
						ot.Oneof15Double = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Float)
						ot.Oneof15Float = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Int32)
						ot.Oneof15Int32 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Int64)
						ot.Oneof15Int64 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Uint32)
						ot.Oneof15Uint32 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Uint64)
						ot.Oneof15Uint64 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Sint32)
						ot.Oneof15Sint32 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Sint64)
						ot.Oneof15Sint64 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Fixed32)
						ot.Oneof15Fixed32 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Fixed64)
						ot.Oneof15Fixed64 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Sfixed32)
						ot.Oneof15Sfixed32 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Sfixed64)
						ot.Oneof15Sfixed64 = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Bool)
						ot.Oneof15Bool = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15String)
						ot.Oneof15String = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15Bytes)
						ot.Oneof15Bytes = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15EmbedMessage)
						ot.Oneof15EmbedMessage = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15StandMessage)
						ot.Oneof15StandMessage = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15ExternalMessage)
						ot.Oneof15ExternalMessage = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15EmbedEnum)
						ot.Oneof15EmbedEnum = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15StandEnum)
						ot.Oneof15StandEnum = x
						this.Oneof_Type15 = ot
					case oneofKey == "oneof15_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type15isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type15isStore = true
						ot := new(Model1_Oneof15ExternalEnum)
						ot.Oneof15ExternalEnum = x
						this.Oneof_Type15 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type15
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type16":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type16 | GoName: Oneof_Type16
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type16:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type16
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof16_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Double)
						ot.Oneof16Double = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Float)
						ot.Oneof16Float = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Int32)
						ot.Oneof16Int32 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Int64)
						ot.Oneof16Int64 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Uint32)
						ot.Oneof16Uint32 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Uint64)
						ot.Oneof16Uint64 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Sint32)
						ot.Oneof16Sint32 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Sint64)
						ot.Oneof16Sint64 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Fixed32)
						ot.Oneof16Fixed32 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Fixed64)
						ot.Oneof16Fixed64 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Sfixed32)
						ot.Oneof16Sfixed32 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Sfixed64)
						ot.Oneof16Sfixed64 = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Bool)
						ot.Oneof16Bool = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16String)
						ot.Oneof16String = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16Bytes)
						ot.Oneof16Bytes = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16EmbedMessage)
						ot.Oneof16EmbedMessage = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16StandMessage)
						ot.Oneof16StandMessage = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16ExternalMessage)
						ot.Oneof16ExternalMessage = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16EmbedEnum)
						ot.Oneof16EmbedEnum = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16StandEnum)
						ot.Oneof16StandEnum = x
						this.Oneof_Type16 = ot
					case oneofKey == "oneof16_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type16isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type16isStore = true
						ot := new(Model1_Oneof16ExternalEnum)
						ot.Oneof16ExternalEnum = x
						this.Oneof_Type16 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type16
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type17":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type17 | GoName: Oneof_Type17
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type17:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type17
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof17_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Double)
						ot.Oneof17Double = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Float)
						ot.Oneof17Float = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Int32)
						ot.Oneof17Int32 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Int64)
						ot.Oneof17Int64 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Uint32)
						ot.Oneof17Uint32 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Uint64)
						ot.Oneof17Uint64 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Sint32)
						ot.Oneof17Sint32 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Sint64)
						ot.Oneof17Sint64 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Fixed32)
						ot.Oneof17Fixed32 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Fixed64)
						ot.Oneof17Fixed64 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Sfixed32)
						ot.Oneof17Sfixed32 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Sfixed64)
						ot.Oneof17Sfixed64 = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Bool)
						ot.Oneof17Bool = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17String)
						ot.Oneof17String = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17Bytes)
						ot.Oneof17Bytes = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17EmbedMessage)
						ot.Oneof17EmbedMessage = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17StandMessage)
						ot.Oneof17StandMessage = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17ExternalMessage)
						ot.Oneof17ExternalMessage = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17EmbedEnum)
						ot.Oneof17EmbedEnum = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17StandEnum)
						ot.Oneof17StandEnum = x
						this.Oneof_Type17 = ot
					case oneofKey == "oneof17_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type17isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type17isStore = true
						ot := new(Model1_Oneof17ExternalEnum)
						ot.Oneof17ExternalEnum = x
						this.Oneof_Type17 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type17
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type18":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type18 | GoName: Oneof_Type18
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type18:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type18
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof18_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Double)
						ot.Oneof18Double = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Float)
						ot.Oneof18Float = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Int32)
						ot.Oneof18Int32 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Int64)
						ot.Oneof18Int64 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Uint32)
						ot.Oneof18Uint32 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Uint64)
						ot.Oneof18Uint64 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Sint32)
						ot.Oneof18Sint32 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Sint64)
						ot.Oneof18Sint64 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Fixed32)
						ot.Oneof18Fixed32 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Fixed64)
						ot.Oneof18Fixed64 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Sfixed32)
						ot.Oneof18Sfixed32 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Sfixed64)
						ot.Oneof18Sfixed64 = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Bool)
						ot.Oneof18Bool = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18String)
						ot.Oneof18String = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18Bytes)
						ot.Oneof18Bytes = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18EmbedMessage)
						ot.Oneof18EmbedMessage = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18StandMessage)
						ot.Oneof18StandMessage = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18ExternalMessage)
						ot.Oneof18ExternalMessage = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18EmbedEnum)
						ot.Oneof18EmbedEnum = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18StandEnum)
						ot.Oneof18StandEnum = x
						this.Oneof_Type18 = ot
					case oneofKey == "oneof18_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type18isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type18isStore = true
						ot := new(Model1_Oneof18ExternalEnum)
						ot.Oneof18ExternalEnum = x
						this.Oneof_Type18 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type18
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type19":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type19 | GoName: Oneof_Type19
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type19:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type19
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof19_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Double)
						ot.Oneof19Double = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Float)
						ot.Oneof19Float = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Int32)
						ot.Oneof19Int32 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Int64)
						ot.Oneof19Int64 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Uint32)
						ot.Oneof19Uint32 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Uint64)
						ot.Oneof19Uint64 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Sint32)
						ot.Oneof19Sint32 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Sint64)
						ot.Oneof19Sint64 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Fixed32)
						ot.Oneof19Fixed32 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Fixed64)
						ot.Oneof19Fixed64 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Sfixed32)
						ot.Oneof19Sfixed32 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Sfixed64)
						ot.Oneof19Sfixed64 = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Bool)
						ot.Oneof19Bool = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19String)
						ot.Oneof19String = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19Bytes)
						ot.Oneof19Bytes = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19EmbedMessage)
						ot.Oneof19EmbedMessage = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19StandMessage)
						ot.Oneof19StandMessage = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19ExternalMessage)
						ot.Oneof19ExternalMessage = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19EmbedEnum)
						ot.Oneof19EmbedEnum = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19StandEnum)
						ot.Oneof19StandEnum = x
						this.Oneof_Type19 = ot
					case oneofKey == "oneof19_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type19isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type19isStore = true
						ot := new(Model1_Oneof19ExternalEnum)
						ot.Oneof19ExternalEnum = x
						this.Oneof_Type19 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type19
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type20":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type20 | GoName: Oneof_Type20
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type20:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type20
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof20_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Double)
						ot.Oneof20Double = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Float)
						ot.Oneof20Float = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Int32)
						ot.Oneof20Int32 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Int64)
						ot.Oneof20Int64 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Uint32)
						ot.Oneof20Uint32 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Uint64)
						ot.Oneof20Uint64 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Sint32)
						ot.Oneof20Sint32 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Sint64)
						ot.Oneof20Sint64 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Fixed32)
						ot.Oneof20Fixed32 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Fixed64)
						ot.Oneof20Fixed64 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Sfixed32)
						ot.Oneof20Sfixed32 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Sfixed64)
						ot.Oneof20Sfixed64 = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Bool)
						ot.Oneof20Bool = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20String)
						ot.Oneof20String = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20Bytes)
						ot.Oneof20Bytes = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20EmbedMessage)
						ot.Oneof20EmbedMessage = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20StandMessage)
						ot.Oneof20StandMessage = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20ExternalMessage)
						ot.Oneof20ExternalMessage = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20EmbedEnum)
						ot.Oneof20EmbedEnum = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20StandEnum)
						ot.Oneof20StandEnum = x
						this.Oneof_Type20 = ot
					case oneofKey == "oneof20_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type20isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type20isStore = true
						ot := new(Model1_Oneof20ExternalEnum)
						ot.Oneof20ExternalEnum = x
						this.Oneof_Type20 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type20
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type21":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type21 | GoName: Oneof_Type21
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type21:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type21
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof21_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Double)
						ot.Oneof21Double = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Float)
						ot.Oneof21Float = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Int32)
						ot.Oneof21Int32 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Int64)
						ot.Oneof21Int64 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Uint32)
						ot.Oneof21Uint32 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Uint64)
						ot.Oneof21Uint64 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Sint32)
						ot.Oneof21Sint32 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Sint64)
						ot.Oneof21Sint64 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Fixed32)
						ot.Oneof21Fixed32 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Fixed64)
						ot.Oneof21Fixed64 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Sfixed32)
						ot.Oneof21Sfixed32 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Sfixed64)
						ot.Oneof21Sfixed64 = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Bool)
						ot.Oneof21Bool = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21String)
						ot.Oneof21String = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21Bytes)
						ot.Oneof21Bytes = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21EmbedMessage)
						ot.Oneof21EmbedMessage = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21StandMessage)
						ot.Oneof21StandMessage = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21ExternalMessage)
						ot.Oneof21ExternalMessage = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21EmbedEnum)
						ot.Oneof21EmbedEnum = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21StandEnum)
						ot.Oneof21StandEnum = x
						this.Oneof_Type21 = ot
					case oneofKey == "oneof21_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type21isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type21isStore = true
						ot := new(Model1_Oneof21ExternalEnum)
						ot.Oneof21ExternalEnum = x
						this.Oneof_Type21 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type21
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type22_null":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type22_null | GoName: Oneof_Type22Null
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type22_null:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type22_null
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof22_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Double)
						ot.Oneof22Double = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Float)
						ot.Oneof22Float = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Int32)
						ot.Oneof22Int32 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Int64)
						ot.Oneof22Int64 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Uint32)
						ot.Oneof22Uint32 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Uint64)
						ot.Oneof22Uint64 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Sint32)
						ot.Oneof22Sint32 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Sint64)
						ot.Oneof22Sint64 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Fixed32)
						ot.Oneof22Fixed32 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Fixed64)
						ot.Oneof22Fixed64 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Sfixed32)
						ot.Oneof22Sfixed32 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Sfixed64)
						ot.Oneof22Sfixed64 = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Bool)
						ot.Oneof22Bool = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22String)
						ot.Oneof22String = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22Bytes)
						ot.Oneof22Bytes = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22EmbedMessage)
						ot.Oneof22EmbedMessage = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22StandMessage)
						ot.Oneof22StandMessage = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22ExternalMessage)
						ot.Oneof22ExternalMessage = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22EmbedEnum)
						ot.Oneof22EmbedEnum = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22StandEnum)
						ot.Oneof22StandEnum = x
						this.Oneof_Type22Null = ot
					case oneofKey == "oneof22_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type22NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type22NullisStore = true
						ot := new(Model1_Oneof22ExternalEnum)
						ot.Oneof22ExternalEnum = x
						this.Oneof_Type22Null = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type22_null
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Oneof_Type23_null":
			// decode filed type of oneof; | field: gojsontest.Model1.Oneof_Type23_null | GoName: Oneof_Type23Null
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float64", string(value), objKey)
				}
			LOOP_ONEOF_Oneof_Type23_null:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Oneof_Type23_null
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "oneof23_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Double)
						ot.Oneof23Double = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Float)
						ot.Oneof23Float = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Int32)
						ot.Oneof23Int32 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Int64)
						ot.Oneof23Int64 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Uint32)
						ot.Oneof23Uint32 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Uint64)
						ot.Oneof23Uint64 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Sint32)
						ot.Oneof23Sint32 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Sint64)
						ot.Oneof23Sint64 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Fixed32)
						ot.Oneof23Fixed32 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Fixed64)
						ot.Oneof23Fixed64 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Sfixed32)
						ot.Oneof23Sfixed32 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Sfixed64)
						ot.Oneof23Sfixed64 = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Bool)
						ot.Oneof23Bool = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23String)
						ot.Oneof23String = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23Bytes)
						ot.Oneof23Bytes = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_embed_message":
						value := decoder.ReadItem()
						var x *Model1_EmbedMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(Model1_EmbedMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23EmbedMessage)
						ot.Oneof23EmbedMessage = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_stand_message":
						value := decoder.ReadItem()
						var x *StandMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(StandMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23StandMessage)
						ot.Oneof23StandMessage = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_external_message":
						value := decoder.ReadItem()
						var x *gojsonexternal.ExternalMessage1
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(gojsonexternal.ExternalMessage1)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23ExternalMessage)
						ot.Oneof23ExternalMessage = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_embed_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
						}
						_, ok := Model1_EmbedEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := Model1_EmbedEnum1(x1)
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23EmbedEnum)
						ot.Oneof23EmbedEnum = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_stand_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
						}
						_, ok := StandEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := StandEnum1(x1)
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23StandEnum)
						ot.Oneof23StandEnum = x
						this.Oneof_Type23Null = ot
					case oneofKey == "oneof23_external_enum":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
						}
						_, ok := gojsonexternal.ExternalEnum1_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := gojsonexternal.ExternalEnum1(x1)
						if oneofOneof_Type23NullisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof_Type23NullisStore = true
						ot := new(Model1_Oneof23ExternalEnum)
						ot.Oneof23ExternalEnum = x
						this.Oneof_Type23Null = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Oneof_Type23_null
					}
				}
				decoder.ScanNext()
			}
		case objKey == "type_double1":
			// decode filed type of basic; | field: gojsontest.Model1.type_double1 | kind: DoubleKind | GoName: TypeDouble1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TypeDouble1 = x
		case objKey == "type_double2":
			// decode filed type of basic; | field: gojsontest.Model1.TypeDouble2 | kind: DoubleKind | GoName: TypeDouble2
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TypeDouble2 = x
		case objKey == "typeDouble3":
			// decode filed type of basic; | field: gojsontest.Model1.typeDouble3 | kind: DoubleKind | GoName: TypeDouble3
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TypeDouble3 = x
		case objKey == "Type_double4":
			// decode filed type of basic; | field: gojsontest.Model1.Type_double4 | kind: DoubleKind | GoName: TypeDouble4
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TypeDouble4 = x
		case objKey == "Type_Double5":
			// decode filed type of basic; | field: gojsontest.Model1.Type_Double5 | kind: DoubleKind | GoName: Type_Double5
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.Type_Double5 = x
		case objKey == "type_float":
			// decode filed type of basic; | field: gojsontest.Model1.type_float | kind: FloatKind | GoName: TypeFloat
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
			}
			this.TypeFloat = x
		case objKey == "type_int32":
			// decode filed type of basic; | field: gojsontest.Model1.type_int32 | kind: Int32Kind | GoName: TypeInt32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TypeInt32 = x
		case objKey == "type_int64":
			// decode filed type of basic; | field: gojsontest.Model1.type_int64 | kind: Int64Kind | GoName: TypeInt64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TypeInt64 = x
		case objKey == "type_uint32":
			// decode filed type of basic; | field: gojsontest.Model1.type_uint32 | kind: Uint32Kind | GoName: TypeUint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TypeUint32 = x
		case objKey == "type_uint64":
			// decode filed type of basic; | field: gojsontest.Model1.type_uint64 | kind: Uint64Kind | GoName: TypeUint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TypeUint64 = x
		case objKey == "type_sint32":
			// decode filed type of basic; | field: gojsontest.Model1.type_sint32 | kind: Sint32Kind | GoName: TypeSint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TypeSint32 = x
		case objKey == "type_sint64":
			// decode filed type of basic; | field: gojsontest.Model1.type_sint64 | kind: Sint64Kind | GoName: TypeSint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TypeSint64 = x
		case objKey == "type_fixed32":
			// decode filed type of basic; | field: gojsontest.Model1.type_fixed32 | kind: Fixed32Kind | GoName: TypeFixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TypeFixed32 = x
		case objKey == "type_fixed64":
			// decode filed type of basic; | field: gojsontest.Model1.type_fixed64 | kind: Fixed64Kind | GoName: TypeFixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TypeFixed64 = x
		case objKey == "type_sfixed32":
			// decode filed type of basic; | field: gojsontest.Model1.type_sfixed32 | kind: Sfixed32Kind | GoName: TypeSfixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TypeSfixed32 = x
		case objKey == "type_sfixed64":
			// decode filed type of basic; | field: gojsontest.Model1.type_sfixed64 | kind: Sfixed64Kind | GoName: TypeSfixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TypeSfixed64 = x
		case objKey == "type_bool1":
			// decode filed type of basic; | field: gojsontest.Model1.type_bool1 | kind: BoolKind | GoName: TypeBool1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			this.TypeBool1 = x
		case objKey == "type_bool2":
			// decode filed type of basic; | field: gojsontest.Model1.type_bool2 | kind: BoolKind | GoName: TypeBool2
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			this.TypeBool2 = x
		case objKey == "type_string1":
			// decode filed type of basic; | field: gojsontest.Model1.type_string1 | kind: StringKind | GoName: TypeString1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString1 = x
		case objKey == "type_string2":
			// decode filed type of basic; | field: gojsontest.Model1.type_string2 | kind: StringKind | GoName: TypeString2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString2 = x
		case objKey == "type_string3":
			// decode filed type of basic; | field: gojsontest.Model1.type_string3 | kind: StringKind | GoName: TypeString3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString3 = x
		case objKey == "type_string4":
			// decode filed type of basic; | field: gojsontest.Model1.type_string4 | kind: StringKind | GoName: TypeString4
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString4 = x
		case objKey == "type_string5":
			// decode filed type of basic; | field: gojsontest.Model1.type_string5 | kind: StringKind | GoName: TypeString5
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString5 = x
		case objKey == "type_bytes":
			// decode filed type of basic; | field: gojsontest.Model1.type_bytes | kind: BytesKind | GoName: TypeBytes
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.TypeBytes = x
		case objKey == "type_embed_message":
			// decode filed type of basic; | field: gojsontest.Model1.type_embed_message | kind: MessageKind | GoName: TypeEmbedMessage
			value := decoder.ReadItem()
			var x *Model1_EmbedMessage1
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TypeEmbedMessage == nil {
					x = new(Model1_EmbedMessage1)
				} else {
					x = this.TypeEmbedMessage
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TypeEmbedMessage = x
		case objKey == "type_stand_message":
			// decode filed type of basic; | field: gojsontest.Model1.type_stand_message | kind: MessageKind | GoName: TypeStandMessage
			value := decoder.ReadItem()
			var x *StandMessage1
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TypeStandMessage == nil {
					x = new(StandMessage1)
				} else {
					x = this.TypeStandMessage
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TypeStandMessage = x
		case objKey == "type_embed_enum":
			// decode filed type of basic; | field: gojsontest.Model1.type_embed_enum | kind: EnumKind | GoName: TypeEmbedEnum
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model1_EmbedEnum1", string(value), objKey)
			}
			_, ok := Model1_EmbedEnum1_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := Model1_EmbedEnum1(x1)
			this.TypeEmbedEnum = x
		case objKey == "type_stand_enum":
			// decode filed type of basic; | field: gojsontest.Model1.type_stand_enum | kind: EnumKind | GoName: TypeStandEnum
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
			}
			_, ok := StandEnum1_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := StandEnum1(x1)
			this.TypeStandEnum = x
		case objKey == "type_external_enum":
			// decode filed type of basic; | field: gojsontest.Model1.type_external_enum | kind: EnumKind | GoName: TypeExternalEnum
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
			}
			_, ok := gojsonexternal.ExternalEnum1_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := gojsonexternal.ExternalEnum1(x1)
			this.TypeExternalEnum = x
		case objKey == "type_external_message":
			// decode filed type of basic; | field: gojsontest.Model1.type_external_message | kind: MessageKind | GoName: TypeExternalMessage
			value := decoder.ReadItem()
			var x *gojsonexternal.ExternalMessage1
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TypeExternalMessage == nil {
					x = new(gojsonexternal.ExternalMessage1)
				} else {
					x = this.TypeExternalMessage
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TypeExternalMessage = x
		case objKey == "type_bytes_null":
			// decode filed type of basic; | field: gojsontest.Model1.type_bytes_null | kind: BytesKind | GoName: TypeBytesNull
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.TypeBytesNull = x
		case objKey == "type_embed_message_null":
			// decode filed type of basic; | field: gojsontest.Model1.type_embed_message_null | kind: MessageKind | GoName: TypeEmbedMessageNull
			value := decoder.ReadItem()
			var x *Model1_EmbedMessage1
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TypeEmbedMessageNull == nil {
					x = new(Model1_EmbedMessage1)
				} else {
					x = this.TypeEmbedMessageNull
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TypeEmbedMessageNull = x
		case objKey == "type_stand_message_null":
			// decode filed type of basic; | field: gojsontest.Model1.type_stand_message_null | kind: MessageKind | GoName: TypeStandMessageNull
			value := decoder.ReadItem()
			var x *StandMessage1
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TypeStandMessageNull == nil {
					x = new(StandMessage1)
				} else {
					x = this.TypeStandMessageNull
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TypeStandMessageNull = x
		case objKey == "type_external_message_null":
			// decode filed type of basic; | field: gojsontest.Model1.type_external_message_null | kind: MessageKind | GoName: TypeExternalMessageNull
			value := decoder.ReadItem()
			var x *gojsonexternal.ExternalMessage1
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TypeExternalMessageNull == nil {
					x = new(gojsonexternal.ExternalMessage1)
				} else {
					x = this.TypeExternalMessageNull
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TypeExternalMessageNull = x
		case objKey == "array_double":
			// decode filed type of list; | field: gojsontest.Model1.array_double | kind: DoubleKind | GoName: ArrayDouble
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), objKey)
				} else {
					this.ArrayDouble = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), objKey)
				}
				if this.ArrayDouble == nil {
					this.ArrayDouble = make([]float64, 0)
				}
				i := 0
				length := len(this.ArrayDouble)
			LOOP_LIST_array_double:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_double
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []float64", string(value), objKey)
					}
					if i < length {
						this.ArrayDouble[i] = x
					} else {
						this.ArrayDouble = append(this.ArrayDouble, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_double
					}
				}
				if i < length {
					this.ArrayDouble = this.ArrayDouble[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_float":
			// decode filed type of list; | field: gojsontest.Model1.array_float | kind: FloatKind | GoName: ArrayFloat
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), objKey)
				} else {
					this.ArrayFloat = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), objKey)
				}
				if this.ArrayFloat == nil {
					this.ArrayFloat = make([]float32, 0)
				}
				i := 0
				length := len(this.ArrayFloat)
			LOOP_LIST_array_float:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_float
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []float32", string(value), objKey)
					}
					if i < length {
						this.ArrayFloat[i] = x
					} else {
						this.ArrayFloat = append(this.ArrayFloat, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_float
					}
				}
				if i < length {
					this.ArrayFloat = this.ArrayFloat[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_int32":
			// decode filed type of list; | field: gojsontest.Model1.array_int32 | kind: Int32Kind | GoName: ArrayInt32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArrayInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArrayInt32 == nil {
					this.ArrayInt32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArrayInt32)
			LOOP_LIST_array_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_int32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArrayInt32[i] = x
					} else {
						this.ArrayInt32 = append(this.ArrayInt32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_int32
					}
				}
				if i < length {
					this.ArrayInt32 = this.ArrayInt32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_int64":
			// decode filed type of list; | field: gojsontest.Model1.array_int64 | kind: Int64Kind | GoName: ArrayInt64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArrayInt64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArrayInt64 == nil {
					this.ArrayInt64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArrayInt64)
			LOOP_LIST_array_int64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_int64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArrayInt64[i] = x
					} else {
						this.ArrayInt64 = append(this.ArrayInt64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_int64
					}
				}
				if i < length {
					this.ArrayInt64 = this.ArrayInt64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_uint32":
			// decode filed type of list; | field: gojsontest.Model1.array_uint32 | kind: Uint32Kind | GoName: ArrayUint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				} else {
					this.ArrayUint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				}
				if this.ArrayUint32 == nil {
					this.ArrayUint32 = make([]uint32, 0)
				}
				i := 0
				length := len(this.ArrayUint32)
			LOOP_LIST_array_uint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_uint32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint32", string(value), objKey)
					}
					if i < length {
						this.ArrayUint32[i] = x
					} else {
						this.ArrayUint32 = append(this.ArrayUint32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_uint32
					}
				}
				if i < length {
					this.ArrayUint32 = this.ArrayUint32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_uint64":
			// decode filed type of list; | field: gojsontest.Model1.array_uint64 | kind: Uint64Kind | GoName: ArrayUint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				} else {
					this.ArrayUint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				}
				if this.ArrayUint64 == nil {
					this.ArrayUint64 = make([]uint64, 0)
				}
				i := 0
				length := len(this.ArrayUint64)
			LOOP_LIST_array_uint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_uint64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint64", string(value), objKey)
					}
					if i < length {
						this.ArrayUint64[i] = x
					} else {
						this.ArrayUint64 = append(this.ArrayUint64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_uint64
					}
				}
				if i < length {
					this.ArrayUint64 = this.ArrayUint64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sint32":
			// decode filed type of list; | field: gojsontest.Model1.array_sint32 | kind: Sint32Kind | GoName: ArraySint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArraySint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArraySint32 == nil {
					this.ArraySint32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArraySint32)
			LOOP_LIST_array_sint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sint32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArraySint32[i] = x
					} else {
						this.ArraySint32 = append(this.ArraySint32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sint32
					}
				}
				if i < length {
					this.ArraySint32 = this.ArraySint32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sint64":
			// decode filed type of list; | field: gojsontest.Model1.array_sint64 | kind: Sint64Kind | GoName: ArraySint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArraySint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArraySint64 == nil {
					this.ArraySint64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArraySint64)
			LOOP_LIST_array_sint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sint64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArraySint64[i] = x
					} else {
						this.ArraySint64 = append(this.ArraySint64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sint64
					}
				}
				if i < length {
					this.ArraySint64 = this.ArraySint64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_fixed32":
			// decode filed type of list; | field: gojsontest.Model1.array_fixed32 | kind: Fixed32Kind | GoName: ArrayFixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				} else {
					this.ArrayFixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				}
				if this.ArrayFixed32 == nil {
					this.ArrayFixed32 = make([]uint32, 0)
				}
				i := 0
				length := len(this.ArrayFixed32)
			LOOP_LIST_array_fixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_fixed32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint32", string(value), objKey)
					}
					if i < length {
						this.ArrayFixed32[i] = x
					} else {
						this.ArrayFixed32 = append(this.ArrayFixed32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_fixed32
					}
				}
				if i < length {
					this.ArrayFixed32 = this.ArrayFixed32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_fixed64":
			// decode filed type of list; | field: gojsontest.Model1.array_fixed64 | kind: Fixed64Kind | GoName: ArrayFixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				} else {
					this.ArrayFixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				}
				if this.ArrayFixed64 == nil {
					this.ArrayFixed64 = make([]uint64, 0)
				}
				i := 0
				length := len(this.ArrayFixed64)
			LOOP_LIST_array_fixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_fixed64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint64", string(value), objKey)
					}
					if i < length {
						this.ArrayFixed64[i] = x
					} else {
						this.ArrayFixed64 = append(this.ArrayFixed64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_fixed64
					}
				}
				if i < length {
					this.ArrayFixed64 = this.ArrayFixed64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sfixed32":
			// decode filed type of list; | field: gojsontest.Model1.array_sfixed32 | kind: Sfixed32Kind | GoName: ArraySfixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArraySfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArraySfixed32 == nil {
					this.ArraySfixed32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArraySfixed32)
			LOOP_LIST_array_sfixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sfixed32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArraySfixed32[i] = x
					} else {
						this.ArraySfixed32 = append(this.ArraySfixed32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sfixed32
					}
				}
				if i < length {
					this.ArraySfixed32 = this.ArraySfixed32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sfixed64":
			// decode filed type of list; | field: gojsontest.Model1.array_sfixed64 | kind: Sfixed64Kind | GoName: ArraySfixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArraySfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArraySfixed64 == nil {
					this.ArraySfixed64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArraySfixed64)
			LOOP_LIST_array_sfixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sfixed64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArraySfixed64[i] = x
					} else {
						this.ArraySfixed64 = append(this.ArraySfixed64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sfixed64
					}
				}
				if i < length {
					this.ArraySfixed64 = this.ArraySfixed64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bool":
			// decode filed type of list; | field: gojsontest.Model1.array_bool | kind: BoolKind | GoName: ArrayBool
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), objKey)
				} else {
					this.ArrayBool = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), objKey)
				}
				if this.ArrayBool == nil {
					this.ArrayBool = make([]bool, 0)
				}
				i := 0
				length := len(this.ArrayBool)
			LOOP_LIST_array_bool:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bool
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseBool(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []bool", string(value), objKey)
					}
					if i < length {
						this.ArrayBool[i] = x
					} else {
						this.ArrayBool = append(this.ArrayBool, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bool
					}
				}
				if i < length {
					this.ArrayBool = this.ArrayBool[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_string":
			// decode filed type of list; | field: gojsontest.Model1.array_string | kind: StringKind | GoName: ArrayString
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString == nil {
					this.ArrayString = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString)
			LOOP_LIST_array_string:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_string
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString[i] = x
					} else {
						this.ArrayString = append(this.ArrayString, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_string
					}
				}
				if i < length {
					this.ArrayString = this.ArrayString[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bytes":
			// decode filed type of list; | field: gojsontest.Model1.array_bytes | kind: BytesKind | GoName: ArrayBytes
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes == nil {
					this.ArrayBytes = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes)
			LOOP_LIST_array_bytes:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bytes
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes[i] = x
					} else {
						this.ArrayBytes = append(this.ArrayBytes, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bytes
					}
				}
				if i < length {
					this.ArrayBytes = this.ArrayBytes[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_embed_message":
			// decode filed type of list; | field: gojsontest.Model1.array_embed_message | kind: MessageKind | GoName: ArrayEmbedMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Model1_EmbedMessage1", string(value), objKey)
				} else {
					this.ArrayEmbedMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Model1_EmbedMessage1", string(value), objKey)
				}
				if this.ArrayEmbedMessage == nil {
					this.ArrayEmbedMessage = make([]*Model1_EmbedMessage1, 0)
				}
				i := 0
				length := len(this.ArrayEmbedMessage)
			LOOP_LIST_array_embed_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_embed_message
					}
					value := decoder.ReadItem()
					var x *Model1_EmbedMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayEmbedMessage[i]
						}
						if x == nil {
							x = new(Model1_EmbedMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayEmbedMessage[i] = x
					} else {
						this.ArrayEmbedMessage = append(this.ArrayEmbedMessage, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_embed_message
					}
				}
				if i < length {
					this.ArrayEmbedMessage = this.ArrayEmbedMessage[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_stand_message":
			// decode filed type of list; | field: gojsontest.Model1.array_stand_message | kind: MessageKind | GoName: ArrayStandMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*StandMessage1", string(value), objKey)
				} else {
					this.ArrayStandMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*StandMessage1", string(value), objKey)
				}
				if this.ArrayStandMessage == nil {
					this.ArrayStandMessage = make([]*StandMessage1, 0)
				}
				i := 0
				length := len(this.ArrayStandMessage)
			LOOP_LIST_array_stand_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_stand_message
					}
					value := decoder.ReadItem()
					var x *StandMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayStandMessage[i]
						}
						if x == nil {
							x = new(StandMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayStandMessage[i] = x
					} else {
						this.ArrayStandMessage = append(this.ArrayStandMessage, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_stand_message
					}
				}
				if i < length {
					this.ArrayStandMessage = this.ArrayStandMessage[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_external_message":
			// decode filed type of list; | field: gojsontest.Model1.array_external_message | kind: MessageKind | GoName: ArrayExternalMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.ArrayExternalMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.ArrayExternalMessage == nil {
					this.ArrayExternalMessage = make([]*gojsonexternal.ExternalMessage1, 0)
				}
				i := 0
				length := len(this.ArrayExternalMessage)
			LOOP_LIST_array_external_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_external_message
					}
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayExternalMessage[i]
						}
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayExternalMessage[i] = x
					} else {
						this.ArrayExternalMessage = append(this.ArrayExternalMessage, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_external_message
					}
				}
				if i < length {
					this.ArrayExternalMessage = this.ArrayExternalMessage[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_embed_enum":
			// decode filed type of list; | field: gojsontest.Model1.array_embed_enum | kind: EnumKind | GoName: ArrayEmbedEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Model1_EmbedEnum1", string(value), objKey)
				} else {
					this.ArrayEmbedEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Model1_EmbedEnum1", string(value), objKey)
				}
				if this.ArrayEmbedEnum == nil {
					this.ArrayEmbedEnum = make([]Model1_EmbedEnum1, 0)
				}
				i := 0
				length := len(this.ArrayEmbedEnum)
			LOOP_LIST_array_embed_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_embed_enum
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []Model1_EmbedEnum1", string(value), objKey)
					}
					_, ok := Model1_EmbedEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := Model1_EmbedEnum1(x1)
					if i < length {
						this.ArrayEmbedEnum[i] = x
					} else {
						this.ArrayEmbedEnum = append(this.ArrayEmbedEnum, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_embed_enum
					}
				}
				if i < length {
					this.ArrayEmbedEnum = this.ArrayEmbedEnum[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_stand_enum":
			// decode filed type of list; | field: gojsontest.Model1.array_stand_enum | kind: EnumKind | GoName: ArrayStandEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []StandEnum1", string(value), objKey)
				} else {
					this.ArrayStandEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []StandEnum1", string(value), objKey)
				}
				if this.ArrayStandEnum == nil {
					this.ArrayStandEnum = make([]StandEnum1, 0)
				}
				i := 0
				length := len(this.ArrayStandEnum)
			LOOP_LIST_array_stand_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_stand_enum
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []StandEnum1", string(value), objKey)
					}
					_, ok := StandEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := StandEnum1(x1)
					if i < length {
						this.ArrayStandEnum[i] = x
					} else {
						this.ArrayStandEnum = append(this.ArrayStandEnum, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_stand_enum
					}
				}
				if i < length {
					this.ArrayStandEnum = this.ArrayStandEnum[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_external_enum":
			// decode filed type of list; | field: gojsontest.Model1.array_external_enum | kind: EnumKind | GoName: ArrayExternalEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.ArrayExternalEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.ArrayExternalEnum == nil {
					this.ArrayExternalEnum = make([]gojsonexternal.ExternalEnum1, 0)
				}
				i := 0
				length := len(this.ArrayExternalEnum)
			LOOP_LIST_array_external_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_external_enum
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					if i < length {
						this.ArrayExternalEnum[i] = x
					} else {
						this.ArrayExternalEnum = append(this.ArrayExternalEnum, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_external_enum
					}
				}
				if i < length {
					this.ArrayExternalEnum = this.ArrayExternalEnum[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_stand_enum_null":
			// decode filed type of list; | field: gojsontest.Model1.array_stand_enum_null | kind: EnumKind | GoName: ArrayStandEnumNull
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []StandEnum1", string(value), objKey)
				} else {
					this.ArrayStandEnumNull = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []StandEnum1", string(value), objKey)
				}
				if this.ArrayStandEnumNull == nil {
					this.ArrayStandEnumNull = make([]StandEnum1, 0)
				}
				i := 0
				length := len(this.ArrayStandEnumNull)
			LOOP_LIST_array_stand_enum_null:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_stand_enum_null
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []StandEnum1", string(value), objKey)
					}
					_, ok := StandEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := StandEnum1(x1)
					if i < length {
						this.ArrayStandEnumNull[i] = x
					} else {
						this.ArrayStandEnumNull = append(this.ArrayStandEnumNull, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_stand_enum_null
					}
				}
				if i < length {
					this.ArrayStandEnumNull = this.ArrayStandEnumNull[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_double":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_double | keyKind: Int32Kind | valueKind: DoubleKind | goName: MapInt32Double
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float64", string(value), objKey)
				} else {
					this.MapInt32Double = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float64", string(value), objKey)
				}
				if this.MapInt32Double == nil { // create map if not initialized.
					this.MapInt32Double = make(map[int32]float64)
				}
			LOOP_MAP_map_int32_double:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_double
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]float64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]float64", string(value), objKey)
					}
					this.MapInt32Double[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_double
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_float":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_float | keyKind: Int32Kind | valueKind: FloatKind | goName: MapInt32Float
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float32", string(value), objKey)
				} else {
					this.MapInt32Float = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float32", string(value), objKey)
				}
				if this.MapInt32Float == nil { // create map if not initialized.
					this.MapInt32Float = make(map[int32]float32)
				}
			LOOP_MAP_map_int32_float:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_float
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]float32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]float32", string(value), objKey)
					}
					this.MapInt32Float[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_float
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_int32 | keyKind: Int32Kind | valueKind: Int32Kind | goName: MapInt32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Int32 == nil { // create map if not initialized.
					this.MapInt32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_map_int32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_int64":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_int64 | keyKind: Int32Kind | valueKind: Int64Kind | goName: MapInt32Int64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Int64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Int64 == nil { // create map if not initialized.
					this.MapInt32Int64 = make(map[int32]int64)
				}
			LOOP_MAP_map_int32_int64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_int64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Int64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_int64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_uint32":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_uint32 | keyKind: Int32Kind | valueKind: Uint32Kind | goName: MapInt32Uint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				} else {
					this.MapInt32Uint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				}
				if this.MapInt32Uint32 == nil { // create map if not initialized.
					this.MapInt32Uint32 = make(map[int32]uint32)
				}
			LOOP_MAP_map_int32_uint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_uint32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint32", string(value), objKey)
					}
					this.MapInt32Uint32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_uint32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_uint64":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_uint64 | keyKind: Int32Kind | valueKind: Uint64Kind | goName: MapInt32Uint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				} else {
					this.MapInt32Uint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				}
				if this.MapInt32Uint64 == nil { // create map if not initialized.
					this.MapInt32Uint64 = make(map[int32]uint64)
				}
			LOOP_MAP_map_int32_uint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_uint64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint64", string(value), objKey)
					}
					this.MapInt32Uint64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_uint64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sint32":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_sint32 | keyKind: Int32Kind | valueKind: Sint32Kind | goName: MapInt32Sint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Sint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Sint32 == nil { // create map if not initialized.
					this.MapInt32Sint32 = make(map[int32]int32)
				}
			LOOP_MAP_map_int32_sint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sint32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Sint32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sint32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sint64":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_sint64 | keyKind: Int32Kind | valueKind: Sint64Kind | goName: MapInt32Sint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Sint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Sint64 == nil { // create map if not initialized.
					this.MapInt32Sint64 = make(map[int32]int64)
				}
			LOOP_MAP_map_int32_sint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sint64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Sint64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sint64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_fixed32":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_fixed32 | keyKind: Int32Kind | valueKind: Fixed32Kind | goName: MapInt32Fixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				} else {
					this.MapInt32Fixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				}
				if this.MapInt32Fixed32 == nil { // create map if not initialized.
					this.MapInt32Fixed32 = make(map[int32]uint32)
				}
			LOOP_MAP_map_int32_fixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_fixed32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint32", string(value), objKey)
					}
					this.MapInt32Fixed32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_fixed32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_fixed64":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_fixed64 | keyKind: Int32Kind | valueKind: Fixed64Kind | goName: MapInt32Fixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				} else {
					this.MapInt32Fixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				}
				if this.MapInt32Fixed64 == nil { // create map if not initialized.
					this.MapInt32Fixed64 = make(map[int32]uint64)
				}
			LOOP_MAP_map_int32_fixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_fixed64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint64", string(value), objKey)
					}
					this.MapInt32Fixed64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_fixed64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sfixed32":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_sfixed32 | keyKind: Int32Kind | valueKind: Sfixed32Kind | goName: MapInt32Sfixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Sfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Sfixed32 == nil { // create map if not initialized.
					this.MapInt32Sfixed32 = make(map[int32]int32)
				}
			LOOP_MAP_map_int32_sfixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sfixed32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Sfixed32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sfixed32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sfixed64":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_sfixed64 | keyKind: Int32Kind | valueKind: Sfixed64Kind | goName: MapInt32Sfixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Sfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Sfixed64 == nil { // create map if not initialized.
					this.MapInt32Sfixed64 = make(map[int32]int64)
				}
			LOOP_MAP_map_int32_sfixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sfixed64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Sfixed64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sfixed64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_bool":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_bool | keyKind: Int32Kind | valueKind: BoolKind | goName: MapInt32Bool
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]bool", string(value), objKey)
				} else {
					this.MapInt32Bool = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]bool", string(value), objKey)
				}
				if this.MapInt32Bool == nil { // create map if not initialized.
					this.MapInt32Bool = make(map[int32]bool)
				}
			LOOP_MAP_map_int32_bool:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_bool
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]bool", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseBool(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]bool", string(value), objKey)
					}
					this.MapInt32Bool[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_bool
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_string":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_string | keyKind: Int32Kind | valueKind: StringKind | goName: MapInt32String
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]string", string(value), objKey)
				} else {
					this.MapInt32String = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]string", string(value), objKey)
				}
				if this.MapInt32String == nil { // create map if not initialized.
					this.MapInt32String = make(map[int32]string)
				}
			LOOP_MAP_map_int32_string:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_string
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]string", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]string", string(value), objKey)
						}
					}
					this.MapInt32String[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_string
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_bytes":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_bytes | keyKind: Int32Kind | valueKind: BytesKind | goName: MapInt32Bytes
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32][]byte", string(value), objKey)
				} else {
					this.MapInt32Bytes = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32][]byte", string(value), objKey)
				}
				if this.MapInt32Bytes == nil { // create map if not initialized.
					this.MapInt32Bytes = make(map[int32][]byte)
				}
			LOOP_MAP_map_int32_bytes:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_bytes
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32][]byte", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapInt32Bytes[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_bytes
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_embed_message":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_embed_message | keyKind: Int32Kind | valueKind: MessageKind | goName: MapInt32EmbedMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*Model1_EmbedMessage1", string(value), objKey)
				} else {
					this.MapInt32EmbedMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*Model1_EmbedMessage1", string(value), objKey)
				}
				if this.MapInt32EmbedMessage == nil { // create map if not initialized.
					this.MapInt32EmbedMessage = make(map[int32]*Model1_EmbedMessage1)
				}
			LOOP_MAP_map_int32_embed_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_embed_message
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]*Model1_EmbedMessage1", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *Model1_EmbedMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapInt32EmbedMessage[mapKey]
						if x == nil {
							x = new(Model1_EmbedMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapInt32EmbedMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_embed_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_stand_message":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_stand_message | keyKind: Int32Kind | valueKind: MessageKind | goName: MapInt32StandMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*StandMessage1", string(value), objKey)
				} else {
					this.MapInt32StandMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*StandMessage1", string(value), objKey)
				}
				if this.MapInt32StandMessage == nil { // create map if not initialized.
					this.MapInt32StandMessage = make(map[int32]*StandMessage1)
				}
			LOOP_MAP_map_int32_stand_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_stand_message
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]*StandMessage1", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *StandMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapInt32StandMessage[mapKey]
						if x == nil {
							x = new(StandMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapInt32StandMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_stand_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_embed_enum":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_embed_enum | keyKind: Int32Kind | valueKind: EnumKind | goName: MapInt32EmbedEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]Model1_EmbedEnum1", string(value), objKey)
				} else {
					this.MapInt32EmbedEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]Model1_EmbedEnum1", string(value), objKey)
				}
				if this.MapInt32EmbedEnum == nil { // create map if not initialized.
					this.MapInt32EmbedEnum = make(map[int32]Model1_EmbedEnum1)
				}
			LOOP_MAP_map_int32_embed_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_embed_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]Model1_EmbedEnum1", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]Model1_EmbedEnum1", string(value), objKey)
					}
					_, ok := Model1_EmbedEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := Model1_EmbedEnum1(x1)
					this.MapInt32EmbedEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_embed_enum
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_stand_enum":
			// decode filed type of map; | field: gojsontest.Model1.map_int32_stand_enum | keyKind: Int32Kind | valueKind: EnumKind | goName: MapInt32StandEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]StandEnum1", string(value), objKey)
				} else {
					this.MapInt32StandEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]StandEnum1", string(value), objKey)
				}
				if this.MapInt32StandEnum == nil { // create map if not initialized.
					this.MapInt32StandEnum = make(map[int32]StandEnum1)
				}
			LOOP_MAP_map_int32_stand_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_stand_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]StandEnum1", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]StandEnum1", string(value), objKey)
					}
					_, ok := StandEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := StandEnum1(x1)
					this.MapInt32StandEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_stand_enum
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int64_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_int64_int32 | keyKind: Int64Kind | valueKind: Int32Kind | goName: MapInt64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapInt64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapInt64Int32 == nil { // create map if not initialized.
					this.MapInt64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_map_int64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapInt64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_uint32_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_uint32_int32 | keyKind: Uint32Kind | valueKind: Int32Kind | goName: MapUint32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				} else {
					this.MapUint32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				}
				if this.MapUint32Int32 == nil { // create map if not initialized.
					this.MapUint32Int32 = make(map[uint32]int32)
				}
			LOOP_MAP_map_uint32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_uint32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseUint(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint32]int32", key, objKey)
					}
					mapKey := uint32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint32]int32", string(value), objKey)
					}
					this.MapUint32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_uint32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_uint64_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_uint64_int32 | keyKind: Uint64Kind | valueKind: Int32Kind | goName: MapUint64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				} else {
					this.MapUint64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				}
				if this.MapUint64Int32 == nil { // create map if not initialized.
					this.MapUint64Int32 = make(map[uint64]int32)
				}
			LOOP_MAP_map_uint64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_uint64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseUint(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint64]int32", string(value), objKey)
					}
					this.MapUint64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_uint64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sint32_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_sint32_int32 | keyKind: Sint32Kind | valueKind: Int32Kind | goName: MapSint32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapSint32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapSint32Int32 == nil { // create map if not initialized.
					this.MapSint32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_map_sint32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sint32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapSint32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sint32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sint64_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_sint64_int32 | keyKind: Sint64Kind | valueKind: Int32Kind | goName: MapSint64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapSint64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapSint64Int32 == nil { // create map if not initialized.
					this.MapSint64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_map_sint64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sint64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapSint64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sint64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_fixed32_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_fixed32_int32 | keyKind: Fixed32Kind | valueKind: Int32Kind | goName: MapFixed32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				} else {
					this.MapFixed32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				}
				if this.MapFixed32Int32 == nil { // create map if not initialized.
					this.MapFixed32Int32 = make(map[uint32]int32)
				}
			LOOP_MAP_map_fixed32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_fixed32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseUint(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint32]int32", key, objKey)
					}
					mapKey := uint32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint32]int32", string(value), objKey)
					}
					this.MapFixed32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_fixed32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_fixed64_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_fixed64_int32 | keyKind: Fixed64Kind | valueKind: Int32Kind | goName: MapFixed64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				} else {
					this.MapFixed64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				}
				if this.MapFixed64Int32 == nil { // create map if not initialized.
					this.MapFixed64Int32 = make(map[uint64]int32)
				}
			LOOP_MAP_map_fixed64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_fixed64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseUint(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint64]int32", string(value), objKey)
					}
					this.MapFixed64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_fixed64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sfixed32_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_sfixed32_int32 | keyKind: Sfixed32Kind | valueKind: Int32Kind | goName: MapSfixed32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapSfixed32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapSfixed32Int32 == nil { // create map if not initialized.
					this.MapSfixed32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_map_sfixed32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sfixed32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapSfixed32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sfixed32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sfixed64_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_sfixed64_int32 | keyKind: Sfixed64Kind | valueKind: Int32Kind | goName: MapSfixed64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapSfixed64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapSfixed64Int32 == nil { // create map if not initialized.
					this.MapSfixed64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_map_sfixed64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sfixed64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapSfixed64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sfixed64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_int32":
			// decode filed type of map; | field: gojsontest.Model1.map_string_int32 | keyKind: StringKind | valueKind: Int32Kind | goName: MapStringInt32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				} else {
					this.MapStringInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				}
				if this.MapStringInt32 == nil { // create map if not initialized.
					this.MapStringInt32 = make(map[string]int32)
				}
			LOOP_MAP_map_string_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]int32", string(value), objKey)
					}
					this.MapStringInt32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_int32_null":
			// decode filed type of map; | field: gojsontest.Model1.map_string_int32_null | keyKind: StringKind | valueKind: Int32Kind | goName: MapStringInt32Null
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				} else {
					this.MapStringInt32Null = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				}
				if this.MapStringInt32Null == nil { // create map if not initialized.
					this.MapStringInt32Null = make(map[string]int32)
				}
			LOOP_MAP_map_string_int32_null:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_int32_null
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]int32", string(value), objKey)
					}
					this.MapStringInt32Null[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_int32_null
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_string":
			// decode filed type of map; | field: gojsontest.Model1.map_string_string | keyKind: StringKind | valueKind: StringKind | goName: MapStringString
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				} else {
					this.MapStringString = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				}
				if this.MapStringString == nil { // create map if not initialized.
					this.MapStringString = make(map[string]string)
				}
			LOOP_MAP_map_string_string:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_string
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]string", string(value), objKey)
						}
					}
					this.MapStringString[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_string
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_embed_message":
			// decode filed type of map; | field: gojsontest.Model1.map_string_embed_message | keyKind: StringKind | valueKind: MessageKind | goName: MapStringEmbedMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Model1_EmbedMessage1", string(value), objKey)
				} else {
					this.MapStringEmbedMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Model1_EmbedMessage1", string(value), objKey)
				}
				if this.MapStringEmbedMessage == nil { // create map if not initialized.
					this.MapStringEmbedMessage = make(map[string]*Model1_EmbedMessage1)
				}
			LOOP_MAP_map_string_embed_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_embed_message
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *Model1_EmbedMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapStringEmbedMessage[mapKey]
						if x == nil {
							x = new(Model1_EmbedMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapStringEmbedMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_embed_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_stand_message":
			// decode filed type of map; | field: gojsontest.Model1.map_string_stand_message | keyKind: StringKind | valueKind: MessageKind | goName: MapStringStandMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*StandMessage1", string(value), objKey)
				} else {
					this.MapStringStandMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*StandMessage1", string(value), objKey)
				}
				if this.MapStringStandMessage == nil { // create map if not initialized.
					this.MapStringStandMessage = make(map[string]*StandMessage1)
				}
			LOOP_MAP_map_string_stand_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_stand_message
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *StandMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapStringStandMessage[mapKey]
						if x == nil {
							x = new(StandMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapStringStandMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_stand_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_external_message":
			// decode filed type of map; | field: gojsontest.Model1.map_string_external_message | keyKind: StringKind | valueKind: MessageKind | goName: MapStringExternalMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.MapStringExternalMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.MapStringExternalMessage == nil { // create map if not initialized.
					this.MapStringExternalMessage = make(map[string]*gojsonexternal.ExternalMessage1)
				}
			LOOP_MAP_map_string_external_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_external_message
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapStringExternalMessage[mapKey]
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapStringExternalMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_external_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_embed_enum":
			// decode filed type of map; | field: gojsontest.Model1.map_string_embed_enum | keyKind: StringKind | valueKind: EnumKind | goName: MapStringEmbedEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Model1_EmbedEnum1", string(value), objKey)
				} else {
					this.MapStringEmbedEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Model1_EmbedEnum1", string(value), objKey)
				}
				if this.MapStringEmbedEnum == nil { // create map if not initialized.
					this.MapStringEmbedEnum = make(map[string]Model1_EmbedEnum1)
				}
			LOOP_MAP_map_string_embed_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_embed_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]Model1_EmbedEnum1", string(value), objKey)
					}
					_, ok := Model1_EmbedEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := Model1_EmbedEnum1(x1)
					this.MapStringEmbedEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_embed_enum
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_stand_enum":
			// decode filed type of map; | field: gojsontest.Model1.map_string_stand_enum | keyKind: StringKind | valueKind: EnumKind | goName: MapStringStandEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]StandEnum1", string(value), objKey)
				} else {
					this.MapStringStandEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]StandEnum1", string(value), objKey)
				}
				if this.MapStringStandEnum == nil { // create map if not initialized.
					this.MapStringStandEnum = make(map[string]StandEnum1)
				}
			LOOP_MAP_map_string_stand_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_stand_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]StandEnum1", string(value), objKey)
					}
					_, ok := StandEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := StandEnum1(x1)
					this.MapStringStandEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_stand_enum
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_external_enum":
			// decode filed type of map; | field: gojsontest.Model1.map_string_external_enum | keyKind: StringKind | valueKind: EnumKind | goName: MapStringExternalEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.MapStringExternalEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.MapStringExternalEnum == nil { // create map if not initialized.
					this.MapStringExternalEnum = make(map[string]gojsonexternal.ExternalEnum1)
				}
			LOOP_MAP_map_string_external_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_external_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					this.MapStringExternalEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_external_enum
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *Model1_EmbedMessage1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(38)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.Model1.EmbedMessage1.age1 | kind: StringKind | GoName: Age1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("age1")
	encoder.AppendString(this.Age1)
	// encode filed type of basic; | field: gojsontest.Model1.EmbedMessage1.age2 | kind: StringKind | GoName: Age2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("age2")
	encoder.AppendString(this.Age2)
	// encode filed type of basic; | field: gojsontest.Model1.EmbedMessage1.age3 | kind: StringKind | GoName: Age3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("age3")
	encoder.AppendString(this.Age3)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *Model1_EmbedMessage1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*Model1_EmbedMessage1) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "age1":
			// decode filed type of basic; | field: gojsontest.Model1.EmbedMessage1.age1 | kind: StringKind | GoName: Age1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Age1 = x
		case objKey == "age2":
			// decode filed type of basic; | field: gojsontest.Model1.EmbedMessage1.age2 | kind: StringKind | GoName: Age2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Age2 = x
		case objKey == "age3":
			// decode filed type of basic; | field: gojsontest.Model1.EmbedMessage1.age3 | kind: StringKind | GoName: Age3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Age3 = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *Model2) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(2988)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.Model2.type_double1 | kind: DoubleKind | GoName: TypeDouble1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_double1")
	encoder.AppendFloat64(this.TypeDouble1)
	// encode filed type of basic; | field: gojsontest.Model2.type_double2 | kind: DoubleKind | GoName: TypeDouble2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_double2")
	encoder.AppendFloat64(this.TypeDouble2)
	// encode filed type of basic; | field: gojsontest.Model2.type_double3 | kind: DoubleKind | GoName: TypeDouble3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_double3")
	encoder.AppendFloat64(this.TypeDouble3)
	// encode filed type of basic; | field: gojsontest.Model2.type_double4 | kind: DoubleKind | GoName: TypeDouble4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_double4")
	encoder.AppendFloat64(this.TypeDouble4)
	// encode filed type of basic; | field: gojsontest.Model2.type_double5 | kind: DoubleKind | GoName: TypeDouble5 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_double5")
	encoder.AppendFloat64(this.TypeDouble5)
	// encode filed type of basic; | field: gojsontest.Model2.type_float | kind: FloatKind | GoName: TypeFloat | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_float")
	encoder.AppendFloat32(this.TypeFloat)
	// encode filed type of basic; | field: gojsontest.Model2.type_int32 | kind: Int32Kind | GoName: TypeInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_int32")
	encoder.AppendInt32(this.TypeInt32)
	// encode filed type of basic; | field: gojsontest.Model2.type_int64 | kind: Int64Kind | GoName: TypeInt64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_int64")
	encoder.AppendInt64(this.TypeInt64)
	// encode filed type of basic; | field: gojsontest.Model2.type_uint32 | kind: Uint32Kind | GoName: TypeUint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_uint32")
	encoder.AppendUint32(this.TypeUint32)
	// encode filed type of basic; | field: gojsontest.Model2.type_uint64 | kind: Uint64Kind | GoName: TypeUint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_uint64")
	encoder.AppendUint64(this.TypeUint64)
	// encode filed type of basic; | field: gojsontest.Model2.type_sint32 | kind: Sint32Kind | GoName: TypeSint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_sint32")
	encoder.AppendInt32(this.TypeSint32)
	// encode filed type of basic; | field: gojsontest.Model2.type_sint64 | kind: Sint64Kind | GoName: TypeSint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_sint64")
	encoder.AppendInt64(this.TypeSint64)
	// encode filed type of basic; | field: gojsontest.Model2.type_fixed32 | kind: Fixed32Kind | GoName: TypeFixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_fixed32")
	encoder.AppendUint32(this.TypeFixed32)
	// encode filed type of basic; | field: gojsontest.Model2.type_fixed64 | kind: Fixed64Kind | GoName: TypeFixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_fixed64")
	encoder.AppendUint64(this.TypeFixed64)
	// encode filed type of basic; | field: gojsontest.Model2.type_sfixed32 | kind: Sfixed32Kind | GoName: TypeSfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_sfixed32")
	encoder.AppendInt32(this.TypeSfixed32)
	// encode filed type of basic; | field: gojsontest.Model2.type_sfixed64 | kind: Sfixed64Kind | GoName: TypeSfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_sfixed64")
	encoder.AppendInt64(this.TypeSfixed64)
	// encode filed type of basic; | field: gojsontest.Model2.type_bool1 | kind: BoolKind | GoName: TypeBool1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_bool1")
	encoder.AppendBool(this.TypeBool1)
	// encode filed type of basic; | field: gojsontest.Model2.type_bool2 | kind: BoolKind | GoName: TypeBool2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_bool2")
	encoder.AppendBool(this.TypeBool2)
	// encode filed type of basic; | field: gojsontest.Model2.type_string1 | kind: StringKind | GoName: TypeString1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string1")
	encoder.AppendString(this.TypeString1)
	// encode filed type of basic; | field: gojsontest.Model2.type_string2 | kind: StringKind | GoName: TypeString2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string2")
	encoder.AppendString(this.TypeString2)
	// encode filed type of basic; | field: gojsontest.Model2.type_string3 | kind: StringKind | GoName: TypeString3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string3")
	encoder.AppendString(this.TypeString3)
	// encode filed type of basic; | field: gojsontest.Model2.type_string4 | kind: StringKind | GoName: TypeString4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string4")
	encoder.AppendString(this.TypeString4)
	// encode filed type of basic; | field: gojsontest.Model2.type_string5 | kind: StringKind | GoName: TypeString5 | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_string5")
	encoder.AppendString(this.TypeString5)
	// encode filed type of basic; | field: gojsontest.Model2.type_bytes | kind: BytesKind | GoName: TypeBytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_bytes")
	encoder.AppendBytes(this.TypeBytes)
	// encode filed type of basic; | field: gojsontest.Model2.type_embed_message | kind: MessageKind | GoName: TypeEmbedMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_embed_message")
	err = encoder.AppendInterface(this.TypeEmbedMessage)
	if err != nil {
		return nil, err
	}
	// encode filed type of basic; | field: gojsontest.Model2.type_stand_message | kind: MessageKind | GoName: TypeStandMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_stand_message")
	err = encoder.AppendInterface(this.TypeStandMessage)
	if err != nil {
		return nil, err
	}
	// encode filed type of basic; | field: gojsontest.Model2.type_embed_enum | kind: EnumKind | GoName: TypeEmbedEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_embed_enum")
	encoder.AppendInt32(int32(this.TypeEmbedEnum.Number()))
	// encode filed type of basic; | field: gojsontest.Model2.type_stand_enum | kind: EnumKind | GoName: TypeStandEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_stand_enum")
	encoder.AppendInt32(int32(this.TypeStandEnum.Number()))
	// encode filed type of basic; | field: gojsontest.Model2.type_external_enum | kind: EnumKind | GoName: TypeExternalEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_external_enum")
	encoder.AppendInt32(int32(this.TypeExternalEnum.Number()))
	// encode filed type of basic; | field: gojsontest.Model2.type_external_message | kind: MessageKind | GoName: TypeExternalMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("type_external_message")
	err = encoder.AppendInterface(this.TypeExternalMessage)
	if err != nil {
		return nil, err
	}
	// encode field type of list; | field: gojsontest.Model2.array_double | kind:DoubleKind | goName: ArrayDouble | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_double")
	if this.ArrayDouble != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayDouble {
			encoder.AppendFloat64(this.ArrayDouble[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_float | kind:FloatKind | goName: ArrayFloat | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_float")
	if this.ArrayFloat != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayFloat {
			encoder.AppendFloat32(this.ArrayFloat[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_int32 | kind:Int32Kind | goName: ArrayInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_int32")
	if this.ArrayInt32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayInt32 {
			encoder.AppendInt32(this.ArrayInt32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_int64 | kind:Int64Kind | goName: ArrayInt64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_int64")
	if this.ArrayInt64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayInt64 {
			encoder.AppendInt64(this.ArrayInt64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_uint32 | kind:Uint32Kind | goName: ArrayUint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_uint32")
	if this.ArrayUint32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayUint32 {
			encoder.AppendUint32(this.ArrayUint32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_uint64 | kind:Uint64Kind | goName: ArrayUint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_uint64")
	if this.ArrayUint64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayUint64 {
			encoder.AppendUint64(this.ArrayUint64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_sint32 | kind:Sint32Kind | goName: ArraySint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sint32")
	if this.ArraySint32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySint32 {
			encoder.AppendInt32(this.ArraySint32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_sint64 | kind:Sint64Kind | goName: ArraySint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sint64")
	if this.ArraySint64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySint64 {
			encoder.AppendInt64(this.ArraySint64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_fixed32 | kind:Fixed32Kind | goName: ArrayFixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_fixed32")
	if this.ArrayFixed32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayFixed32 {
			encoder.AppendUint32(this.ArrayFixed32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_fixed64 | kind:Fixed64Kind | goName: ArrayFixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_fixed64")
	if this.ArrayFixed64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayFixed64 {
			encoder.AppendUint64(this.ArrayFixed64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_sfixed32 | kind:Sfixed32Kind | goName: ArraySfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sfixed32")
	if this.ArraySfixed32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySfixed32 {
			encoder.AppendInt32(this.ArraySfixed32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_sfixed64 | kind:Sfixed64Kind | goName: ArraySfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sfixed64")
	if this.ArraySfixed64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySfixed64 {
			encoder.AppendInt64(this.ArraySfixed64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_bool | kind:BoolKind | goName: ArrayBool | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_bool")
	if this.ArrayBool != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayBool {
			encoder.AppendBool(this.ArrayBool[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_string | kind:StringKind | goName: ArrayString | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_string")
	if this.ArrayString != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayString {
			encoder.AppendString(this.ArrayString[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_bytes | kind:BytesKind | goName: ArrayBytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_bytes")
	if this.ArrayBytes != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayBytes {
			encoder.AppendBytes(this.ArrayBytes[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_embed_message | kind:MessageKind | goName: ArrayEmbedMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_embed_message")
	if this.ArrayEmbedMessage != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayEmbedMessage {
			err = encoder.AppendInterface(this.ArrayEmbedMessage[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_stand_message | kind:MessageKind | goName: ArrayStandMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_stand_message")
	if this.ArrayStandMessage != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayStandMessage {
			err = encoder.AppendInterface(this.ArrayStandMessage[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_external_message | kind:MessageKind | goName: ArrayExternalMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_external_message")
	if this.ArrayExternalMessage != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayExternalMessage {
			err = encoder.AppendInterface(this.ArrayExternalMessage[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_embed_enum | kind:EnumKind | goName: ArrayEmbedEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_embed_enum")
	if this.ArrayEmbedEnum != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayEmbedEnum {
			encoder.AppendInt32(int32(this.ArrayEmbedEnum[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_stand_enum | kind:EnumKind | goName: ArrayStandEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_stand_enum")
	if this.ArrayStandEnum != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayStandEnum {
			encoder.AppendInt32(int32(this.ArrayStandEnum[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.Model2.array_external_enum | kind:EnumKind | goName: ArrayExternalEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_external_enum")
	if this.ArrayExternalEnum != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayExternalEnum {
			encoder.AppendInt32(int32(this.ArrayExternalEnum[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_double | keyKind: int32 | valueKind: double | goName: MapInt32Double | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_double")
	if this.MapInt32Double != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Double {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendFloat64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_float | keyKind: int32 | valueKind: float | goName: MapInt32Float | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_float")
	if this.MapInt32Float != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Float {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendFloat32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_int32 | keyKind: int32 | valueKind: int32 | goName: MapInt32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_int32")
	if this.MapInt32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_int64 | keyKind: int32 | valueKind: int64 | goName: MapInt32Int64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_int64")
	if this.MapInt32Int64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Int64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_uint32 | keyKind: int32 | valueKind: uint32 | goName: MapInt32Uint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_uint32")
	if this.MapInt32Uint32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Uint32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_uint64 | keyKind: int32 | valueKind: uint64 | goName: MapInt32Uint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_uint64")
	if this.MapInt32Uint64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Uint64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_sint32 | keyKind: int32 | valueKind: sint32 | goName: MapInt32Sint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sint32")
	if this.MapInt32Sint32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sint32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_sint64 | keyKind: int32 | valueKind: sint64 | goName: MapInt32Sint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sint64")
	if this.MapInt32Sint64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sint64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_fixed32 | keyKind: int32 | valueKind: fixed32 | goName: MapInt32Fixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_fixed32")
	if this.MapInt32Fixed32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Fixed32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_fixed64 | keyKind: int32 | valueKind: fixed64 | goName: MapInt32Fixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_fixed64")
	if this.MapInt32Fixed64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Fixed64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_sfixed32 | keyKind: int32 | valueKind: sfixed32 | goName: MapInt32Sfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sfixed32")
	if this.MapInt32Sfixed32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sfixed32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_sfixed64 | keyKind: int32 | valueKind: sfixed64 | goName: MapInt32Sfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sfixed64")
	if this.MapInt32Sfixed64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sfixed64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_bool | keyKind: int32 | valueKind: bool | goName: MapInt32Bool | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_bool")
	if this.MapInt32Bool != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Bool {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendBool(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_string | keyKind: int32 | valueKind: string | goName: MapInt32String | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_string")
	if this.MapInt32String != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32String {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_bytes | keyKind: int32 | valueKind: bytes | goName: MapInt32Bytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_bytes")
	if this.MapInt32Bytes != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Bytes {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_embed_message | keyKind: int32 | valueKind: message | goName: MapInt32EmbedMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_embed_message")
	if this.MapInt32EmbedMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32EmbedMessage {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_stand_message | keyKind: int32 | valueKind: message | goName: MapInt32StandMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_stand_message")
	if this.MapInt32StandMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32StandMessage {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_embed_enum | keyKind: int32 | valueKind: enum | goName: MapInt32EmbedEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_embed_enum")
	if this.MapInt32EmbedEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32EmbedEnum {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int32_stand_enum | keyKind: int32 | valueKind: enum | goName: MapInt32StandEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_stand_enum")
	if this.MapInt32StandEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32StandEnum {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_int64_int32 | keyKind: int64 | valueKind: int32 | goName: MapInt64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int64_int32")
	if this.MapInt64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_uint32_int32 | keyKind: uint32 | valueKind: int32 | goName: MapUint32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_uint32_int32")
	if this.MapUint32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapUint32Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(uint64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_uint64_int32 | keyKind: uint64 | valueKind: int32 | goName: MapUint64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_uint64_int32")
	if this.MapUint64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapUint64Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_sint32_int32 | keyKind: sint32 | valueKind: int32 | goName: MapSint32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sint32_int32")
	if this.MapSint32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSint32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_sint64_int32 | keyKind: sint64 | valueKind: int32 | goName: MapSint64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sint64_int32")
	if this.MapSint64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSint64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_fixed32_int32 | keyKind: fixed32 | valueKind: int32 | goName: MapFixed32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_fixed32_int32")
	if this.MapFixed32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapFixed32Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(uint64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_fixed64_int32 | keyKind: fixed64 | valueKind: int32 | goName: MapFixed64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_fixed64_int32")
	if this.MapFixed64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapFixed64Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_sfixed32_int32 | keyKind: sfixed32 | valueKind: int32 | goName: MapSfixed32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sfixed32_int32")
	if this.MapSfixed32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSfixed32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_sfixed64_int32 | keyKind: sfixed64 | valueKind: int32 | goName: MapSfixed64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sfixed64_int32")
	if this.MapSfixed64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSfixed64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_string_int32 | keyKind: string | valueKind: int32 | goName: MapStringInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_int32")
	if this.MapStringInt32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringInt32 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_string_string | keyKind: string | valueKind: string | goName: MapStringString | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_string")
	if this.MapStringString != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringString {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_string_embed_message | keyKind: string | valueKind: message | goName: MapStringEmbedMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_embed_message")
	if this.MapStringEmbedMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringEmbedMessage {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_string_stand_message | keyKind: string | valueKind: message | goName: MapStringStandMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_stand_message")
	if this.MapStringStandMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringStandMessage {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_string_external_message | keyKind: string | valueKind: message | goName: MapStringExternalMessage | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_external_message")
	if this.MapStringExternalMessage != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringExternalMessage {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_string_embed_enum | keyKind: string | valueKind: enum | goName: MapStringEmbedEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_embed_enum")
	if this.MapStringEmbedEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringEmbedEnum {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_string_stand_enum | keyKind: string | valueKind: enum | goName: MapStringStandEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_stand_enum")
	if this.MapStringStandEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringStandEnum {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.Model2.map_string_external_enum | keyKind: string | valueKind: enum | goName: MapStringExternalEnum | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_external_enum")
	if this.MapStringExternalEnum != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringExternalEnum {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *Model2) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*Model2) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "type_double1":
			// decode filed type of basic; | field: gojsontest.Model2.type_double1 | kind: DoubleKind | GoName: TypeDouble1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TypeDouble1 = x
		case objKey == "type_double2":
			// decode filed type of basic; | field: gojsontest.Model2.type_double2 | kind: DoubleKind | GoName: TypeDouble2
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TypeDouble2 = x
		case objKey == "type_double3":
			// decode filed type of basic; | field: gojsontest.Model2.type_double3 | kind: DoubleKind | GoName: TypeDouble3
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TypeDouble3 = x
		case objKey == "type_double4":
			// decode filed type of basic; | field: gojsontest.Model2.type_double4 | kind: DoubleKind | GoName: TypeDouble4
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TypeDouble4 = x
		case objKey == "type_double5":
			// decode filed type of basic; | field: gojsontest.Model2.type_double5 | kind: DoubleKind | GoName: TypeDouble5
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TypeDouble5 = x
		case objKey == "type_float":
			// decode filed type of basic; | field: gojsontest.Model2.type_float | kind: FloatKind | GoName: TypeFloat
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
			}
			this.TypeFloat = x
		case objKey == "type_int32":
			// decode filed type of basic; | field: gojsontest.Model2.type_int32 | kind: Int32Kind | GoName: TypeInt32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TypeInt32 = x
		case objKey == "type_int64":
			// decode filed type of basic; | field: gojsontest.Model2.type_int64 | kind: Int64Kind | GoName: TypeInt64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TypeInt64 = x
		case objKey == "type_uint32":
			// decode filed type of basic; | field: gojsontest.Model2.type_uint32 | kind: Uint32Kind | GoName: TypeUint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TypeUint32 = x
		case objKey == "type_uint64":
			// decode filed type of basic; | field: gojsontest.Model2.type_uint64 | kind: Uint64Kind | GoName: TypeUint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TypeUint64 = x
		case objKey == "type_sint32":
			// decode filed type of basic; | field: gojsontest.Model2.type_sint32 | kind: Sint32Kind | GoName: TypeSint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TypeSint32 = x
		case objKey == "type_sint64":
			// decode filed type of basic; | field: gojsontest.Model2.type_sint64 | kind: Sint64Kind | GoName: TypeSint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TypeSint64 = x
		case objKey == "type_fixed32":
			// decode filed type of basic; | field: gojsontest.Model2.type_fixed32 | kind: Fixed32Kind | GoName: TypeFixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TypeFixed32 = x
		case objKey == "type_fixed64":
			// decode filed type of basic; | field: gojsontest.Model2.type_fixed64 | kind: Fixed64Kind | GoName: TypeFixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TypeFixed64 = x
		case objKey == "type_sfixed32":
			// decode filed type of basic; | field: gojsontest.Model2.type_sfixed32 | kind: Sfixed32Kind | GoName: TypeSfixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TypeSfixed32 = x
		case objKey == "type_sfixed64":
			// decode filed type of basic; | field: gojsontest.Model2.type_sfixed64 | kind: Sfixed64Kind | GoName: TypeSfixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TypeSfixed64 = x
		case objKey == "type_bool1":
			// decode filed type of basic; | field: gojsontest.Model2.type_bool1 | kind: BoolKind | GoName: TypeBool1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			this.TypeBool1 = x
		case objKey == "type_bool2":
			// decode filed type of basic; | field: gojsontest.Model2.type_bool2 | kind: BoolKind | GoName: TypeBool2
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			this.TypeBool2 = x
		case objKey == "type_string1":
			// decode filed type of basic; | field: gojsontest.Model2.type_string1 | kind: StringKind | GoName: TypeString1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString1 = x
		case objKey == "type_string2":
			// decode filed type of basic; | field: gojsontest.Model2.type_string2 | kind: StringKind | GoName: TypeString2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString2 = x
		case objKey == "type_string3":
			// decode filed type of basic; | field: gojsontest.Model2.type_string3 | kind: StringKind | GoName: TypeString3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString3 = x
		case objKey == "type_string4":
			// decode filed type of basic; | field: gojsontest.Model2.type_string4 | kind: StringKind | GoName: TypeString4
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString4 = x
		case objKey == "type_string5":
			// decode filed type of basic; | field: gojsontest.Model2.type_string5 | kind: StringKind | GoName: TypeString5
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TypeString5 = x
		case objKey == "type_bytes":
			// decode filed type of basic; | field: gojsontest.Model2.type_bytes | kind: BytesKind | GoName: TypeBytes
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.TypeBytes = x
		case objKey == "type_embed_message":
			// decode filed type of basic; | field: gojsontest.Model2.type_embed_message | kind: MessageKind | GoName: TypeEmbedMessage
			value := decoder.ReadItem()
			var x *Model2_EmbedMessage1
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TypeEmbedMessage == nil {
					x = new(Model2_EmbedMessage1)
				} else {
					x = this.TypeEmbedMessage
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TypeEmbedMessage = x
		case objKey == "type_stand_message":
			// decode filed type of basic; | field: gojsontest.Model2.type_stand_message | kind: MessageKind | GoName: TypeStandMessage
			value := decoder.ReadItem()
			var x *StandMessage1
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TypeStandMessage == nil {
					x = new(StandMessage1)
				} else {
					x = this.TypeStandMessage
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TypeStandMessage = x
		case objKey == "type_embed_enum":
			// decode filed type of basic; | field: gojsontest.Model2.type_embed_enum | kind: EnumKind | GoName: TypeEmbedEnum
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type Model2_EmbedEnum1", string(value), objKey)
			}
			_, ok := Model2_EmbedEnum1_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := Model2_EmbedEnum1(x1)
			this.TypeEmbedEnum = x
		case objKey == "type_stand_enum":
			// decode filed type of basic; | field: gojsontest.Model2.type_stand_enum | kind: EnumKind | GoName: TypeStandEnum
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type StandEnum1", string(value), objKey)
			}
			_, ok := StandEnum1_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := StandEnum1(x1)
			this.TypeStandEnum = x
		case objKey == "type_external_enum":
			// decode filed type of basic; | field: gojsontest.Model2.type_external_enum | kind: EnumKind | GoName: TypeExternalEnum
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type gojsonexternal.ExternalEnum1", string(value), objKey)
			}
			_, ok := gojsonexternal.ExternalEnum1_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := gojsonexternal.ExternalEnum1(x1)
			this.TypeExternalEnum = x
		case objKey == "type_external_message":
			// decode filed type of basic; | field: gojsontest.Model2.type_external_message | kind: MessageKind | GoName: TypeExternalMessage
			value := decoder.ReadItem()
			var x *gojsonexternal.ExternalMessage1
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TypeExternalMessage == nil {
					x = new(gojsonexternal.ExternalMessage1)
				} else {
					x = this.TypeExternalMessage
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TypeExternalMessage = x
		case objKey == "array_double":
			// decode filed type of list; | field: gojsontest.Model2.array_double | kind: DoubleKind | GoName: ArrayDouble
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), objKey)
				} else {
					this.ArrayDouble = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), objKey)
				}
				if this.ArrayDouble == nil {
					this.ArrayDouble = make([]float64, 0)
				}
				i := 0
				length := len(this.ArrayDouble)
			LOOP_LIST_array_double:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_double
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []float64", string(value), objKey)
					}
					if i < length {
						this.ArrayDouble[i] = x
					} else {
						this.ArrayDouble = append(this.ArrayDouble, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_double
					}
				}
				if i < length {
					this.ArrayDouble = this.ArrayDouble[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_float":
			// decode filed type of list; | field: gojsontest.Model2.array_float | kind: FloatKind | GoName: ArrayFloat
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), objKey)
				} else {
					this.ArrayFloat = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), objKey)
				}
				if this.ArrayFloat == nil {
					this.ArrayFloat = make([]float32, 0)
				}
				i := 0
				length := len(this.ArrayFloat)
			LOOP_LIST_array_float:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_float
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []float32", string(value), objKey)
					}
					if i < length {
						this.ArrayFloat[i] = x
					} else {
						this.ArrayFloat = append(this.ArrayFloat, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_float
					}
				}
				if i < length {
					this.ArrayFloat = this.ArrayFloat[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_int32":
			// decode filed type of list; | field: gojsontest.Model2.array_int32 | kind: Int32Kind | GoName: ArrayInt32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArrayInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArrayInt32 == nil {
					this.ArrayInt32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArrayInt32)
			LOOP_LIST_array_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_int32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArrayInt32[i] = x
					} else {
						this.ArrayInt32 = append(this.ArrayInt32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_int32
					}
				}
				if i < length {
					this.ArrayInt32 = this.ArrayInt32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_int64":
			// decode filed type of list; | field: gojsontest.Model2.array_int64 | kind: Int64Kind | GoName: ArrayInt64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArrayInt64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArrayInt64 == nil {
					this.ArrayInt64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArrayInt64)
			LOOP_LIST_array_int64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_int64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArrayInt64[i] = x
					} else {
						this.ArrayInt64 = append(this.ArrayInt64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_int64
					}
				}
				if i < length {
					this.ArrayInt64 = this.ArrayInt64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_uint32":
			// decode filed type of list; | field: gojsontest.Model2.array_uint32 | kind: Uint32Kind | GoName: ArrayUint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				} else {
					this.ArrayUint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				}
				if this.ArrayUint32 == nil {
					this.ArrayUint32 = make([]uint32, 0)
				}
				i := 0
				length := len(this.ArrayUint32)
			LOOP_LIST_array_uint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_uint32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint32", string(value), objKey)
					}
					if i < length {
						this.ArrayUint32[i] = x
					} else {
						this.ArrayUint32 = append(this.ArrayUint32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_uint32
					}
				}
				if i < length {
					this.ArrayUint32 = this.ArrayUint32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_uint64":
			// decode filed type of list; | field: gojsontest.Model2.array_uint64 | kind: Uint64Kind | GoName: ArrayUint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				} else {
					this.ArrayUint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				}
				if this.ArrayUint64 == nil {
					this.ArrayUint64 = make([]uint64, 0)
				}
				i := 0
				length := len(this.ArrayUint64)
			LOOP_LIST_array_uint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_uint64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint64", string(value), objKey)
					}
					if i < length {
						this.ArrayUint64[i] = x
					} else {
						this.ArrayUint64 = append(this.ArrayUint64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_uint64
					}
				}
				if i < length {
					this.ArrayUint64 = this.ArrayUint64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sint32":
			// decode filed type of list; | field: gojsontest.Model2.array_sint32 | kind: Sint32Kind | GoName: ArraySint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArraySint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArraySint32 == nil {
					this.ArraySint32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArraySint32)
			LOOP_LIST_array_sint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sint32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArraySint32[i] = x
					} else {
						this.ArraySint32 = append(this.ArraySint32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sint32
					}
				}
				if i < length {
					this.ArraySint32 = this.ArraySint32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sint64":
			// decode filed type of list; | field: gojsontest.Model2.array_sint64 | kind: Sint64Kind | GoName: ArraySint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArraySint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArraySint64 == nil {
					this.ArraySint64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArraySint64)
			LOOP_LIST_array_sint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sint64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArraySint64[i] = x
					} else {
						this.ArraySint64 = append(this.ArraySint64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sint64
					}
				}
				if i < length {
					this.ArraySint64 = this.ArraySint64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_fixed32":
			// decode filed type of list; | field: gojsontest.Model2.array_fixed32 | kind: Fixed32Kind | GoName: ArrayFixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				} else {
					this.ArrayFixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				}
				if this.ArrayFixed32 == nil {
					this.ArrayFixed32 = make([]uint32, 0)
				}
				i := 0
				length := len(this.ArrayFixed32)
			LOOP_LIST_array_fixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_fixed32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint32", string(value), objKey)
					}
					if i < length {
						this.ArrayFixed32[i] = x
					} else {
						this.ArrayFixed32 = append(this.ArrayFixed32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_fixed32
					}
				}
				if i < length {
					this.ArrayFixed32 = this.ArrayFixed32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_fixed64":
			// decode filed type of list; | field: gojsontest.Model2.array_fixed64 | kind: Fixed64Kind | GoName: ArrayFixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				} else {
					this.ArrayFixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				}
				if this.ArrayFixed64 == nil {
					this.ArrayFixed64 = make([]uint64, 0)
				}
				i := 0
				length := len(this.ArrayFixed64)
			LOOP_LIST_array_fixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_fixed64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint64", string(value), objKey)
					}
					if i < length {
						this.ArrayFixed64[i] = x
					} else {
						this.ArrayFixed64 = append(this.ArrayFixed64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_fixed64
					}
				}
				if i < length {
					this.ArrayFixed64 = this.ArrayFixed64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sfixed32":
			// decode filed type of list; | field: gojsontest.Model2.array_sfixed32 | kind: Sfixed32Kind | GoName: ArraySfixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArraySfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArraySfixed32 == nil {
					this.ArraySfixed32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArraySfixed32)
			LOOP_LIST_array_sfixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sfixed32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArraySfixed32[i] = x
					} else {
						this.ArraySfixed32 = append(this.ArraySfixed32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sfixed32
					}
				}
				if i < length {
					this.ArraySfixed32 = this.ArraySfixed32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sfixed64":
			// decode filed type of list; | field: gojsontest.Model2.array_sfixed64 | kind: Sfixed64Kind | GoName: ArraySfixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArraySfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArraySfixed64 == nil {
					this.ArraySfixed64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArraySfixed64)
			LOOP_LIST_array_sfixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sfixed64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArraySfixed64[i] = x
					} else {
						this.ArraySfixed64 = append(this.ArraySfixed64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sfixed64
					}
				}
				if i < length {
					this.ArraySfixed64 = this.ArraySfixed64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bool":
			// decode filed type of list; | field: gojsontest.Model2.array_bool | kind: BoolKind | GoName: ArrayBool
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), objKey)
				} else {
					this.ArrayBool = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), objKey)
				}
				if this.ArrayBool == nil {
					this.ArrayBool = make([]bool, 0)
				}
				i := 0
				length := len(this.ArrayBool)
			LOOP_LIST_array_bool:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bool
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseBool(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []bool", string(value), objKey)
					}
					if i < length {
						this.ArrayBool[i] = x
					} else {
						this.ArrayBool = append(this.ArrayBool, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bool
					}
				}
				if i < length {
					this.ArrayBool = this.ArrayBool[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_string":
			// decode filed type of list; | field: gojsontest.Model2.array_string | kind: StringKind | GoName: ArrayString
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString == nil {
					this.ArrayString = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString)
			LOOP_LIST_array_string:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_string
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString[i] = x
					} else {
						this.ArrayString = append(this.ArrayString, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_string
					}
				}
				if i < length {
					this.ArrayString = this.ArrayString[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bytes":
			// decode filed type of list; | field: gojsontest.Model2.array_bytes | kind: BytesKind | GoName: ArrayBytes
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes == nil {
					this.ArrayBytes = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes)
			LOOP_LIST_array_bytes:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bytes
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes[i] = x
					} else {
						this.ArrayBytes = append(this.ArrayBytes, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bytes
					}
				}
				if i < length {
					this.ArrayBytes = this.ArrayBytes[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_embed_message":
			// decode filed type of list; | field: gojsontest.Model2.array_embed_message | kind: MessageKind | GoName: ArrayEmbedMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Model2_EmbedMessage1", string(value), objKey)
				} else {
					this.ArrayEmbedMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Model2_EmbedMessage1", string(value), objKey)
				}
				if this.ArrayEmbedMessage == nil {
					this.ArrayEmbedMessage = make([]*Model2_EmbedMessage1, 0)
				}
				i := 0
				length := len(this.ArrayEmbedMessage)
			LOOP_LIST_array_embed_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_embed_message
					}
					value := decoder.ReadItem()
					var x *Model2_EmbedMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayEmbedMessage[i]
						}
						if x == nil {
							x = new(Model2_EmbedMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayEmbedMessage[i] = x
					} else {
						this.ArrayEmbedMessage = append(this.ArrayEmbedMessage, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_embed_message
					}
				}
				if i < length {
					this.ArrayEmbedMessage = this.ArrayEmbedMessage[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_stand_message":
			// decode filed type of list; | field: gojsontest.Model2.array_stand_message | kind: MessageKind | GoName: ArrayStandMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*StandMessage1", string(value), objKey)
				} else {
					this.ArrayStandMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*StandMessage1", string(value), objKey)
				}
				if this.ArrayStandMessage == nil {
					this.ArrayStandMessage = make([]*StandMessage1, 0)
				}
				i := 0
				length := len(this.ArrayStandMessage)
			LOOP_LIST_array_stand_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_stand_message
					}
					value := decoder.ReadItem()
					var x *StandMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayStandMessage[i]
						}
						if x == nil {
							x = new(StandMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayStandMessage[i] = x
					} else {
						this.ArrayStandMessage = append(this.ArrayStandMessage, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_stand_message
					}
				}
				if i < length {
					this.ArrayStandMessage = this.ArrayStandMessage[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_external_message":
			// decode filed type of list; | field: gojsontest.Model2.array_external_message | kind: MessageKind | GoName: ArrayExternalMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.ArrayExternalMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.ArrayExternalMessage == nil {
					this.ArrayExternalMessage = make([]*gojsonexternal.ExternalMessage1, 0)
				}
				i := 0
				length := len(this.ArrayExternalMessage)
			LOOP_LIST_array_external_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_external_message
					}
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayExternalMessage[i]
						}
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayExternalMessage[i] = x
					} else {
						this.ArrayExternalMessage = append(this.ArrayExternalMessage, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_external_message
					}
				}
				if i < length {
					this.ArrayExternalMessage = this.ArrayExternalMessage[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_embed_enum":
			// decode filed type of list; | field: gojsontest.Model2.array_embed_enum | kind: EnumKind | GoName: ArrayEmbedEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Model2_EmbedEnum1", string(value), objKey)
				} else {
					this.ArrayEmbedEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Model2_EmbedEnum1", string(value), objKey)
				}
				if this.ArrayEmbedEnum == nil {
					this.ArrayEmbedEnum = make([]Model2_EmbedEnum1, 0)
				}
				i := 0
				length := len(this.ArrayEmbedEnum)
			LOOP_LIST_array_embed_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_embed_enum
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []Model2_EmbedEnum1", string(value), objKey)
					}
					_, ok := Model2_EmbedEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := Model2_EmbedEnum1(x1)
					if i < length {
						this.ArrayEmbedEnum[i] = x
					} else {
						this.ArrayEmbedEnum = append(this.ArrayEmbedEnum, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_embed_enum
					}
				}
				if i < length {
					this.ArrayEmbedEnum = this.ArrayEmbedEnum[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_stand_enum":
			// decode filed type of list; | field: gojsontest.Model2.array_stand_enum | kind: EnumKind | GoName: ArrayStandEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []StandEnum1", string(value), objKey)
				} else {
					this.ArrayStandEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []StandEnum1", string(value), objKey)
				}
				if this.ArrayStandEnum == nil {
					this.ArrayStandEnum = make([]StandEnum1, 0)
				}
				i := 0
				length := len(this.ArrayStandEnum)
			LOOP_LIST_array_stand_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_stand_enum
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []StandEnum1", string(value), objKey)
					}
					_, ok := StandEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := StandEnum1(x1)
					if i < length {
						this.ArrayStandEnum[i] = x
					} else {
						this.ArrayStandEnum = append(this.ArrayStandEnum, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_stand_enum
					}
				}
				if i < length {
					this.ArrayStandEnum = this.ArrayStandEnum[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_external_enum":
			// decode filed type of list; | field: gojsontest.Model2.array_external_enum | kind: EnumKind | GoName: ArrayExternalEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.ArrayExternalEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.ArrayExternalEnum == nil {
					this.ArrayExternalEnum = make([]gojsonexternal.ExternalEnum1, 0)
				}
				i := 0
				length := len(this.ArrayExternalEnum)
			LOOP_LIST_array_external_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_external_enum
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					if i < length {
						this.ArrayExternalEnum[i] = x
					} else {
						this.ArrayExternalEnum = append(this.ArrayExternalEnum, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_external_enum
					}
				}
				if i < length {
					this.ArrayExternalEnum = this.ArrayExternalEnum[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_double":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_double | keyKind: Int32Kind | valueKind: DoubleKind | goName: MapInt32Double
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float64", string(value), objKey)
				} else {
					this.MapInt32Double = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float64", string(value), objKey)
				}
				if this.MapInt32Double == nil { // create map if not initialized.
					this.MapInt32Double = make(map[int32]float64)
				}
			LOOP_MAP_map_int32_double:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_double
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]float64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]float64", string(value), objKey)
					}
					this.MapInt32Double[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_double
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_float":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_float | keyKind: Int32Kind | valueKind: FloatKind | goName: MapInt32Float
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float32", string(value), objKey)
				} else {
					this.MapInt32Float = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float32", string(value), objKey)
				}
				if this.MapInt32Float == nil { // create map if not initialized.
					this.MapInt32Float = make(map[int32]float32)
				}
			LOOP_MAP_map_int32_float:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_float
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]float32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]float32", string(value), objKey)
					}
					this.MapInt32Float[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_float
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_int32 | keyKind: Int32Kind | valueKind: Int32Kind | goName: MapInt32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Int32 == nil { // create map if not initialized.
					this.MapInt32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_map_int32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_int64":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_int64 | keyKind: Int32Kind | valueKind: Int64Kind | goName: MapInt32Int64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Int64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Int64 == nil { // create map if not initialized.
					this.MapInt32Int64 = make(map[int32]int64)
				}
			LOOP_MAP_map_int32_int64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_int64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Int64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_int64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_uint32":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_uint32 | keyKind: Int32Kind | valueKind: Uint32Kind | goName: MapInt32Uint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				} else {
					this.MapInt32Uint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				}
				if this.MapInt32Uint32 == nil { // create map if not initialized.
					this.MapInt32Uint32 = make(map[int32]uint32)
				}
			LOOP_MAP_map_int32_uint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_uint32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint32", string(value), objKey)
					}
					this.MapInt32Uint32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_uint32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_uint64":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_uint64 | keyKind: Int32Kind | valueKind: Uint64Kind | goName: MapInt32Uint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				} else {
					this.MapInt32Uint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				}
				if this.MapInt32Uint64 == nil { // create map if not initialized.
					this.MapInt32Uint64 = make(map[int32]uint64)
				}
			LOOP_MAP_map_int32_uint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_uint64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint64", string(value), objKey)
					}
					this.MapInt32Uint64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_uint64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sint32":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_sint32 | keyKind: Int32Kind | valueKind: Sint32Kind | goName: MapInt32Sint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Sint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Sint32 == nil { // create map if not initialized.
					this.MapInt32Sint32 = make(map[int32]int32)
				}
			LOOP_MAP_map_int32_sint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sint32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Sint32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sint32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sint64":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_sint64 | keyKind: Int32Kind | valueKind: Sint64Kind | goName: MapInt32Sint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Sint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Sint64 == nil { // create map if not initialized.
					this.MapInt32Sint64 = make(map[int32]int64)
				}
			LOOP_MAP_map_int32_sint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sint64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Sint64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sint64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_fixed32":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_fixed32 | keyKind: Int32Kind | valueKind: Fixed32Kind | goName: MapInt32Fixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				} else {
					this.MapInt32Fixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				}
				if this.MapInt32Fixed32 == nil { // create map if not initialized.
					this.MapInt32Fixed32 = make(map[int32]uint32)
				}
			LOOP_MAP_map_int32_fixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_fixed32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint32", string(value), objKey)
					}
					this.MapInt32Fixed32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_fixed32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_fixed64":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_fixed64 | keyKind: Int32Kind | valueKind: Fixed64Kind | goName: MapInt32Fixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				} else {
					this.MapInt32Fixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				}
				if this.MapInt32Fixed64 == nil { // create map if not initialized.
					this.MapInt32Fixed64 = make(map[int32]uint64)
				}
			LOOP_MAP_map_int32_fixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_fixed64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint64", string(value), objKey)
					}
					this.MapInt32Fixed64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_fixed64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sfixed32":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_sfixed32 | keyKind: Int32Kind | valueKind: Sfixed32Kind | goName: MapInt32Sfixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Sfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Sfixed32 == nil { // create map if not initialized.
					this.MapInt32Sfixed32 = make(map[int32]int32)
				}
			LOOP_MAP_map_int32_sfixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sfixed32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Sfixed32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sfixed32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sfixed64":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_sfixed64 | keyKind: Int32Kind | valueKind: Sfixed64Kind | goName: MapInt32Sfixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Sfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Sfixed64 == nil { // create map if not initialized.
					this.MapInt32Sfixed64 = make(map[int32]int64)
				}
			LOOP_MAP_map_int32_sfixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sfixed64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Sfixed64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sfixed64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_bool":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_bool | keyKind: Int32Kind | valueKind: BoolKind | goName: MapInt32Bool
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]bool", string(value), objKey)
				} else {
					this.MapInt32Bool = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]bool", string(value), objKey)
				}
				if this.MapInt32Bool == nil { // create map if not initialized.
					this.MapInt32Bool = make(map[int32]bool)
				}
			LOOP_MAP_map_int32_bool:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_bool
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]bool", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseBool(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]bool", string(value), objKey)
					}
					this.MapInt32Bool[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_bool
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_string":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_string | keyKind: Int32Kind | valueKind: StringKind | goName: MapInt32String
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]string", string(value), objKey)
				} else {
					this.MapInt32String = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]string", string(value), objKey)
				}
				if this.MapInt32String == nil { // create map if not initialized.
					this.MapInt32String = make(map[int32]string)
				}
			LOOP_MAP_map_int32_string:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_string
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]string", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]string", string(value), objKey)
						}
					}
					this.MapInt32String[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_string
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_bytes":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_bytes | keyKind: Int32Kind | valueKind: BytesKind | goName: MapInt32Bytes
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32][]byte", string(value), objKey)
				} else {
					this.MapInt32Bytes = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32][]byte", string(value), objKey)
				}
				if this.MapInt32Bytes == nil { // create map if not initialized.
					this.MapInt32Bytes = make(map[int32][]byte)
				}
			LOOP_MAP_map_int32_bytes:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_bytes
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32][]byte", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapInt32Bytes[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_bytes
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_embed_message":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_embed_message | keyKind: Int32Kind | valueKind: MessageKind | goName: MapInt32EmbedMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*Model2_EmbedMessage1", string(value), objKey)
				} else {
					this.MapInt32EmbedMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*Model2_EmbedMessage1", string(value), objKey)
				}
				if this.MapInt32EmbedMessage == nil { // create map if not initialized.
					this.MapInt32EmbedMessage = make(map[int32]*Model2_EmbedMessage1)
				}
			LOOP_MAP_map_int32_embed_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_embed_message
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]*Model2_EmbedMessage1", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *Model2_EmbedMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapInt32EmbedMessage[mapKey]
						if x == nil {
							x = new(Model2_EmbedMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapInt32EmbedMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_embed_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_stand_message":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_stand_message | keyKind: Int32Kind | valueKind: MessageKind | goName: MapInt32StandMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*StandMessage1", string(value), objKey)
				} else {
					this.MapInt32StandMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*StandMessage1", string(value), objKey)
				}
				if this.MapInt32StandMessage == nil { // create map if not initialized.
					this.MapInt32StandMessage = make(map[int32]*StandMessage1)
				}
			LOOP_MAP_map_int32_stand_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_stand_message
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]*StandMessage1", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *StandMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapInt32StandMessage[mapKey]
						if x == nil {
							x = new(StandMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapInt32StandMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_stand_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_embed_enum":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_embed_enum | keyKind: Int32Kind | valueKind: EnumKind | goName: MapInt32EmbedEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]Model2_EmbedEnum1", string(value), objKey)
				} else {
					this.MapInt32EmbedEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]Model2_EmbedEnum1", string(value), objKey)
				}
				if this.MapInt32EmbedEnum == nil { // create map if not initialized.
					this.MapInt32EmbedEnum = make(map[int32]Model2_EmbedEnum1)
				}
			LOOP_MAP_map_int32_embed_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_embed_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]Model2_EmbedEnum1", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]Model2_EmbedEnum1", string(value), objKey)
					}
					_, ok := Model2_EmbedEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := Model2_EmbedEnum1(x1)
					this.MapInt32EmbedEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_embed_enum
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_stand_enum":
			// decode filed type of map; | field: gojsontest.Model2.map_int32_stand_enum | keyKind: Int32Kind | valueKind: EnumKind | goName: MapInt32StandEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]StandEnum1", string(value), objKey)
				} else {
					this.MapInt32StandEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]StandEnum1", string(value), objKey)
				}
				if this.MapInt32StandEnum == nil { // create map if not initialized.
					this.MapInt32StandEnum = make(map[int32]StandEnum1)
				}
			LOOP_MAP_map_int32_stand_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_stand_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]StandEnum1", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]StandEnum1", string(value), objKey)
					}
					_, ok := StandEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := StandEnum1(x1)
					this.MapInt32StandEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_stand_enum
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int64_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_int64_int32 | keyKind: Int64Kind | valueKind: Int32Kind | goName: MapInt64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapInt64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapInt64Int32 == nil { // create map if not initialized.
					this.MapInt64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_map_int64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapInt64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_uint32_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_uint32_int32 | keyKind: Uint32Kind | valueKind: Int32Kind | goName: MapUint32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				} else {
					this.MapUint32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				}
				if this.MapUint32Int32 == nil { // create map if not initialized.
					this.MapUint32Int32 = make(map[uint32]int32)
				}
			LOOP_MAP_map_uint32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_uint32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseUint(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint32]int32", key, objKey)
					}
					mapKey := uint32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint32]int32", string(value), objKey)
					}
					this.MapUint32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_uint32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_uint64_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_uint64_int32 | keyKind: Uint64Kind | valueKind: Int32Kind | goName: MapUint64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				} else {
					this.MapUint64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				}
				if this.MapUint64Int32 == nil { // create map if not initialized.
					this.MapUint64Int32 = make(map[uint64]int32)
				}
			LOOP_MAP_map_uint64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_uint64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseUint(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint64]int32", string(value), objKey)
					}
					this.MapUint64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_uint64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sint32_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_sint32_int32 | keyKind: Sint32Kind | valueKind: Int32Kind | goName: MapSint32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapSint32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapSint32Int32 == nil { // create map if not initialized.
					this.MapSint32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_map_sint32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sint32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapSint32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sint32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sint64_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_sint64_int32 | keyKind: Sint64Kind | valueKind: Int32Kind | goName: MapSint64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapSint64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapSint64Int32 == nil { // create map if not initialized.
					this.MapSint64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_map_sint64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sint64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapSint64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sint64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_fixed32_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_fixed32_int32 | keyKind: Fixed32Kind | valueKind: Int32Kind | goName: MapFixed32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				} else {
					this.MapFixed32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				}
				if this.MapFixed32Int32 == nil { // create map if not initialized.
					this.MapFixed32Int32 = make(map[uint32]int32)
				}
			LOOP_MAP_map_fixed32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_fixed32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseUint(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint32]int32", key, objKey)
					}
					mapKey := uint32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint32]int32", string(value), objKey)
					}
					this.MapFixed32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_fixed32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_fixed64_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_fixed64_int32 | keyKind: Fixed64Kind | valueKind: Int32Kind | goName: MapFixed64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				} else {
					this.MapFixed64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				}
				if this.MapFixed64Int32 == nil { // create map if not initialized.
					this.MapFixed64Int32 = make(map[uint64]int32)
				}
			LOOP_MAP_map_fixed64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_fixed64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseUint(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint64]int32", string(value), objKey)
					}
					this.MapFixed64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_fixed64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sfixed32_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_sfixed32_int32 | keyKind: Sfixed32Kind | valueKind: Int32Kind | goName: MapSfixed32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapSfixed32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapSfixed32Int32 == nil { // create map if not initialized.
					this.MapSfixed32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_map_sfixed32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sfixed32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapSfixed32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sfixed32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sfixed64_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_sfixed64_int32 | keyKind: Sfixed64Kind | valueKind: Int32Kind | goName: MapSfixed64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapSfixed64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapSfixed64Int32 == nil { // create map if not initialized.
					this.MapSfixed64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_map_sfixed64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sfixed64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapSfixed64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sfixed64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_int32":
			// decode filed type of map; | field: gojsontest.Model2.map_string_int32 | keyKind: StringKind | valueKind: Int32Kind | goName: MapStringInt32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				} else {
					this.MapStringInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				}
				if this.MapStringInt32 == nil { // create map if not initialized.
					this.MapStringInt32 = make(map[string]int32)
				}
			LOOP_MAP_map_string_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]int32", string(value), objKey)
					}
					this.MapStringInt32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_string":
			// decode filed type of map; | field: gojsontest.Model2.map_string_string | keyKind: StringKind | valueKind: StringKind | goName: MapStringString
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				} else {
					this.MapStringString = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				}
				if this.MapStringString == nil { // create map if not initialized.
					this.MapStringString = make(map[string]string)
				}
			LOOP_MAP_map_string_string:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_string
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]string", string(value), objKey)
						}
					}
					this.MapStringString[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_string
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_embed_message":
			// decode filed type of map; | field: gojsontest.Model2.map_string_embed_message | keyKind: StringKind | valueKind: MessageKind | goName: MapStringEmbedMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Model2_EmbedMessage1", string(value), objKey)
				} else {
					this.MapStringEmbedMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Model2_EmbedMessage1", string(value), objKey)
				}
				if this.MapStringEmbedMessage == nil { // create map if not initialized.
					this.MapStringEmbedMessage = make(map[string]*Model2_EmbedMessage1)
				}
			LOOP_MAP_map_string_embed_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_embed_message
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *Model2_EmbedMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapStringEmbedMessage[mapKey]
						if x == nil {
							x = new(Model2_EmbedMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapStringEmbedMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_embed_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_stand_message":
			// decode filed type of map; | field: gojsontest.Model2.map_string_stand_message | keyKind: StringKind | valueKind: MessageKind | goName: MapStringStandMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*StandMessage1", string(value), objKey)
				} else {
					this.MapStringStandMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*StandMessage1", string(value), objKey)
				}
				if this.MapStringStandMessage == nil { // create map if not initialized.
					this.MapStringStandMessage = make(map[string]*StandMessage1)
				}
			LOOP_MAP_map_string_stand_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_stand_message
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *StandMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapStringStandMessage[mapKey]
						if x == nil {
							x = new(StandMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapStringStandMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_stand_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_external_message":
			// decode filed type of map; | field: gojsontest.Model2.map_string_external_message | keyKind: StringKind | valueKind: MessageKind | goName: MapStringExternalMessage
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.MapStringExternalMessage = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.MapStringExternalMessage == nil { // create map if not initialized.
					this.MapStringExternalMessage = make(map[string]*gojsonexternal.ExternalMessage1)
				}
			LOOP_MAP_map_string_external_message:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_external_message
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapStringExternalMessage[mapKey]
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapStringExternalMessage[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_external_message
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_embed_enum":
			// decode filed type of map; | field: gojsontest.Model2.map_string_embed_enum | keyKind: StringKind | valueKind: EnumKind | goName: MapStringEmbedEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Model2_EmbedEnum1", string(value), objKey)
				} else {
					this.MapStringEmbedEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Model2_EmbedEnum1", string(value), objKey)
				}
				if this.MapStringEmbedEnum == nil { // create map if not initialized.
					this.MapStringEmbedEnum = make(map[string]Model2_EmbedEnum1)
				}
			LOOP_MAP_map_string_embed_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_embed_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]Model2_EmbedEnum1", string(value), objKey)
					}
					_, ok := Model2_EmbedEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := Model2_EmbedEnum1(x1)
					this.MapStringEmbedEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_embed_enum
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_stand_enum":
			// decode filed type of map; | field: gojsontest.Model2.map_string_stand_enum | keyKind: StringKind | valueKind: EnumKind | goName: MapStringStandEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]StandEnum1", string(value), objKey)
				} else {
					this.MapStringStandEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]StandEnum1", string(value), objKey)
				}
				if this.MapStringStandEnum == nil { // create map if not initialized.
					this.MapStringStandEnum = make(map[string]StandEnum1)
				}
			LOOP_MAP_map_string_stand_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_stand_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]StandEnum1", string(value), objKey)
					}
					_, ok := StandEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := StandEnum1(x1)
					this.MapStringStandEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_stand_enum
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_external_enum":
			// decode filed type of map; | field: gojsontest.Model2.map_string_external_enum | keyKind: StringKind | valueKind: EnumKind | goName: MapStringExternalEnum
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.MapStringExternalEnum = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.MapStringExternalEnum == nil { // create map if not initialized.
					this.MapStringExternalEnum = make(map[string]gojsonexternal.ExternalEnum1)
				}
			LOOP_MAP_map_string_external_enum:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_external_enum
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					this.MapStringExternalEnum[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_external_enum
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *Model2_EmbedMessage1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(38)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.Model2.EmbedMessage1.age1 | kind: StringKind | GoName: Age1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("age1")
	encoder.AppendString(this.Age1)
	// encode filed type of basic; | field: gojsontest.Model2.EmbedMessage1.age2 | kind: StringKind | GoName: Age2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("age2")
	encoder.AppendString(this.Age2)
	// encode filed type of basic; | field: gojsontest.Model2.EmbedMessage1.age3 | kind: StringKind | GoName: Age3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("age3")
	encoder.AppendString(this.Age3)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *Model2_EmbedMessage1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*Model2_EmbedMessage1) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "age1":
			// decode filed type of basic; | field: gojsontest.Model2.EmbedMessage1.age1 | kind: StringKind | GoName: Age1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Age1 = x
		case objKey == "age2":
			// decode filed type of basic; | field: gojsontest.Model2.EmbedMessage1.age2 | kind: StringKind | GoName: Age2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Age2 = x
		case objKey == "age3":
			// decode filed type of basic; | field: gojsontest.Model2.EmbedMessage1.age3 | kind: StringKind | GoName: Age3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Age3 = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *Model3) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(486)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.Model3.t_string1 | kind: StringKind | GoName: TString1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string1")
	encoder.AppendString(this.TString1)
	// encode filed type of basic; | field: gojsontest.Model3.t_string2 | kind: StringKind | GoName: TString2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string2")
	encoder.AppendString(this.TString2)
	// encode filed type of basic; | field: gojsontest.Model3.t_string3 | kind: StringKind | GoName: TString3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string3")
	encoder.AppendString(this.TString3)
	// encode filed type of basic; | field: gojsontest.Model3.t_string4 | kind: StringKind | GoName: TString4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string4")
	encoder.AppendString(this.TString4)
	// encode filed type of basic; | field: gojsontest.Model3.t_string5 | kind: StringKind | GoName: TString5 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string5")
	encoder.AppendString(this.TString5)
	// encode filed type of basic; | field: gojsontest.Model3.t_string6 | kind: StringKind | GoName: TString6 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string6")
	encoder.AppendString(this.TString6)
	// encode filed type of basic; | field: gojsontest.Model3.t_string7 | kind: StringKind | GoName: TString7 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string7")
	encoder.AppendString(this.TString7)
	// encode filed type of basic; | field: gojsontest.Model3.t_string8 | kind: StringKind | GoName: TString8 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string8")
	encoder.AppendString(this.TString8)
	// encode filed type of basic; | field: gojsontest.Model3.t_string9 | kind: StringKind | GoName: TString9 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string9")
	encoder.AppendString(this.TString9)
	// encode filed type of basic; | field: gojsontest.Model3.t_string10 | kind: StringKind | GoName: TString10 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string10")
	encoder.AppendString(this.TString10)
	// encode filed type of basic; | field: gojsontest.Model3.t_int32 | kind: Int32Kind | GoName: TInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_int32")
	encoder.AppendInt32(this.TInt32)
	// encode filed type of basic; | field: gojsontest.Model3.t_int64 | kind: Int64Kind | GoName: TInt64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_int64")
	encoder.AppendInt64(this.TInt64)
	// encode filed type of basic; | field: gojsontest.Model3.t_uint32 | kind: Uint32Kind | GoName: TUint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_uint32")
	encoder.AppendUint32(this.TUint32)
	// encode filed type of basic; | field: gojsontest.Model3.t_uint64 | kind: Uint64Kind | GoName: TUint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_uint64")
	encoder.AppendUint64(this.TUint64)
	// encode filed type of basic; | field: gojsontest.Model3.t_sint32 | kind: Sint32Kind | GoName: TSint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sint32")
	encoder.AppendInt32(this.TSint32)
	// encode filed type of basic; | field: gojsontest.Model3.t_sint64 | kind: Sint64Kind | GoName: TSint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sint64")
	encoder.AppendInt64(this.TSint64)
	// encode filed type of basic; | field: gojsontest.Model3.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sfixed32")
	encoder.AppendInt32(this.TSfixed32)
	// encode filed type of basic; | field: gojsontest.Model3.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sfixed64")
	encoder.AppendInt64(this.TSfixed64)
	// encode filed type of basic; | field: gojsontest.Model3.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_fixed32")
	encoder.AppendUint32(this.TFixed32)
	// encode filed type of basic; | field: gojsontest.Model3.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_fixed64")
	encoder.AppendUint64(this.TFixed64)
	// encode filed type of basic; | field: gojsontest.Model3.t_float | kind: FloatKind | GoName: TFloat | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_float")
	encoder.AppendFloat32(this.TFloat)
	// encode filed type of basic; | field: gojsontest.Model3.t_double | kind: DoubleKind | GoName: TDouble | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_double")
	encoder.AppendFloat64(this.TDouble)
	// encode filed type of basic; | field: gojsontest.Model3.t_bool | kind: BoolKind | GoName: TBool | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_bool")
	encoder.AppendBool(this.TBool)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *Model3) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*Model3) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_string1":
			// decode filed type of basic; | field: gojsontest.Model3.t_string1 | kind: StringKind | GoName: TString1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString1 = x
		case objKey == "t_string2":
			// decode filed type of basic; | field: gojsontest.Model3.t_string2 | kind: StringKind | GoName: TString2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString2 = x
		case objKey == "t_string3":
			// decode filed type of basic; | field: gojsontest.Model3.t_string3 | kind: StringKind | GoName: TString3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString3 = x
		case objKey == "t_string4":
			// decode filed type of basic; | field: gojsontest.Model3.t_string4 | kind: StringKind | GoName: TString4
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString4 = x
		case objKey == "t_string5":
			// decode filed type of basic; | field: gojsontest.Model3.t_string5 | kind: StringKind | GoName: TString5
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString5 = x
		case objKey == "t_string6":
			// decode filed type of basic; | field: gojsontest.Model3.t_string6 | kind: StringKind | GoName: TString6
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString6 = x
		case objKey == "t_string7":
			// decode filed type of basic; | field: gojsontest.Model3.t_string7 | kind: StringKind | GoName: TString7
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString7 = x
		case objKey == "t_string8":
			// decode filed type of basic; | field: gojsontest.Model3.t_string8 | kind: StringKind | GoName: TString8
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString8 = x
		case objKey == "t_string9":
			// decode filed type of basic; | field: gojsontest.Model3.t_string9 | kind: StringKind | GoName: TString9
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString9 = x
		case objKey == "t_string10":
			// decode filed type of basic; | field: gojsontest.Model3.t_string10 | kind: StringKind | GoName: TString10
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString10 = x
		case objKey == "t_int32":
			// decode filed type of basic; | field: gojsontest.Model3.t_int32 | kind: Int32Kind | GoName: TInt32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TInt32 = x
		case objKey == "t_int64":
			// decode filed type of basic; | field: gojsontest.Model3.t_int64 | kind: Int64Kind | GoName: TInt64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TInt64 = x
		case objKey == "t_uint32":
			// decode filed type of basic; | field: gojsontest.Model3.t_uint32 | kind: Uint32Kind | GoName: TUint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TUint32 = x
		case objKey == "t_uint64":
			// decode filed type of basic; | field: gojsontest.Model3.t_uint64 | kind: Uint64Kind | GoName: TUint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TUint64 = x
		case objKey == "t_sint32":
			// decode filed type of basic; | field: gojsontest.Model3.t_sint32 | kind: Sint32Kind | GoName: TSint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSint32 = x
		case objKey == "t_sint64":
			// decode filed type of basic; | field: gojsontest.Model3.t_sint64 | kind: Sint64Kind | GoName: TSint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSint64 = x
		case objKey == "t_sfixed32":
			// decode filed type of basic; | field: gojsontest.Model3.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSfixed32 = x
		case objKey == "t_sfixed64":
			// decode filed type of basic; | field: gojsontest.Model3.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSfixed64 = x
		case objKey == "t_fixed32":
			// decode filed type of basic; | field: gojsontest.Model3.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TFixed32 = x
		case objKey == "t_fixed64":
			// decode filed type of basic; | field: gojsontest.Model3.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TFixed64 = x
		case objKey == "t_float":
			// decode filed type of basic; | field: gojsontest.Model3.t_float | kind: FloatKind | GoName: TFloat
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
			}
			this.TFloat = x
		case objKey == "t_double":
			// decode filed type of basic; | field: gojsontest.Model3.t_double | kind: DoubleKind | GoName: TDouble
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TDouble = x
		case objKey == "t_bool":
			// decode filed type of basic; | field: gojsontest.Model3.t_bool | kind: BoolKind | GoName: TBool
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			this.TBool = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *NameStyleTextName) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(388)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.NameStyleTextName.name_style1 | kind: Int32Kind | GoName: NameStyle1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("name_style1")
	encoder.AppendInt32(this.NameStyle1)
	// encode filed type of basic; | field: gojsontest.NameStyleTextName.names_Style2 | kind: Int32Kind | GoName: Names_Style2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("names_Style2")
	encoder.AppendInt32(this.Names_Style2)
	// encode filed type of basic; | field: gojsontest.NameStyleTextName.Name_Style3 | kind: Int32Kind | GoName: Name_Style3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Name_Style3")
	encoder.AppendInt32(this.Name_Style3)
	// encode filed type of basic; | field: gojsontest.NameStyleTextName.Name_style4 | kind: Int32Kind | GoName: NameStyle4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Name_style4")
	encoder.AppendInt32(this.NameStyle4)
	// encode filed type of basic; | field: gojsontest.NameStyleTextName.namestyle5 | kind: Int32Kind | GoName: Namestyle5 | omitempty: false | ignore: false
	encoder.AppendObjectKey("namestyle5")
	encoder.AppendInt32(this.Namestyle5)
	// encode filed type of basic; | field: gojsontest.NameStyleTextName.nameStyle6 | kind: Int32Kind | GoName: NameStyle6 | omitempty: false | ignore: false
	encoder.AppendObjectKey("nameStyle6")
	encoder.AppendInt32(this.NameStyle6)
	// encode filed type of basic; | field: gojsontest.NameStyleTextName.NameStyle7 | kind: Int32Kind | GoName: NameStyle7 | omitempty: false | ignore: false
	encoder.AppendObjectKey("NameStyle7")
	encoder.AppendInt32(this.NameStyle7)
	// encode filed type of basic; | field: gojsontest.NameStyleTextName.Namestyle8 | kind: Int32Kind | GoName: Namestyle8 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Namestyle8")
	encoder.AppendInt32(this.Namestyle8)
	// Encode field type of oneof; | field: gojsontest.NameStyleTextName.data_type1 | GoName: DataType1 | omitempty: false | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *NameStyleTextName_Integer1:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.integer1 | kind: StringKind | GoName: Integer1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer1")
			encoder.AppendString(v.Integer1)
			encoder.AppendObjectEnd()
		case *NameStyleTextName_Float1:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.float1 | kind: StringKind | GoName: Float1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float1")
			encoder.AppendString(v.Float1)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type1, goName: DataType1, field: gojsontest.NameStyleTextName.data_type1", v)
		}
	} else {
		encoder.AppendObjectKey("data_type1")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleTextName.data_Type2 | GoName: Data_Type2 | omitempty: false | ignore: false
	if this.Data_Type2 != nil {
		switch v := this.Data_Type2.(type) {
		case *NameStyleTextName_Integer2:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.integer2 | kind: StringKind | GoName: Integer2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_Type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer2")
			encoder.AppendString(v.Integer2)
			encoder.AppendObjectEnd()
		case *NameStyleTextName_Float2:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.float2 | kind: StringKind | GoName: Float2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_Type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float2")
			encoder.AppendString(v.Float2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_Type2, goName: Data_Type2, field: gojsontest.NameStyleTextName.data_Type2", v)
		}
	} else {
		encoder.AppendObjectKey("data_Type2")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleTextName.Data_Type3 | GoName: Data_Type3 | omitempty: false | ignore: false
	if this.Data_Type3 != nil {
		switch v := this.Data_Type3.(type) {
		case *NameStyleTextName_Integer3:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.integer3 | kind: StringKind | GoName: Integer3 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_Type3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer3")
			encoder.AppendString(v.Integer3)
			encoder.AppendObjectEnd()
		case *NameStyleTextName_Float3:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.float3 | kind: StringKind | GoName: Float3 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_Type3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float3")
			encoder.AppendString(v.Float3)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Data_Type3, goName: Data_Type3, field: gojsontest.NameStyleTextName.Data_Type3", v)
		}
	} else {
		encoder.AppendObjectKey("Data_Type3")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleTextName.Data_type4 | GoName: DataType4 | omitempty: false | ignore: false
	if this.DataType4 != nil {
		switch v := this.DataType4.(type) {
		case *NameStyleTextName_Integer4:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.integer4 | kind: StringKind | GoName: Integer4 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer4")
			encoder.AppendString(v.Integer4)
			encoder.AppendObjectEnd()
		case *NameStyleTextName_Float4:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.float4 | kind: StringKind | GoName: Float4 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float4")
			encoder.AppendString(v.Float4)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Data_type4, goName: DataType4, field: gojsontest.NameStyleTextName.Data_type4", v)
		}
	} else {
		encoder.AppendObjectKey("Data_type4")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleTextName.datatype5 | GoName: Datatype5 | omitempty: false | ignore: false
	if this.Datatype5 != nil {
		switch v := this.Datatype5.(type) {
		case *NameStyleTextName_Integer5:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.integer5 | kind: StringKind | GoName: Integer5 | omitempty: false | ignore: false
			encoder.AppendObjectKey("datatype5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer5")
			encoder.AppendString(v.Integer5)
			encoder.AppendObjectEnd()
		case *NameStyleTextName_Float5:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.float5 | kind: StringKind | GoName: Float5 | omitempty: false | ignore: false
			encoder.AppendObjectKey("datatype5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float5")
			encoder.AppendString(v.Float5)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: datatype5, goName: Datatype5, field: gojsontest.NameStyleTextName.datatype5", v)
		}
	} else {
		encoder.AppendObjectKey("datatype5")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleTextName.dataType6 | GoName: DataType6 | omitempty: false | ignore: false
	if this.DataType6 != nil {
		switch v := this.DataType6.(type) {
		case *NameStyleTextName_Integer6:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.integer6 | kind: StringKind | GoName: Integer6 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dataType6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer6")
			encoder.AppendString(v.Integer6)
			encoder.AppendObjectEnd()
		case *NameStyleTextName_Float6:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.float6 | kind: StringKind | GoName: Float6 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dataType6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float6")
			encoder.AppendString(v.Float6)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dataType6, goName: DataType6, field: gojsontest.NameStyleTextName.dataType6", v)
		}
	} else {
		encoder.AppendObjectKey("dataType6")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleTextName.DataType7 | GoName: DataType7 | omitempty: false | ignore: false
	if this.DataType7 != nil {
		switch v := this.DataType7.(type) {
		case *NameStyleTextName_Integer7:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.integer7 | kind: StringKind | GoName: Integer7 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer7")
			encoder.AppendString(v.Integer7)
			encoder.AppendObjectEnd()
		case *NameStyleTextName_Float7:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.float7 | kind: StringKind | GoName: Float7 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float7")
			encoder.AppendString(v.Float7)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: DataType7, goName: DataType7, field: gojsontest.NameStyleTextName.DataType7", v)
		}
	} else {
		encoder.AppendObjectKey("DataType7")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleTextName.Datatype8 | GoName: Datatype8 | omitempty: false | ignore: false
	if this.Datatype8 != nil {
		switch v := this.Datatype8.(type) {
		case *NameStyleTextName_Integer8:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.integer8 | kind: StringKind | GoName: Integer8 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Datatype8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer8")
			encoder.AppendString(v.Integer8)
			encoder.AppendObjectEnd()
		case *NameStyleTextName_Float8:
			// encode filed type of basic; | field: gojsontest.NameStyleTextName.float8 | kind: StringKind | GoName: Float8 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Datatype8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float8")
			encoder.AppendString(v.Float8)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Datatype8, goName: Datatype8, field: gojsontest.NameStyleTextName.Datatype8", v)
		}
	} else {
		encoder.AppendObjectKey("Datatype8")
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *NameStyleTextName) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*NameStyleTextName) is nil")
	}
	var oneofDataType1isStore bool
	var oneofData_Type2isStore bool
	var oneofData_Type3isStore bool
	var oneofDataType4isStore bool
	var oneofDatatype5isStore bool
	var oneofDataType6isStore bool
	var oneofDataType7isStore bool
	var oneofDatatype8isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "name_style1":
			// decode filed type of basic; | field: gojsontest.NameStyleTextName.name_style1 | kind: Int32Kind | GoName: NameStyle1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle1 = x
		case objKey == "names_Style2":
			// decode filed type of basic; | field: gojsontest.NameStyleTextName.names_Style2 | kind: Int32Kind | GoName: Names_Style2
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Names_Style2 = x
		case objKey == "Name_Style3":
			// decode filed type of basic; | field: gojsontest.NameStyleTextName.Name_Style3 | kind: Int32Kind | GoName: Name_Style3
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Name_Style3 = x
		case objKey == "Name_style4":
			// decode filed type of basic; | field: gojsontest.NameStyleTextName.Name_style4 | kind: Int32Kind | GoName: NameStyle4
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle4 = x
		case objKey == "namestyle5":
			// decode filed type of basic; | field: gojsontest.NameStyleTextName.namestyle5 | kind: Int32Kind | GoName: Namestyle5
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Namestyle5 = x
		case objKey == "nameStyle6":
			// decode filed type of basic; | field: gojsontest.NameStyleTextName.nameStyle6 | kind: Int32Kind | GoName: NameStyle6
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle6 = x
		case objKey == "NameStyle7":
			// decode filed type of basic; | field: gojsontest.NameStyleTextName.NameStyle7 | kind: Int32Kind | GoName: NameStyle7
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle7 = x
		case objKey == "Namestyle8":
			// decode filed type of basic; | field: gojsontest.NameStyleTextName.Namestyle8 | kind: Int32Kind | GoName: Namestyle8
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Namestyle8 = x
		case objKey == "data_type1":
			// decode filed type of oneof; | field: gojsontest.NameStyleTextName.data_type1 | GoName: DataType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_type1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(NameStyleTextName_Integer1)
						ot.Integer1 = x
						this.DataType1 = ot
					case oneofKey == "float1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(NameStyleTextName_Float1)
						ot.Float1 = x
						this.DataType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_Type2":
			// decode filed type of oneof; | field: gojsontest.NameStyleTextName.data_Type2 | GoName: Data_Type2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_Type2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_Type2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type2isStore = true
						ot := new(NameStyleTextName_Integer2)
						ot.Integer2 = x
						this.Data_Type2 = ot
					case oneofKey == "float2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type2isStore = true
						ot := new(NameStyleTextName_Float2)
						ot.Float2 = x
						this.Data_Type2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_Type2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Data_Type3":
			// decode filed type of oneof; | field: gojsontest.NameStyleTextName.Data_Type3 | GoName: Data_Type3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Data_Type3:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Data_Type3
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer3":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type3isStore = true
						ot := new(NameStyleTextName_Integer3)
						ot.Integer3 = x
						this.Data_Type3 = ot
					case oneofKey == "float3":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type3isStore = true
						ot := new(NameStyleTextName_Float3)
						ot.Float3 = x
						this.Data_Type3 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Data_Type3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Data_type4":
			// decode filed type of oneof; | field: gojsontest.NameStyleTextName.Data_type4 | GoName: DataType4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Data_type4:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Data_type4
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer4":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(NameStyleTextName_Integer4)
						ot.Integer4 = x
						this.DataType4 = ot
					case oneofKey == "float4":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(NameStyleTextName_Float4)
						ot.Float4 = x
						this.DataType4 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Data_type4
					}
				}
				decoder.ScanNext()
			}
		case objKey == "datatype5":
			// decode filed type of oneof; | field: gojsontest.NameStyleTextName.datatype5 | GoName: Datatype5
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_datatype5:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_datatype5
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer5":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype5isStore = true
						ot := new(NameStyleTextName_Integer5)
						ot.Integer5 = x
						this.Datatype5 = ot
					case oneofKey == "float5":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype5isStore = true
						ot := new(NameStyleTextName_Float5)
						ot.Float5 = x
						this.Datatype5 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_datatype5
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dataType6":
			// decode filed type of oneof; | field: gojsontest.NameStyleTextName.dataType6 | GoName: DataType6
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dataType6:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dataType6
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer6":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(NameStyleTextName_Integer6)
						ot.Integer6 = x
						this.DataType6 = ot
					case oneofKey == "float6":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(NameStyleTextName_Float6)
						ot.Float6 = x
						this.DataType6 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dataType6
					}
				}
				decoder.ScanNext()
			}
		case objKey == "DataType7":
			// decode filed type of oneof; | field: gojsontest.NameStyleTextName.DataType7 | GoName: DataType7
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_DataType7:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_DataType7
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer7":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(NameStyleTextName_Integer7)
						ot.Integer7 = x
						this.DataType7 = ot
					case oneofKey == "float7":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(NameStyleTextName_Float7)
						ot.Float7 = x
						this.DataType7 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_DataType7
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Datatype8":
			// decode filed type of oneof; | field: gojsontest.NameStyleTextName.Datatype8 | GoName: Datatype8
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Datatype8:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Datatype8
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer8":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype8isStore = true
						ot := new(NameStyleTextName_Integer8)
						ot.Integer8 = x
						this.Datatype8 = ot
					case oneofKey == "float8":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype8isStore = true
						ot := new(NameStyleTextName_Float8)
						ot.Float8 = x
						this.Datatype8 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Datatype8
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *NameStyleGoName) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(380)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.NameStyleGoName.name_style1 | kind: Int32Kind | GoName: NameStyle1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("NameStyle1")
	encoder.AppendInt32(this.NameStyle1)
	// encode filed type of basic; | field: gojsontest.NameStyleGoName.names_Style2 | kind: Int32Kind | GoName: Names_Style2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Names_Style2")
	encoder.AppendInt32(this.Names_Style2)
	// encode filed type of basic; | field: gojsontest.NameStyleGoName.Name_Style3 | kind: Int32Kind | GoName: Name_Style3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Name_Style3")
	encoder.AppendInt32(this.Name_Style3)
	// encode filed type of basic; | field: gojsontest.NameStyleGoName.Name_style4 | kind: Int32Kind | GoName: NameStyle4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("NameStyle4")
	encoder.AppendInt32(this.NameStyle4)
	// encode filed type of basic; | field: gojsontest.NameStyleGoName.namestyle5 | kind: Int32Kind | GoName: Namestyle5 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Namestyle5")
	encoder.AppendInt32(this.Namestyle5)
	// encode filed type of basic; | field: gojsontest.NameStyleGoName.nameStyle6 | kind: Int32Kind | GoName: NameStyle6 | omitempty: false | ignore: false
	encoder.AppendObjectKey("NameStyle6")
	encoder.AppendInt32(this.NameStyle6)
	// encode filed type of basic; | field: gojsontest.NameStyleGoName.NameStyle7 | kind: Int32Kind | GoName: NameStyle7 | omitempty: false | ignore: false
	encoder.AppendObjectKey("NameStyle7")
	encoder.AppendInt32(this.NameStyle7)
	// encode filed type of basic; | field: gojsontest.NameStyleGoName.Namestyle8 | kind: Int32Kind | GoName: Namestyle8 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Namestyle8")
	encoder.AppendInt32(this.Namestyle8)
	// Encode field type of oneof; | field: gojsontest.NameStyleGoName.data_type1 | GoName: DataType1 | omitempty: false | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *NameStyleGoName_Integer1:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.integer1 | kind: StringKind | GoName: Integer1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Integer1")
			encoder.AppendString(v.Integer1)
			encoder.AppendObjectEnd()
		case *NameStyleGoName_Float1:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.float1 | kind: StringKind | GoName: Float1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Float1")
			encoder.AppendString(v.Float1)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: DataType1, goName: DataType1, field: gojsontest.NameStyleGoName.data_type1", v)
		}
	} else {
		encoder.AppendObjectKey("DataType1")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleGoName.data_Type2 | GoName: Data_Type2 | omitempty: false | ignore: false
	if this.Data_Type2 != nil {
		switch v := this.Data_Type2.(type) {
		case *NameStyleGoName_Integer2:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.integer2 | kind: StringKind | GoName: Integer2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_Type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Integer2")
			encoder.AppendString(v.Integer2)
			encoder.AppendObjectEnd()
		case *NameStyleGoName_Float2:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.float2 | kind: StringKind | GoName: Float2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_Type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Float2")
			encoder.AppendString(v.Float2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Data_Type2, goName: Data_Type2, field: gojsontest.NameStyleGoName.data_Type2", v)
		}
	} else {
		encoder.AppendObjectKey("Data_Type2")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleGoName.Data_Type3 | GoName: Data_Type3 | omitempty: false | ignore: false
	if this.Data_Type3 != nil {
		switch v := this.Data_Type3.(type) {
		case *NameStyleGoName_Integer3:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.integer3 | kind: StringKind | GoName: Integer3 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_Type3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Integer3")
			encoder.AppendString(v.Integer3)
			encoder.AppendObjectEnd()
		case *NameStyleGoName_Float3:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.float3 | kind: StringKind | GoName: Float3 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_Type3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Float3")
			encoder.AppendString(v.Float3)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Data_Type3, goName: Data_Type3, field: gojsontest.NameStyleGoName.Data_Type3", v)
		}
	} else {
		encoder.AppendObjectKey("Data_Type3")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleGoName.Data_type4 | GoName: DataType4 | omitempty: false | ignore: false
	if this.DataType4 != nil {
		switch v := this.DataType4.(type) {
		case *NameStyleGoName_Integer4:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.integer4 | kind: StringKind | GoName: Integer4 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Integer4")
			encoder.AppendString(v.Integer4)
			encoder.AppendObjectEnd()
		case *NameStyleGoName_Float4:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.float4 | kind: StringKind | GoName: Float4 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Float4")
			encoder.AppendString(v.Float4)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: DataType4, goName: DataType4, field: gojsontest.NameStyleGoName.Data_type4", v)
		}
	} else {
		encoder.AppendObjectKey("DataType4")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleGoName.datatype5 | GoName: Datatype5 | omitempty: false | ignore: false
	if this.Datatype5 != nil {
		switch v := this.Datatype5.(type) {
		case *NameStyleGoName_Integer5:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.integer5 | kind: StringKind | GoName: Integer5 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Datatype5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Integer5")
			encoder.AppendString(v.Integer5)
			encoder.AppendObjectEnd()
		case *NameStyleGoName_Float5:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.float5 | kind: StringKind | GoName: Float5 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Datatype5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Float5")
			encoder.AppendString(v.Float5)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Datatype5, goName: Datatype5, field: gojsontest.NameStyleGoName.datatype5", v)
		}
	} else {
		encoder.AppendObjectKey("Datatype5")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleGoName.dataType6 | GoName: DataType6 | omitempty: false | ignore: false
	if this.DataType6 != nil {
		switch v := this.DataType6.(type) {
		case *NameStyleGoName_Integer6:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.integer6 | kind: StringKind | GoName: Integer6 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Integer6")
			encoder.AppendString(v.Integer6)
			encoder.AppendObjectEnd()
		case *NameStyleGoName_Float6:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.float6 | kind: StringKind | GoName: Float6 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Float6")
			encoder.AppendString(v.Float6)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: DataType6, goName: DataType6, field: gojsontest.NameStyleGoName.dataType6", v)
		}
	} else {
		encoder.AppendObjectKey("DataType6")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleGoName.DataType7 | GoName: DataType7 | omitempty: false | ignore: false
	if this.DataType7 != nil {
		switch v := this.DataType7.(type) {
		case *NameStyleGoName_Integer7:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.integer7 | kind: StringKind | GoName: Integer7 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Integer7")
			encoder.AppendString(v.Integer7)
			encoder.AppendObjectEnd()
		case *NameStyleGoName_Float7:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.float7 | kind: StringKind | GoName: Float7 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Float7")
			encoder.AppendString(v.Float7)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: DataType7, goName: DataType7, field: gojsontest.NameStyleGoName.DataType7", v)
		}
	} else {
		encoder.AppendObjectKey("DataType7")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleGoName.Datatype8 | GoName: Datatype8 | omitempty: false | ignore: false
	if this.Datatype8 != nil {
		switch v := this.Datatype8.(type) {
		case *NameStyleGoName_Integer8:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.integer8 | kind: StringKind | GoName: Integer8 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Datatype8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Integer8")
			encoder.AppendString(v.Integer8)
			encoder.AppendObjectEnd()
		case *NameStyleGoName_Float8:
			// encode filed type of basic; | field: gojsontest.NameStyleGoName.float8 | kind: StringKind | GoName: Float8 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Datatype8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("Float8")
			encoder.AppendString(v.Float8)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Datatype8, goName: Datatype8, field: gojsontest.NameStyleGoName.Datatype8", v)
		}
	} else {
		encoder.AppendObjectKey("Datatype8")
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *NameStyleGoName) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*NameStyleGoName) is nil")
	}
	var oneofDataType1isStore bool
	var oneofData_Type2isStore bool
	var oneofData_Type3isStore bool
	var oneofDataType4isStore bool
	var oneofDatatype5isStore bool
	var oneofDataType6isStore bool
	var oneofDataType7isStore bool
	var oneofDatatype8isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "NameStyle1":
			// decode filed type of basic; | field: gojsontest.NameStyleGoName.name_style1 | kind: Int32Kind | GoName: NameStyle1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle1 = x
		case objKey == "Names_Style2":
			// decode filed type of basic; | field: gojsontest.NameStyleGoName.names_Style2 | kind: Int32Kind | GoName: Names_Style2
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Names_Style2 = x
		case objKey == "Name_Style3":
			// decode filed type of basic; | field: gojsontest.NameStyleGoName.Name_Style3 | kind: Int32Kind | GoName: Name_Style3
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Name_Style3 = x
		case objKey == "NameStyle4":
			// decode filed type of basic; | field: gojsontest.NameStyleGoName.Name_style4 | kind: Int32Kind | GoName: NameStyle4
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle4 = x
		case objKey == "Namestyle5":
			// decode filed type of basic; | field: gojsontest.NameStyleGoName.namestyle5 | kind: Int32Kind | GoName: Namestyle5
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Namestyle5 = x
		case objKey == "NameStyle6":
			// decode filed type of basic; | field: gojsontest.NameStyleGoName.nameStyle6 | kind: Int32Kind | GoName: NameStyle6
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle6 = x
		case objKey == "NameStyle7":
			// decode filed type of basic; | field: gojsontest.NameStyleGoName.NameStyle7 | kind: Int32Kind | GoName: NameStyle7
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle7 = x
		case objKey == "Namestyle8":
			// decode filed type of basic; | field: gojsontest.NameStyleGoName.Namestyle8 | kind: Int32Kind | GoName: Namestyle8
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Namestyle8 = x
		case objKey == "DataType1":
			// decode filed type of oneof; | field: gojsontest.NameStyleGoName.data_type1 | GoName: DataType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_DataType1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_DataType1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "Integer1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(NameStyleGoName_Integer1)
						ot.Integer1 = x
						this.DataType1 = ot
					case oneofKey == "Float1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(NameStyleGoName_Float1)
						ot.Float1 = x
						this.DataType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_DataType1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Data_Type2":
			// decode filed type of oneof; | field: gojsontest.NameStyleGoName.data_Type2 | GoName: Data_Type2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Data_Type2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Data_Type2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "Integer2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type2isStore = true
						ot := new(NameStyleGoName_Integer2)
						ot.Integer2 = x
						this.Data_Type2 = ot
					case oneofKey == "Float2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type2isStore = true
						ot := new(NameStyleGoName_Float2)
						ot.Float2 = x
						this.Data_Type2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Data_Type2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Data_Type3":
			// decode filed type of oneof; | field: gojsontest.NameStyleGoName.Data_Type3 | GoName: Data_Type3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Data_Type3:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Data_Type3
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "Integer3":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type3isStore = true
						ot := new(NameStyleGoName_Integer3)
						ot.Integer3 = x
						this.Data_Type3 = ot
					case oneofKey == "Float3":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type3isStore = true
						ot := new(NameStyleGoName_Float3)
						ot.Float3 = x
						this.Data_Type3 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Data_Type3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "DataType4":
			// decode filed type of oneof; | field: gojsontest.NameStyleGoName.Data_type4 | GoName: DataType4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_DataType4:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_DataType4
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "Integer4":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(NameStyleGoName_Integer4)
						ot.Integer4 = x
						this.DataType4 = ot
					case oneofKey == "Float4":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(NameStyleGoName_Float4)
						ot.Float4 = x
						this.DataType4 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_DataType4
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Datatype5":
			// decode filed type of oneof; | field: gojsontest.NameStyleGoName.datatype5 | GoName: Datatype5
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Datatype5:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Datatype5
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "Integer5":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype5isStore = true
						ot := new(NameStyleGoName_Integer5)
						ot.Integer5 = x
						this.Datatype5 = ot
					case oneofKey == "Float5":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype5isStore = true
						ot := new(NameStyleGoName_Float5)
						ot.Float5 = x
						this.Datatype5 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Datatype5
					}
				}
				decoder.ScanNext()
			}
		case objKey == "DataType6":
			// decode filed type of oneof; | field: gojsontest.NameStyleGoName.dataType6 | GoName: DataType6
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_DataType6:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_DataType6
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "Integer6":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(NameStyleGoName_Integer6)
						ot.Integer6 = x
						this.DataType6 = ot
					case oneofKey == "Float6":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(NameStyleGoName_Float6)
						ot.Float6 = x
						this.DataType6 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_DataType6
					}
				}
				decoder.ScanNext()
			}
		case objKey == "DataType7":
			// decode filed type of oneof; | field: gojsontest.NameStyleGoName.DataType7 | GoName: DataType7
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_DataType7:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_DataType7
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "Integer7":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(NameStyleGoName_Integer7)
						ot.Integer7 = x
						this.DataType7 = ot
					case oneofKey == "Float7":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(NameStyleGoName_Float7)
						ot.Float7 = x
						this.DataType7 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_DataType7
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Datatype8":
			// decode filed type of oneof; | field: gojsontest.NameStyleGoName.Datatype8 | GoName: Datatype8
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Datatype8:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Datatype8
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "Integer8":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype8isStore = true
						ot := new(NameStyleGoName_Integer8)
						ot.Integer8 = x
						this.Datatype8 = ot
					case oneofKey == "Float8":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype8isStore = true
						ot := new(NameStyleGoName_Float8)
						ot.Float8 = x
						this.Datatype8 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Datatype8
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *NameStyleJSONName) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(380)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.NameStyleJSONName.name_style1 | kind: Int32Kind | GoName: NameStyle1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("nameStyle1")
	encoder.AppendInt32(this.NameStyle1)
	// encode filed type of basic; | field: gojsontest.NameStyleJSONName.names_Style2 | kind: Int32Kind | GoName: Names_Style2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("namesStyle2")
	encoder.AppendInt32(this.Names_Style2)
	// encode filed type of basic; | field: gojsontest.NameStyleJSONName.Name_Style3 | kind: Int32Kind | GoName: Name_Style3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("NameStyle3")
	encoder.AppendInt32(this.Name_Style3)
	// encode filed type of basic; | field: gojsontest.NameStyleJSONName.Name_style4 | kind: Int32Kind | GoName: NameStyle4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("NameStyle4")
	encoder.AppendInt32(this.NameStyle4)
	// encode filed type of basic; | field: gojsontest.NameStyleJSONName.namestyle5 | kind: Int32Kind | GoName: Namestyle5 | omitempty: false | ignore: false
	encoder.AppendObjectKey("namestyle5")
	encoder.AppendInt32(this.Namestyle5)
	// encode filed type of basic; | field: gojsontest.NameStyleJSONName.nameStyle6 | kind: Int32Kind | GoName: NameStyle6 | omitempty: false | ignore: false
	encoder.AppendObjectKey("nameStyle6")
	encoder.AppendInt32(this.NameStyle6)
	// encode filed type of basic; | field: gojsontest.NameStyleJSONName.NameStyle7 | kind: Int32Kind | GoName: NameStyle7 | omitempty: false | ignore: false
	encoder.AppendObjectKey("NameStyle7")
	encoder.AppendInt32(this.NameStyle7)
	// encode filed type of basic; | field: gojsontest.NameStyleJSONName.Namestyle8 | kind: Int32Kind | GoName: Namestyle8 | omitempty: false | ignore: false
	encoder.AppendObjectKey("Namestyle8")
	encoder.AppendInt32(this.Namestyle8)
	// Encode field type of oneof; | field: gojsontest.NameStyleJSONName.data_type1 | GoName: DataType1 | omitempty: false | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *NameStyleJSONName_Integer1:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.integer1 | kind: StringKind | GoName: Integer1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer1")
			encoder.AppendString(v.Integer1)
			encoder.AppendObjectEnd()
		case *NameStyleJSONName_Float1:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.float1 | kind: StringKind | GoName: Float1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float1")
			encoder.AppendString(v.Float1)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type1, goName: DataType1, field: gojsontest.NameStyleJSONName.data_type1", v)
		}
	} else {
		encoder.AppendObjectKey("data_type1")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleJSONName.data_Type2 | GoName: Data_Type2 | omitempty: false | ignore: false
	if this.Data_Type2 != nil {
		switch v := this.Data_Type2.(type) {
		case *NameStyleJSONName_Integer2:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.integer2 | kind: StringKind | GoName: Integer2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_Type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer2")
			encoder.AppendString(v.Integer2)
			encoder.AppendObjectEnd()
		case *NameStyleJSONName_Float2:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.float2 | kind: StringKind | GoName: Float2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_Type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float2")
			encoder.AppendString(v.Float2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_Type2, goName: Data_Type2, field: gojsontest.NameStyleJSONName.data_Type2", v)
		}
	} else {
		encoder.AppendObjectKey("data_Type2")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleJSONName.Data_Type3 | GoName: Data_Type3 | omitempty: false | ignore: false
	if this.Data_Type3 != nil {
		switch v := this.Data_Type3.(type) {
		case *NameStyleJSONName_Integer3:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.integer3 | kind: StringKind | GoName: Integer3 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_Type3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer3")
			encoder.AppendString(v.Integer3)
			encoder.AppendObjectEnd()
		case *NameStyleJSONName_Float3:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.float3 | kind: StringKind | GoName: Float3 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_Type3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float3")
			encoder.AppendString(v.Float3)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Data_Type3, goName: Data_Type3, field: gojsontest.NameStyleJSONName.Data_Type3", v)
		}
	} else {
		encoder.AppendObjectKey("Data_Type3")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleJSONName.Data_type4 | GoName: DataType4 | omitempty: false | ignore: false
	if this.DataType4 != nil {
		switch v := this.DataType4.(type) {
		case *NameStyleJSONName_Integer4:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.integer4 | kind: StringKind | GoName: Integer4 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer4")
			encoder.AppendString(v.Integer4)
			encoder.AppendObjectEnd()
		case *NameStyleJSONName_Float4:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.float4 | kind: StringKind | GoName: Float4 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Data_type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float4")
			encoder.AppendString(v.Float4)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Data_type4, goName: DataType4, field: gojsontest.NameStyleJSONName.Data_type4", v)
		}
	} else {
		encoder.AppendObjectKey("Data_type4")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleJSONName.datatype5 | GoName: Datatype5 | omitempty: false | ignore: false
	if this.Datatype5 != nil {
		switch v := this.Datatype5.(type) {
		case *NameStyleJSONName_Integer5:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.integer5 | kind: StringKind | GoName: Integer5 | omitempty: false | ignore: false
			encoder.AppendObjectKey("datatype5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer5")
			encoder.AppendString(v.Integer5)
			encoder.AppendObjectEnd()
		case *NameStyleJSONName_Float5:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.float5 | kind: StringKind | GoName: Float5 | omitempty: false | ignore: false
			encoder.AppendObjectKey("datatype5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float5")
			encoder.AppendString(v.Float5)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: datatype5, goName: Datatype5, field: gojsontest.NameStyleJSONName.datatype5", v)
		}
	} else {
		encoder.AppendObjectKey("datatype5")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleJSONName.dataType6 | GoName: DataType6 | omitempty: false | ignore: false
	if this.DataType6 != nil {
		switch v := this.DataType6.(type) {
		case *NameStyleJSONName_Integer6:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.integer6 | kind: StringKind | GoName: Integer6 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dataType6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer6")
			encoder.AppendString(v.Integer6)
			encoder.AppendObjectEnd()
		case *NameStyleJSONName_Float6:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.float6 | kind: StringKind | GoName: Float6 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dataType6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float6")
			encoder.AppendString(v.Float6)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dataType6, goName: DataType6, field: gojsontest.NameStyleJSONName.dataType6", v)
		}
	} else {
		encoder.AppendObjectKey("dataType6")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleJSONName.DataType7 | GoName: DataType7 | omitempty: false | ignore: false
	if this.DataType7 != nil {
		switch v := this.DataType7.(type) {
		case *NameStyleJSONName_Integer7:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.integer7 | kind: StringKind | GoName: Integer7 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer7")
			encoder.AppendString(v.Integer7)
			encoder.AppendObjectEnd()
		case *NameStyleJSONName_Float7:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.float7 | kind: StringKind | GoName: Float7 | omitempty: false | ignore: false
			encoder.AppendObjectKey("DataType7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float7")
			encoder.AppendString(v.Float7)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: DataType7, goName: DataType7, field: gojsontest.NameStyleJSONName.DataType7", v)
		}
	} else {
		encoder.AppendObjectKey("DataType7")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.NameStyleJSONName.Datatype8 | GoName: Datatype8 | omitempty: false | ignore: false
	if this.Datatype8 != nil {
		switch v := this.Datatype8.(type) {
		case *NameStyleJSONName_Integer8:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.integer8 | kind: StringKind | GoName: Integer8 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Datatype8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("integer8")
			encoder.AppendString(v.Integer8)
			encoder.AppendObjectEnd()
		case *NameStyleJSONName_Float8:
			// encode filed type of basic; | field: gojsontest.NameStyleJSONName.float8 | kind: StringKind | GoName: Float8 | omitempty: false | ignore: false
			encoder.AppendObjectKey("Datatype8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("float8")
			encoder.AppendString(v.Float8)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: Datatype8, goName: Datatype8, field: gojsontest.NameStyleJSONName.Datatype8", v)
		}
	} else {
		encoder.AppendObjectKey("Datatype8")
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *NameStyleJSONName) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*NameStyleJSONName) is nil")
	}
	var oneofDataType1isStore bool
	var oneofData_Type2isStore bool
	var oneofData_Type3isStore bool
	var oneofDataType4isStore bool
	var oneofDatatype5isStore bool
	var oneofDataType6isStore bool
	var oneofDataType7isStore bool
	var oneofDatatype8isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "nameStyle1":
			// decode filed type of basic; | field: gojsontest.NameStyleJSONName.name_style1 | kind: Int32Kind | GoName: NameStyle1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle1 = x
		case objKey == "namesStyle2":
			// decode filed type of basic; | field: gojsontest.NameStyleJSONName.names_Style2 | kind: Int32Kind | GoName: Names_Style2
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Names_Style2 = x
		case objKey == "NameStyle3":
			// decode filed type of basic; | field: gojsontest.NameStyleJSONName.Name_Style3 | kind: Int32Kind | GoName: Name_Style3
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Name_Style3 = x
		case objKey == "NameStyle4":
			// decode filed type of basic; | field: gojsontest.NameStyleJSONName.Name_style4 | kind: Int32Kind | GoName: NameStyle4
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle4 = x
		case objKey == "namestyle5":
			// decode filed type of basic; | field: gojsontest.NameStyleJSONName.namestyle5 | kind: Int32Kind | GoName: Namestyle5
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Namestyle5 = x
		case objKey == "nameStyle6":
			// decode filed type of basic; | field: gojsontest.NameStyleJSONName.nameStyle6 | kind: Int32Kind | GoName: NameStyle6
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle6 = x
		case objKey == "NameStyle7":
			// decode filed type of basic; | field: gojsontest.NameStyleJSONName.NameStyle7 | kind: Int32Kind | GoName: NameStyle7
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle7 = x
		case objKey == "Namestyle8":
			// decode filed type of basic; | field: gojsontest.NameStyleJSONName.Namestyle8 | kind: Int32Kind | GoName: Namestyle8
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Namestyle8 = x
		case objKey == "data_type1":
			// decode filed type of oneof; | field: gojsontest.NameStyleJSONName.data_type1 | GoName: DataType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_type1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(NameStyleJSONName_Integer1)
						ot.Integer1 = x
						this.DataType1 = ot
					case oneofKey == "float1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(NameStyleJSONName_Float1)
						ot.Float1 = x
						this.DataType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_Type2":
			// decode filed type of oneof; | field: gojsontest.NameStyleJSONName.data_Type2 | GoName: Data_Type2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_Type2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_Type2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type2isStore = true
						ot := new(NameStyleJSONName_Integer2)
						ot.Integer2 = x
						this.Data_Type2 = ot
					case oneofKey == "float2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type2isStore = true
						ot := new(NameStyleJSONName_Float2)
						ot.Float2 = x
						this.Data_Type2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_Type2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Data_Type3":
			// decode filed type of oneof; | field: gojsontest.NameStyleJSONName.Data_Type3 | GoName: Data_Type3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Data_Type3:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Data_Type3
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer3":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type3isStore = true
						ot := new(NameStyleJSONName_Integer3)
						ot.Integer3 = x
						this.Data_Type3 = ot
					case oneofKey == "float3":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofData_Type3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofData_Type3isStore = true
						ot := new(NameStyleJSONName_Float3)
						ot.Float3 = x
						this.Data_Type3 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Data_Type3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Data_type4":
			// decode filed type of oneof; | field: gojsontest.NameStyleJSONName.Data_type4 | GoName: DataType4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Data_type4:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Data_type4
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer4":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(NameStyleJSONName_Integer4)
						ot.Integer4 = x
						this.DataType4 = ot
					case oneofKey == "float4":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(NameStyleJSONName_Float4)
						ot.Float4 = x
						this.DataType4 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Data_type4
					}
				}
				decoder.ScanNext()
			}
		case objKey == "datatype5":
			// decode filed type of oneof; | field: gojsontest.NameStyleJSONName.datatype5 | GoName: Datatype5
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_datatype5:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_datatype5
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer5":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype5isStore = true
						ot := new(NameStyleJSONName_Integer5)
						ot.Integer5 = x
						this.Datatype5 = ot
					case oneofKey == "float5":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype5isStore = true
						ot := new(NameStyleJSONName_Float5)
						ot.Float5 = x
						this.Datatype5 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_datatype5
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dataType6":
			// decode filed type of oneof; | field: gojsontest.NameStyleJSONName.dataType6 | GoName: DataType6
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dataType6:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dataType6
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer6":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(NameStyleJSONName_Integer6)
						ot.Integer6 = x
						this.DataType6 = ot
					case oneofKey == "float6":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(NameStyleJSONName_Float6)
						ot.Float6 = x
						this.DataType6 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dataType6
					}
				}
				decoder.ScanNext()
			}
		case objKey == "DataType7":
			// decode filed type of oneof; | field: gojsontest.NameStyleJSONName.DataType7 | GoName: DataType7
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_DataType7:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_DataType7
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer7":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(NameStyleJSONName_Integer7)
						ot.Integer7 = x
						this.DataType7 = ot
					case oneofKey == "float7":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(NameStyleJSONName_Float7)
						ot.Float7 = x
						this.DataType7 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_DataType7
					}
				}
				decoder.ScanNext()
			}
		case objKey == "Datatype8":
			// decode filed type of oneof; | field: gojsontest.NameStyleJSONName.Datatype8 | GoName: Datatype8
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_Datatype8:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_Datatype8
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "integer8":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype8isStore = true
						ot := new(NameStyleJSONName_Integer8)
						ot.Integer8 = x
						this.Datatype8 = ot
					case oneofKey == "float8":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDatatype8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDatatype8isStore = true
						ot := new(NameStyleJSONName_Float8)
						ot.Float8 = x
						this.Datatype8 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_Datatype8
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldCustomName) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(924)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_string | kind: StringKind | GoName: TString | omitempty: true | ignore: false
	if this.TString != "" {
		encoder.AppendObjectKey("ts")
		encoder.AppendString(this.TString)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_int32 | kind: Int32Kind | GoName: TInt32 | omitempty: true | ignore: false
	if this.TInt32 != 0 {
		encoder.AppendObjectKey("ti32")
		encoder.AppendInt32(this.TInt32)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_int64 | kind: Int64Kind | GoName: TInt64 | omitempty: true | ignore: false
	if this.TInt64 != 0 {
		encoder.AppendObjectKey("ti64")
		encoder.AppendInt64(this.TInt64)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_uint32 | kind: Uint32Kind | GoName: TUint32 | omitempty: true | ignore: false
	if this.TUint32 != 0 {
		encoder.AppendObjectKey("tu32")
		encoder.AppendUint32(this.TUint32)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_uint64 | kind: Uint64Kind | GoName: TUint64 | omitempty: true | ignore: false
	if this.TUint64 != 0 {
		encoder.AppendObjectKey("tu64")
		encoder.AppendUint64(this.TUint64)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_sint32 | kind: Sint32Kind | GoName: TSint32 | omitempty: true | ignore: false
	if this.TSint32 != 0 {
		encoder.AppendObjectKey("tsi32")
		encoder.AppendInt32(this.TSint32)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_sint64 | kind: Sint64Kind | GoName: TSint64 | omitempty: true | ignore: false
	if this.TSint64 != 0 {
		encoder.AppendObjectKey("tsi64")
		encoder.AppendInt64(this.TSint64)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32 | omitempty: true | ignore: false
	if this.TSfixed32 != 0 {
		encoder.AppendObjectKey("tsf32")
		encoder.AppendInt32(this.TSfixed32)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64 | omitempty: true | ignore: false
	if this.TSfixed64 != 0 {
		encoder.AppendObjectKey("tsf64")
		encoder.AppendInt64(this.TSfixed64)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32 | omitempty: true | ignore: false
	if this.TFixed32 != 0 {
		encoder.AppendObjectKey("tfi32")
		encoder.AppendUint32(this.TFixed32)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64 | omitempty: true | ignore: false
	if this.TFixed64 != 0 {
		encoder.AppendObjectKey("tfi64")
		encoder.AppendUint64(this.TFixed64)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_float | kind: FloatKind | GoName: TFloat | omitempty: true | ignore: false
	if this.TFloat != 0 {
		encoder.AppendObjectKey("tfl")
		encoder.AppendFloat32(this.TFloat)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_double | kind: DoubleKind | GoName: TDouble | omitempty: true | ignore: false
	if this.TDouble != 0 {
		encoder.AppendObjectKey("tdl")
		encoder.AppendFloat64(this.TDouble)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_bool | kind: BoolKind | GoName: TBool | omitempty: true | ignore: false
	if this.TBool {
		encoder.AppendObjectKey("tbl")
		encoder.AppendBool(this.TBool)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_enum1 | kind: EnumKind | GoName: TEnum1 | omitempty: true | ignore: false
	if this.TEnum1 != 0 {
		encoder.AppendObjectKey("te1")
		encoder.AppendInt32(int32(this.TEnum1.Number()))
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_enum2 | kind: EnumKind | GoName: TEnum2 | omitempty: true | ignore: false
	encoder.AppendObjectKey("te2")
	encoder.AppendString(this.TEnum2.String())
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_bytes | kind: BytesKind | GoName: TBytes | omitempty: true | ignore: false
	if len(this.TBytes) != 0 {
		encoder.AppendObjectKey("tbs")
		encoder.AppendBytes(this.TBytes)
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_aliases | kind: MessageKind | GoName: TAliases | omitempty: true | ignore: false
	if this.TAliases != nil {
		encoder.AppendObjectKey("ta")
		err = encoder.AppendInterface(this.TAliases)
		if err != nil {
			return nil, err
		}
	}
	// encode filed type of basic; | field: gojsontest.FieldCustomName.t_config | kind: MessageKind | GoName: TConfig | omitempty: true | ignore: false
	if this.TConfig != nil {
		encoder.AppendObjectKey("tc")
		err = encoder.AppendInterface(this.TConfig)
		if err != nil {
			return nil, err
		}
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_double | kind:DoubleKind | goName: ArrayDouble | omitempty: true | ignore: false
	if len(this.ArrayDouble) != 0 {
		encoder.AppendObjectKey("adl")
		encoder.AppendListBegin()
		for i := range this.ArrayDouble {
			encoder.AppendFloat64(this.ArrayDouble[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_float | kind:FloatKind | goName: ArrayFloat | omitempty: true | ignore: false
	if len(this.ArrayFloat) != 0 {
		encoder.AppendObjectKey("afl")
		encoder.AppendListBegin()
		for i := range this.ArrayFloat {
			encoder.AppendFloat32(this.ArrayFloat[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_int32 | kind:Int32Kind | goName: ArrayInt32 | omitempty: true | ignore: false
	if len(this.ArrayInt32) != 0 {
		encoder.AppendObjectKey("ai32")
		encoder.AppendListBegin()
		for i := range this.ArrayInt32 {
			encoder.AppendInt32(this.ArrayInt32[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_int64 | kind:Int64Kind | goName: ArrayInt64 | omitempty: true | ignore: false
	if len(this.ArrayInt64) != 0 {
		encoder.AppendObjectKey("ai64")
		encoder.AppendListBegin()
		for i := range this.ArrayInt64 {
			encoder.AppendInt64(this.ArrayInt64[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_uint32 | kind:Uint32Kind | goName: ArrayUint32 | omitempty: true | ignore: false
	if len(this.ArrayUint32) != 0 {
		encoder.AppendObjectKey("au32")
		encoder.AppendListBegin()
		for i := range this.ArrayUint32 {
			encoder.AppendUint32(this.ArrayUint32[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_uint64 | kind:Uint64Kind | goName: ArrayUint64 | omitempty: true | ignore: false
	if len(this.ArrayUint64) != 0 {
		encoder.AppendObjectKey("au64")
		encoder.AppendListBegin()
		for i := range this.ArrayUint64 {
			encoder.AppendUint64(this.ArrayUint64[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_sint32 | kind:Sint32Kind | goName: ArraySint32 | omitempty: true | ignore: false
	if len(this.ArraySint32) != 0 {
		encoder.AppendObjectKey("asi32")
		encoder.AppendListBegin()
		for i := range this.ArraySint32 {
			encoder.AppendInt32(this.ArraySint32[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_sint64 | kind:Sint64Kind | goName: ArraySint64 | omitempty: true | ignore: false
	if len(this.ArraySint64) != 0 {
		encoder.AppendObjectKey("asi64")
		encoder.AppendListBegin()
		for i := range this.ArraySint64 {
			encoder.AppendInt64(this.ArraySint64[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_sfixed32 | kind:Sfixed32Kind | goName: ArraySfixed32 | omitempty: true | ignore: false
	if len(this.ArraySfixed32) != 0 {
		encoder.AppendObjectKey("asf32")
		encoder.AppendListBegin()
		for i := range this.ArraySfixed32 {
			encoder.AppendInt32(this.ArraySfixed32[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_sfixed64 | kind:Sfixed64Kind | goName: ArraySfixed64 | omitempty: true | ignore: false
	if len(this.ArraySfixed64) != 0 {
		encoder.AppendObjectKey("asf64")
		encoder.AppendListBegin()
		for i := range this.ArraySfixed64 {
			encoder.AppendInt64(this.ArraySfixed64[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_fixed32 | kind:Fixed32Kind | goName: ArrayFixed32 | omitempty: true | ignore: false
	if len(this.ArrayFixed32) != 0 {
		encoder.AppendObjectKey("afi32")
		encoder.AppendListBegin()
		for i := range this.ArrayFixed32 {
			encoder.AppendUint32(this.ArrayFixed32[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_fixed64 | kind:Fixed64Kind | goName: ArrayFixed64 | omitempty: true | ignore: false
	if len(this.ArrayFixed64) != 0 {
		encoder.AppendObjectKey("afi64")
		encoder.AppendListBegin()
		for i := range this.ArrayFixed64 {
			encoder.AppendUint64(this.ArrayFixed64[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_bool | kind:BoolKind | goName: ArrayBool | omitempty: true | ignore: false
	if len(this.ArrayBool) != 0 {
		encoder.AppendObjectKey("abl")
		encoder.AppendListBegin()
		for i := range this.ArrayBool {
			encoder.AppendBool(this.ArrayBool[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_string | kind:StringKind | goName: ArrayString | omitempty: true | ignore: false
	if len(this.ArrayString) != 0 {
		encoder.AppendObjectKey("as")
		encoder.AppendListBegin()
		for i := range this.ArrayString {
			encoder.AppendString(this.ArrayString[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_bytes | kind:BytesKind | goName: ArrayBytes | omitempty: true | ignore: false
	if len(this.ArrayBytes) != 0 {
		encoder.AppendObjectKey("abs")
		encoder.AppendListBegin()
		for i := range this.ArrayBytes {
			encoder.AppendBytes(this.ArrayBytes[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_enum1 | kind:EnumKind | goName: ArrayEnum1 | omitempty: true | ignore: false
	if len(this.ArrayEnum1) != 0 {
		encoder.AppendObjectKey("ae1")
		encoder.AppendListBegin()
		for i := range this.ArrayEnum1 {
			encoder.AppendInt32(int32(this.ArrayEnum1[i].Number()))
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_enum2 | kind:EnumKind | goName: ArrayEnum2 | omitempty: true | ignore: false
	if len(this.ArrayEnum2) != 0 {
		encoder.AppendObjectKey("ae2")
		encoder.AppendListBegin()
		for i := range this.ArrayEnum2 {
			encoder.AppendString(this.ArrayEnum2[i].String())
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_aliases | kind:MessageKind | goName: ArrayAliases | omitempty: true | ignore: false
	if len(this.ArrayAliases) != 0 {
		encoder.AppendObjectKey("aa")
		encoder.AppendListBegin()
		for i := range this.ArrayAliases {
			err = encoder.AppendInterface(this.ArrayAliases[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.FieldCustomName.array_config | kind:MessageKind | goName: ArrayConfig | omitempty: true | ignore: false
	if len(this.ArrayConfig) != 0 {
		encoder.AppendObjectKey("ac")
		encoder.AppendListBegin()
		for i := range this.ArrayConfig {
			err = encoder.AppendInterface(this.ArrayConfig[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_double | keyKind: int32 | valueKind: double | goName: MapInt32Double | omitempty: true | ignore: false
	if len(this.MapInt32Double) != 0 {
		encoder.AppendObjectKey("m32dl")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Double {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendFloat64(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_float | keyKind: int32 | valueKind: float | goName: MapInt32Float | omitempty: true | ignore: false
	if len(this.MapInt32Float) != 0 {
		encoder.AppendObjectKey("m32fl")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Float {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendFloat32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_int32 | keyKind: int32 | valueKind: int32 | goName: MapInt32Int32 | omitempty: true | ignore: false
	if len(this.MapInt32Int32) != 0 {
		encoder.AppendObjectKey("m32i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_int64 | keyKind: int32 | valueKind: int64 | goName: MapInt32Int64 | omitempty: true | ignore: false
	if len(this.MapInt32Int64) != 0 {
		encoder.AppendObjectKey("m32i64")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Int64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_uint32 | keyKind: int32 | valueKind: uint32 | goName: MapInt32Uint32 | omitempty: true | ignore: false
	if len(this.MapInt32Uint32) != 0 {
		encoder.AppendObjectKey("m32u32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Uint32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_uint64 | keyKind: int32 | valueKind: uint64 | goName: MapInt32Uint64 | omitempty: true | ignore: false
	if len(this.MapInt32Uint64) != 0 {
		encoder.AppendObjectKey("m32u64")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Uint64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint64(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_sint32 | keyKind: int32 | valueKind: sint32 | goName: MapInt32Sint32 | omitempty: true | ignore: false
	if len(this.MapInt32Sint32) != 0 {
		encoder.AppendObjectKey("m32si32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sint32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_sint64 | keyKind: int32 | valueKind: sint64 | goName: MapInt32Sint64 | omitempty: true | ignore: false
	if len(this.MapInt32Sint64) != 0 {
		encoder.AppendObjectKey("m32si64")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sint64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_sfixed32 | keyKind: int32 | valueKind: sfixed32 | goName: MapInt32Sfixed32 | omitempty: true | ignore: false
	if len(this.MapInt32Sfixed32) != 0 {
		encoder.AppendObjectKey("m32sf32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sfixed32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_sfixed64 | keyKind: int32 | valueKind: sfixed64 | goName: MapInt32Sfixed64 | omitempty: true | ignore: false
	if len(this.MapInt32Sfixed64) != 0 {
		encoder.AppendObjectKey("m32sf64")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sfixed64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_fixed32 | keyKind: int32 | valueKind: fixed32 | goName: MapInt32Fixed32 | omitempty: true | ignore: false
	if len(this.MapInt32Fixed32) != 0 {
		encoder.AppendObjectKey("m32fi32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Fixed32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_fixed64 | keyKind: int32 | valueKind: fixed64 | goName: MapInt32Fixed64 | omitempty: true | ignore: false
	if len(this.MapInt32Fixed64) != 0 {
		encoder.AppendObjectKey("m32fi64")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Fixed64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint64(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_bool | keyKind: int32 | valueKind: bool | goName: MapInt32Bool | omitempty: true | ignore: false
	if len(this.MapInt32Bool) != 0 {
		encoder.AppendObjectKey("m32bl")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Bool {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendBool(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_string | keyKind: int32 | valueKind: string | goName: MapInt32String | omitempty: true | ignore: false
	if len(this.MapInt32String) != 0 {
		encoder.AppendObjectKey("m32s")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32String {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_bytes | keyKind: int32 | valueKind: bytes | goName: MapInt32Bytes | omitempty: true | ignore: false
	if len(this.MapInt32Bytes) != 0 {
		encoder.AppendObjectKey("m32b")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Bytes {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_enum1 | keyKind: int32 | valueKind: enum | goName: MapInt32Enum1 | omitempty: true | ignore: false
	if len(this.MapInt32Enum1) != 0 {
		encoder.AppendObjectKey("m32e1")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Enum1 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_enum2 | keyKind: int32 | valueKind: enum | goName: MapInt32Enum2 | omitempty: true | ignore: false
	if len(this.MapInt32Enum2) != 0 {
		encoder.AppendObjectKey("m32e2")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Enum2 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendString(v.String())
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_aliases | keyKind: int32 | valueKind: message | goName: MapInt32Aliases | omitempty: true | ignore: false
	if len(this.MapInt32Aliases) != 0 {
		encoder.AppendObjectKey("m32a")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Aliases {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int32_config | keyKind: int32 | valueKind: message | goName: MapInt32Config | omitempty: true | ignore: false
	if len(this.MapInt32Config) != 0 {
		encoder.AppendObjectKey("m32c")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Config {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_int64_int32 | keyKind: int64 | valueKind: int32 | goName: MapInt64Int32 | omitempty: true | ignore: false
	if len(this.MapInt64Int32) != 0 {
		encoder.AppendObjectKey("mi64i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_uint32_int32 | keyKind: uint32 | valueKind: int32 | goName: MapUint32Int32 | omitempty: true | ignore: false
	if len(this.MapUint32Int32) != 0 {
		encoder.AppendObjectKey("mu32i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapUint32Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(uint64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_uint64_int32 | keyKind: uint64 | valueKind: int32 | goName: MapUint64Int32 | omitempty: true | ignore: false
	if len(this.MapUint64Int32) != 0 {
		encoder.AppendObjectKey("mu64i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapUint64Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_sint32_int32 | keyKind: sint32 | valueKind: int32 | goName: MapSint32Int32 | omitempty: true | ignore: false
	if len(this.MapSint32Int32) != 0 {
		encoder.AppendObjectKey("ms32i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapSint32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_sint64_int32 | keyKind: sint64 | valueKind: int32 | goName: MapSint64Int32 | omitempty: true | ignore: false
	if len(this.MapSint64Int32) != 0 {
		encoder.AppendObjectKey("ms64i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapSint64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_fixed32_int32 | keyKind: fixed32 | valueKind: int32 | goName: MapFixed32Int32 | omitempty: true | ignore: false
	if len(this.MapFixed32Int32) != 0 {
		encoder.AppendObjectKey("mf32i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapFixed32Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(uint64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_fixed64_int32 | keyKind: fixed64 | valueKind: int32 | goName: MapFixed64Int32 | omitempty: true | ignore: false
	if len(this.MapFixed64Int32) != 0 {
		encoder.AppendObjectKey("mf64i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapFixed64Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_sfixed32_int32 | keyKind: sfixed32 | valueKind: int32 | goName: MapSfixed32Int32 | omitempty: true | ignore: false
	if len(this.MapSfixed32Int32) != 0 {
		encoder.AppendObjectKey("msf32i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapSfixed32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_sfixed64_int32 | keyKind: sfixed64 | valueKind: int32 | goName: MapSfixed64Int32 | omitempty: true | ignore: false
	if len(this.MapSfixed64Int32) != 0 {
		encoder.AppendObjectKey("msf64i32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapSfixed64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.FieldCustomName.map_string_int32 | keyKind: string | valueKind: int32 | goName: MapStringInt32 | omitempty: true | ignore: false
	if len(this.MapStringInt32) != 0 {
		encoder.AppendObjectKey("msi32")
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringInt32 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	}
	// Encode field type of oneof; | field: gojsontest.FieldCustomName.DataType1 | GoName: DataType1 | omitempty: true | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *FieldCustomName_One1TString:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_string | kind: StringKind | GoName: One1TString | omitempty: true | ignore: false
			if v.One1TString != "" {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1ts")
				encoder.AppendString(v.One1TString)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TInt32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_int32 | kind: Int32Kind | GoName: One1TInt32 | omitempty: true | ignore: false
			if v.One1TInt32 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1i32")
				encoder.AppendInt32(v.One1TInt32)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TInt64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_int64 | kind: Int64Kind | GoName: One1TInt64 | omitempty: true | ignore: false
			if v.One1TInt64 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1i64")
				encoder.AppendInt64(v.One1TInt64)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TUint32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_uint32 | kind: Uint32Kind | GoName: One1TUint32 | omitempty: true | ignore: false
			if v.One1TUint32 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1u32")
				encoder.AppendUint32(v.One1TUint32)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TUint64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_uint64 | kind: Uint64Kind | GoName: One1TUint64 | omitempty: true | ignore: false
			if v.One1TUint64 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1u64")
				encoder.AppendUint64(v.One1TUint64)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TSint32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_sint32 | kind: Sint32Kind | GoName: One1TSint32 | omitempty: true | ignore: false
			if v.One1TSint32 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1si32")
				encoder.AppendInt32(v.One1TSint32)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TSint64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_sint64 | kind: Sint64Kind | GoName: One1TSint64 | omitempty: true | ignore: false
			if v.One1TSint64 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1si64")
				encoder.AppendInt64(v.One1TSint64)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TSfixed32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_sfixed32 | kind: Sfixed32Kind | GoName: One1TSfixed32 | omitempty: true | ignore: false
			if v.One1TSfixed32 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1sf32")
				encoder.AppendInt32(v.One1TSfixed32)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TSfixed64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_sfixed64 | kind: Sfixed64Kind | GoName: One1TSfixed64 | omitempty: true | ignore: false
			if v.One1TSfixed64 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1sf64")
				encoder.AppendInt64(v.One1TSfixed64)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TFixed32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_fixed32 | kind: Fixed32Kind | GoName: One1TFixed32 | omitempty: true | ignore: false
			if v.One1TFixed32 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1fi32")
				encoder.AppendUint32(v.One1TFixed32)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TFixed64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_fixed64 | kind: Fixed64Kind | GoName: One1TFixed64 | omitempty: true | ignore: false
			if v.One1TFixed64 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1fi64")
				encoder.AppendUint64(v.One1TFixed64)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TFloat:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_float | kind: FloatKind | GoName: One1TFloat | omitempty: true | ignore: false
			if v.One1TFloat != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1tf")
				encoder.AppendFloat32(v.One1TFloat)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TDouble:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_double | kind: DoubleKind | GoName: One1TDouble | omitempty: true | ignore: false
			if v.One1TDouble != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1df")
				encoder.AppendFloat64(v.One1TDouble)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TBool:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_bool | kind: BoolKind | GoName: One1TBool | omitempty: true | ignore: false
			if v.One1TBool {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1bl")
				encoder.AppendBool(v.One1TBool)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TEnum1:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_enum1 | kind: EnumKind | GoName: One1TEnum1 | omitempty: true | ignore: false
			if v.One1TEnum1 != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1e1")
				encoder.AppendInt32(int32(v.One1TEnum1.Number()))
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TEnum2:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_enum2 | kind: EnumKind | GoName: One1TEnum2 | omitempty: true | ignore: false
			encoder.AppendObjectKey("dt1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("o1e2")
			encoder.AppendString(v.One1TEnum2.String())
			encoder.AppendObjectEnd()
		case *FieldCustomName_One1TBytes:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_bytes | kind: BytesKind | GoName: One1TBytes | omitempty: true | ignore: false
			if len(v.One1TBytes) != 0 {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1tb")
				encoder.AppendBytes(v.One1TBytes)
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TAliases:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_aliases | kind: MessageKind | GoName: One1TAliases | omitempty: true | ignore: false
			if v.One1TAliases != nil {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1ta")
				err = encoder.AppendInterface(v.One1TAliases)
				if err != nil {
					return nil, err
				}
				encoder.AppendObjectEnd()
			}
		case *FieldCustomName_One1TConfig:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one1_t_config | kind: MessageKind | GoName: One1TConfig | omitempty: true | ignore: false
			if v.One1TConfig != nil {
				encoder.AppendObjectKey("dt1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("o1tc")
				err = encoder.AppendInterface(v.One1TConfig)
				if err != nil {
					return nil, err
				}
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt1, goName: DataType1, field: gojsontest.FieldCustomName.DataType1", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldCustomName.DataType2 | GoName: DataType2 | omitempty: true | ignore: false
	if this.DataType2 != nil {
		switch v := this.DataType2.(type) {
		case *FieldCustomName_One2TString:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_string | kind: StringKind | GoName: One2TString | omitempty: true | ignore: false
			if v.One2TString != "" {
				encoder.AppendObjectKey("o2ts")
				encoder.AppendString(v.One2TString)
			}
		case *FieldCustomName_One2TInt32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_int32 | kind: Int32Kind | GoName: One2TInt32 | omitempty: true | ignore: false
			if v.One2TInt32 != 0 {
				encoder.AppendObjectKey("o2i32")
				encoder.AppendInt32(v.One2TInt32)
			}
		case *FieldCustomName_One2TInt64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_int64 | kind: Int64Kind | GoName: One2TInt64 | omitempty: true | ignore: false
			if v.One2TInt64 != 0 {
				encoder.AppendObjectKey("o2i64")
				encoder.AppendInt64(v.One2TInt64)
			}
		case *FieldCustomName_One2TUint32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_uint32 | kind: Uint32Kind | GoName: One2TUint32 | omitempty: true | ignore: false
			if v.One2TUint32 != 0 {
				encoder.AppendObjectKey("o2u32")
				encoder.AppendUint32(v.One2TUint32)
			}
		case *FieldCustomName_One2TUint64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_uint64 | kind: Uint64Kind | GoName: One2TUint64 | omitempty: true | ignore: false
			if v.One2TUint64 != 0 {
				encoder.AppendObjectKey("o2u64")
				encoder.AppendUint64(v.One2TUint64)
			}
		case *FieldCustomName_One2TSint32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_sint32 | kind: Sint32Kind | GoName: One2TSint32 | omitempty: true | ignore: false
			if v.One2TSint32 != 0 {
				encoder.AppendObjectKey("o2si32")
				encoder.AppendInt32(v.One2TSint32)
			}
		case *FieldCustomName_One2TSint64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_sint64 | kind: Sint64Kind | GoName: One2TSint64 | omitempty: true | ignore: false
			if v.One2TSint64 != 0 {
				encoder.AppendObjectKey("o2si64")
				encoder.AppendInt64(v.One2TSint64)
			}
		case *FieldCustomName_One2TSfixed32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_sfixed32 | kind: Sfixed32Kind | GoName: One2TSfixed32 | omitempty: true | ignore: false
			if v.One2TSfixed32 != 0 {
				encoder.AppendObjectKey("o2sf32")
				encoder.AppendInt32(v.One2TSfixed32)
			}
		case *FieldCustomName_One2TSfixed64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_sfixed64 | kind: Sfixed64Kind | GoName: One2TSfixed64 | omitempty: true | ignore: false
			if v.One2TSfixed64 != 0 {
				encoder.AppendObjectKey("o2sf64")
				encoder.AppendInt64(v.One2TSfixed64)
			}
		case *FieldCustomName_One2TFixed32:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_fixed32 | kind: Fixed32Kind | GoName: One2TFixed32 | omitempty: true | ignore: false
			if v.One2TFixed32 != 0 {
				encoder.AppendObjectKey("o2fi32")
				encoder.AppendUint32(v.One2TFixed32)
			}
		case *FieldCustomName_One2TFixed64:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_fixed64 | kind: Fixed64Kind | GoName: One2TFixed64 | omitempty: true | ignore: false
			if v.One2TFixed64 != 0 {
				encoder.AppendObjectKey("o2fi64")
				encoder.AppendUint64(v.One2TFixed64)
			}
		case *FieldCustomName_One2TFloat:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_float | kind: FloatKind | GoName: One2TFloat | omitempty: true | ignore: false
			if v.One2TFloat != 0 {
				encoder.AppendObjectKey("o2tf")
				encoder.AppendFloat32(v.One2TFloat)
			}
		case *FieldCustomName_One2TDouble:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_double | kind: DoubleKind | GoName: One2TDouble | omitempty: true | ignore: false
			if v.One2TDouble != 0 {
				encoder.AppendObjectKey("o2df")
				encoder.AppendFloat64(v.One2TDouble)
			}
		case *FieldCustomName_One2TBool:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_bool | kind: BoolKind | GoName: One2TBool | omitempty: true | ignore: false
			if v.One2TBool {
				encoder.AppendObjectKey("o2bl")
				encoder.AppendBool(v.One2TBool)
			}
		case *FieldCustomName_One2TEnum1:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_enum1 | kind: EnumKind | GoName: One2TEnum1 | omitempty: true | ignore: false
			if v.One2TEnum1 != 0 {
				encoder.AppendObjectKey("o2e1")
				encoder.AppendInt32(int32(v.One2TEnum1.Number()))
			}
		case *FieldCustomName_One2TEnum2:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_enum2 | kind: EnumKind | GoName: One2TEnum2 | omitempty: true | ignore: false
			encoder.AppendObjectKey("o2e2")
			encoder.AppendString(v.One2TEnum2.String())
		case *FieldCustomName_One2TBytes:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_bytes | kind: BytesKind | GoName: One2TBytes | omitempty: true | ignore: false
			if len(v.One2TBytes) != 0 {
				encoder.AppendObjectKey("o2tb")
				encoder.AppendBytes(v.One2TBytes)
			}
		case *FieldCustomName_One2TAliases:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_aliases | kind: MessageKind | GoName: One2TAliases | omitempty: true | ignore: false
			if v.One2TAliases != nil {
				encoder.AppendObjectKey("o2ta")
				err = encoder.AppendInterface(v.One2TAliases)
				if err != nil {
					return nil, err
				}
			}
		case *FieldCustomName_One2TConfig:
			// encode filed type of basic; | field: gojsontest.FieldCustomName.one2_t_config | kind: MessageKind | GoName: One2TConfig | omitempty: true | ignore: false
			if v.One2TConfig != nil {
				encoder.AppendObjectKey("o2tc")
				err = encoder.AppendInterface(v.One2TConfig)
				if err != nil {
					return nil, err
				}
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt2, goName: DataType2, field: gojsontest.FieldCustomName.DataType2", v)
		}
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldCustomName) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldCustomName) is nil")
	}
	var oneofDataType1isStore bool
	var oneofDataType2isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ts":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_string | kind: StringKind | GoName: TString
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString = x
		case objKey == "ti32":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_int32 | kind: Int32Kind | GoName: TInt32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TInt32 = x
		case objKey == "ti64":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_int64 | kind: Int64Kind | GoName: TInt64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TInt64 = x
		case objKey == "tu32":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_uint32 | kind: Uint32Kind | GoName: TUint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TUint32 = x
		case objKey == "tu64":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_uint64 | kind: Uint64Kind | GoName: TUint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TUint64 = x
		case objKey == "tsi32":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_sint32 | kind: Sint32Kind | GoName: TSint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSint32 = x
		case objKey == "tsi64":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_sint64 | kind: Sint64Kind | GoName: TSint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSint64 = x
		case objKey == "tsf32":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSfixed32 = x
		case objKey == "tsf64":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSfixed64 = x
		case objKey == "tfi32":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TFixed32 = x
		case objKey == "tfi64":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TFixed64 = x
		case objKey == "tfl":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_float | kind: FloatKind | GoName: TFloat
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
			}
			this.TFloat = x
		case objKey == "tdl":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_double | kind: DoubleKind | GoName: TDouble
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TDouble = x
		case objKey == "tbl":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_bool | kind: BoolKind | GoName: TBool
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			this.TBool = x
		case objKey == "te1":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_enum1 | kind: EnumKind | GoName: TEnum1
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type FieldCustomName_Enum", string(value), objKey)
			}
			_, ok := FieldCustomName_Enum_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := FieldCustomName_Enum(x1)
			this.TEnum1 = x
		case objKey == "te2":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_enum2 | kind: EnumKind | GoName: TEnum2
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type FieldCustomName_Enum", string(value), objKey)
			}
			x1, ok := FieldCustomName_Enum_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := FieldCustomName_Enum(x1)
			this.TEnum2 = x
		case objKey == "tbs":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_bytes | kind: BytesKind | GoName: TBytes
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.TBytes = x
		case objKey == "ta":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_aliases | kind: MessageKind | GoName: TAliases
			value := decoder.ReadItem()
			var x *FieldCustomName_Aliases
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TAliases == nil {
					x = new(FieldCustomName_Aliases)
				} else {
					x = this.TAliases
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TAliases = x
		case objKey == "tc":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.t_config | kind: MessageKind | GoName: TConfig
			value := decoder.ReadItem()
			var x *FieldCustomName_Config
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TConfig == nil {
					x = new(FieldCustomName_Config)
				} else {
					x = this.TConfig
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TConfig = x
		case objKey == "adl":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_double | kind: DoubleKind | GoName: ArrayDouble
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), objKey)
				} else {
					this.ArrayDouble = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), objKey)
				}
				if this.ArrayDouble == nil {
					this.ArrayDouble = make([]float64, 0)
				}
				i := 0
				length := len(this.ArrayDouble)
			LOOP_LIST_adl:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_adl
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []float64", string(value), objKey)
					}
					if i < length {
						this.ArrayDouble[i] = x
					} else {
						this.ArrayDouble = append(this.ArrayDouble, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_adl
					}
				}
				if i < length {
					this.ArrayDouble = this.ArrayDouble[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "afl":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_float | kind: FloatKind | GoName: ArrayFloat
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), objKey)
				} else {
					this.ArrayFloat = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), objKey)
				}
				if this.ArrayFloat == nil {
					this.ArrayFloat = make([]float32, 0)
				}
				i := 0
				length := len(this.ArrayFloat)
			LOOP_LIST_afl:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_afl
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []float32", string(value), objKey)
					}
					if i < length {
						this.ArrayFloat[i] = x
					} else {
						this.ArrayFloat = append(this.ArrayFloat, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_afl
					}
				}
				if i < length {
					this.ArrayFloat = this.ArrayFloat[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "ai32":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_int32 | kind: Int32Kind | GoName: ArrayInt32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArrayInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArrayInt32 == nil {
					this.ArrayInt32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArrayInt32)
			LOOP_LIST_ai32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_ai32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArrayInt32[i] = x
					} else {
						this.ArrayInt32 = append(this.ArrayInt32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_ai32
					}
				}
				if i < length {
					this.ArrayInt32 = this.ArrayInt32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "ai64":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_int64 | kind: Int64Kind | GoName: ArrayInt64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArrayInt64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArrayInt64 == nil {
					this.ArrayInt64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArrayInt64)
			LOOP_LIST_ai64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_ai64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArrayInt64[i] = x
					} else {
						this.ArrayInt64 = append(this.ArrayInt64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_ai64
					}
				}
				if i < length {
					this.ArrayInt64 = this.ArrayInt64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "au32":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_uint32 | kind: Uint32Kind | GoName: ArrayUint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				} else {
					this.ArrayUint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				}
				if this.ArrayUint32 == nil {
					this.ArrayUint32 = make([]uint32, 0)
				}
				i := 0
				length := len(this.ArrayUint32)
			LOOP_LIST_au32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_au32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint32", string(value), objKey)
					}
					if i < length {
						this.ArrayUint32[i] = x
					} else {
						this.ArrayUint32 = append(this.ArrayUint32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_au32
					}
				}
				if i < length {
					this.ArrayUint32 = this.ArrayUint32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "au64":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_uint64 | kind: Uint64Kind | GoName: ArrayUint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				} else {
					this.ArrayUint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				}
				if this.ArrayUint64 == nil {
					this.ArrayUint64 = make([]uint64, 0)
				}
				i := 0
				length := len(this.ArrayUint64)
			LOOP_LIST_au64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_au64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint64", string(value), objKey)
					}
					if i < length {
						this.ArrayUint64[i] = x
					} else {
						this.ArrayUint64 = append(this.ArrayUint64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_au64
					}
				}
				if i < length {
					this.ArrayUint64 = this.ArrayUint64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "asi32":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_sint32 | kind: Sint32Kind | GoName: ArraySint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArraySint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArraySint32 == nil {
					this.ArraySint32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArraySint32)
			LOOP_LIST_asi32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_asi32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArraySint32[i] = x
					} else {
						this.ArraySint32 = append(this.ArraySint32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_asi32
					}
				}
				if i < length {
					this.ArraySint32 = this.ArraySint32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "asi64":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_sint64 | kind: Sint64Kind | GoName: ArraySint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArraySint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArraySint64 == nil {
					this.ArraySint64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArraySint64)
			LOOP_LIST_asi64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_asi64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArraySint64[i] = x
					} else {
						this.ArraySint64 = append(this.ArraySint64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_asi64
					}
				}
				if i < length {
					this.ArraySint64 = this.ArraySint64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "asf32":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_sfixed32 | kind: Sfixed32Kind | GoName: ArraySfixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArraySfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArraySfixed32 == nil {
					this.ArraySfixed32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArraySfixed32)
			LOOP_LIST_asf32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_asf32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArraySfixed32[i] = x
					} else {
						this.ArraySfixed32 = append(this.ArraySfixed32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_asf32
					}
				}
				if i < length {
					this.ArraySfixed32 = this.ArraySfixed32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "asf64":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_sfixed64 | kind: Sfixed64Kind | GoName: ArraySfixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArraySfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArraySfixed64 == nil {
					this.ArraySfixed64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArraySfixed64)
			LOOP_LIST_asf64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_asf64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArraySfixed64[i] = x
					} else {
						this.ArraySfixed64 = append(this.ArraySfixed64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_asf64
					}
				}
				if i < length {
					this.ArraySfixed64 = this.ArraySfixed64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "afi32":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_fixed32 | kind: Fixed32Kind | GoName: ArrayFixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				} else {
					this.ArrayFixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				}
				if this.ArrayFixed32 == nil {
					this.ArrayFixed32 = make([]uint32, 0)
				}
				i := 0
				length := len(this.ArrayFixed32)
			LOOP_LIST_afi32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_afi32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint32", string(value), objKey)
					}
					if i < length {
						this.ArrayFixed32[i] = x
					} else {
						this.ArrayFixed32 = append(this.ArrayFixed32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_afi32
					}
				}
				if i < length {
					this.ArrayFixed32 = this.ArrayFixed32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "afi64":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_fixed64 | kind: Fixed64Kind | GoName: ArrayFixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				} else {
					this.ArrayFixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				}
				if this.ArrayFixed64 == nil {
					this.ArrayFixed64 = make([]uint64, 0)
				}
				i := 0
				length := len(this.ArrayFixed64)
			LOOP_LIST_afi64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_afi64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint64", string(value), objKey)
					}
					if i < length {
						this.ArrayFixed64[i] = x
					} else {
						this.ArrayFixed64 = append(this.ArrayFixed64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_afi64
					}
				}
				if i < length {
					this.ArrayFixed64 = this.ArrayFixed64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "abl":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_bool | kind: BoolKind | GoName: ArrayBool
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), objKey)
				} else {
					this.ArrayBool = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), objKey)
				}
				if this.ArrayBool == nil {
					this.ArrayBool = make([]bool, 0)
				}
				i := 0
				length := len(this.ArrayBool)
			LOOP_LIST_abl:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_abl
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseBool(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []bool", string(value), objKey)
					}
					if i < length {
						this.ArrayBool[i] = x
					} else {
						this.ArrayBool = append(this.ArrayBool, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_abl
					}
				}
				if i < length {
					this.ArrayBool = this.ArrayBool[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "as":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_string | kind: StringKind | GoName: ArrayString
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString == nil {
					this.ArrayString = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString)
			LOOP_LIST_as:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_as
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString[i] = x
					} else {
						this.ArrayString = append(this.ArrayString, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_as
					}
				}
				if i < length {
					this.ArrayString = this.ArrayString[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "abs":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_bytes | kind: BytesKind | GoName: ArrayBytes
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes == nil {
					this.ArrayBytes = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes)
			LOOP_LIST_abs:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_abs
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes[i] = x
					} else {
						this.ArrayBytes = append(this.ArrayBytes, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_abs
					}
				}
				if i < length {
					this.ArrayBytes = this.ArrayBytes[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "ae1":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_enum1 | kind: EnumKind | GoName: ArrayEnum1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []FieldCustomName_Enum", string(value), objKey)
				} else {
					this.ArrayEnum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []FieldCustomName_Enum", string(value), objKey)
				}
				if this.ArrayEnum1 == nil {
					this.ArrayEnum1 = make([]FieldCustomName_Enum, 0)
				}
				i := 0
				length := len(this.ArrayEnum1)
			LOOP_LIST_ae1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_ae1
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []FieldCustomName_Enum", string(value), objKey)
					}
					_, ok := FieldCustomName_Enum_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := FieldCustomName_Enum(x1)
					if i < length {
						this.ArrayEnum1[i] = x
					} else {
						this.ArrayEnum1 = append(this.ArrayEnum1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_ae1
					}
				}
				if i < length {
					this.ArrayEnum1 = this.ArrayEnum1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "ae2":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_enum2 | kind: EnumKind | GoName: ArrayEnum2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []FieldCustomName_Enum", string(value), objKey)
				} else {
					this.ArrayEnum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []FieldCustomName_Enum", string(value), objKey)
				}
				if this.ArrayEnum2 == nil {
					this.ArrayEnum2 = make([]FieldCustomName_Enum, 0)
				}
				i := 0
				length := len(this.ArrayEnum2)
			LOOP_LIST_ae2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_ae2
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []FieldCustomName_Enum", string(value), objKey)
					}
					x1, ok := FieldCustomName_Enum_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := FieldCustomName_Enum(x1)
					if i < length {
						this.ArrayEnum2[i] = x
					} else {
						this.ArrayEnum2 = append(this.ArrayEnum2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_ae2
					}
				}
				if i < length {
					this.ArrayEnum2 = this.ArrayEnum2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "aa":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_aliases | kind: MessageKind | GoName: ArrayAliases
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*FieldCustomName_Aliases", string(value), objKey)
				} else {
					this.ArrayAliases = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*FieldCustomName_Aliases", string(value), objKey)
				}
				if this.ArrayAliases == nil {
					this.ArrayAliases = make([]*FieldCustomName_Aliases, 0)
				}
				i := 0
				length := len(this.ArrayAliases)
			LOOP_LIST_aa:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_aa
					}
					value := decoder.ReadItem()
					var x *FieldCustomName_Aliases
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayAliases[i]
						}
						if x == nil {
							x = new(FieldCustomName_Aliases)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayAliases[i] = x
					} else {
						this.ArrayAliases = append(this.ArrayAliases, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_aa
					}
				}
				if i < length {
					this.ArrayAliases = this.ArrayAliases[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "ac":
			// decode filed type of list; | field: gojsontest.FieldCustomName.array_config | kind: MessageKind | GoName: ArrayConfig
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*FieldCustomName_Config", string(value), objKey)
				} else {
					this.ArrayConfig = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*FieldCustomName_Config", string(value), objKey)
				}
				if this.ArrayConfig == nil {
					this.ArrayConfig = make([]*FieldCustomName_Config, 0)
				}
				i := 0
				length := len(this.ArrayConfig)
			LOOP_LIST_ac:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_ac
					}
					value := decoder.ReadItem()
					var x *FieldCustomName_Config
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayConfig[i]
						}
						if x == nil {
							x = new(FieldCustomName_Config)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayConfig[i] = x
					} else {
						this.ArrayConfig = append(this.ArrayConfig, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_ac
					}
				}
				if i < length {
					this.ArrayConfig = this.ArrayConfig[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "m32dl":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_double | keyKind: Int32Kind | valueKind: DoubleKind | goName: MapInt32Double
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float64", string(value), objKey)
				} else {
					this.MapInt32Double = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float64", string(value), objKey)
				}
				if this.MapInt32Double == nil { // create map if not initialized.
					this.MapInt32Double = make(map[int32]float64)
				}
			LOOP_MAP_m32dl:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32dl
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]float64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]float64", string(value), objKey)
					}
					this.MapInt32Double[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32dl
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32fl":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_float | keyKind: Int32Kind | valueKind: FloatKind | goName: MapInt32Float
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float32", string(value), objKey)
				} else {
					this.MapInt32Float = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float32", string(value), objKey)
				}
				if this.MapInt32Float == nil { // create map if not initialized.
					this.MapInt32Float = make(map[int32]float32)
				}
			LOOP_MAP_m32fl:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32fl
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]float32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]float32", string(value), objKey)
					}
					this.MapInt32Float[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32fl
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_int32 | keyKind: Int32Kind | valueKind: Int32Kind | goName: MapInt32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Int32 == nil { // create map if not initialized.
					this.MapInt32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_m32i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32i32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32i64":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_int64 | keyKind: Int32Kind | valueKind: Int64Kind | goName: MapInt32Int64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Int64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Int64 == nil { // create map if not initialized.
					this.MapInt32Int64 = make(map[int32]int64)
				}
			LOOP_MAP_m32i64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32i64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Int64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32i64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32u32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_uint32 | keyKind: Int32Kind | valueKind: Uint32Kind | goName: MapInt32Uint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				} else {
					this.MapInt32Uint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				}
				if this.MapInt32Uint32 == nil { // create map if not initialized.
					this.MapInt32Uint32 = make(map[int32]uint32)
				}
			LOOP_MAP_m32u32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32u32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint32", string(value), objKey)
					}
					this.MapInt32Uint32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32u32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32u64":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_uint64 | keyKind: Int32Kind | valueKind: Uint64Kind | goName: MapInt32Uint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				} else {
					this.MapInt32Uint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				}
				if this.MapInt32Uint64 == nil { // create map if not initialized.
					this.MapInt32Uint64 = make(map[int32]uint64)
				}
			LOOP_MAP_m32u64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32u64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint64", string(value), objKey)
					}
					this.MapInt32Uint64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32u64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32si32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_sint32 | keyKind: Int32Kind | valueKind: Sint32Kind | goName: MapInt32Sint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Sint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Sint32 == nil { // create map if not initialized.
					this.MapInt32Sint32 = make(map[int32]int32)
				}
			LOOP_MAP_m32si32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32si32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Sint32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32si32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32si64":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_sint64 | keyKind: Int32Kind | valueKind: Sint64Kind | goName: MapInt32Sint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Sint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Sint64 == nil { // create map if not initialized.
					this.MapInt32Sint64 = make(map[int32]int64)
				}
			LOOP_MAP_m32si64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32si64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Sint64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32si64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32sf32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_sfixed32 | keyKind: Int32Kind | valueKind: Sfixed32Kind | goName: MapInt32Sfixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Sfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Sfixed32 == nil { // create map if not initialized.
					this.MapInt32Sfixed32 = make(map[int32]int32)
				}
			LOOP_MAP_m32sf32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32sf32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Sfixed32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32sf32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32sf64":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_sfixed64 | keyKind: Int32Kind | valueKind: Sfixed64Kind | goName: MapInt32Sfixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Sfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Sfixed64 == nil { // create map if not initialized.
					this.MapInt32Sfixed64 = make(map[int32]int64)
				}
			LOOP_MAP_m32sf64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32sf64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Sfixed64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32sf64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32fi32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_fixed32 | keyKind: Int32Kind | valueKind: Fixed32Kind | goName: MapInt32Fixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				} else {
					this.MapInt32Fixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				}
				if this.MapInt32Fixed32 == nil { // create map if not initialized.
					this.MapInt32Fixed32 = make(map[int32]uint32)
				}
			LOOP_MAP_m32fi32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32fi32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint32", string(value), objKey)
					}
					this.MapInt32Fixed32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32fi32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32fi64":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_fixed64 | keyKind: Int32Kind | valueKind: Fixed64Kind | goName: MapInt32Fixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				} else {
					this.MapInt32Fixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				}
				if this.MapInt32Fixed64 == nil { // create map if not initialized.
					this.MapInt32Fixed64 = make(map[int32]uint64)
				}
			LOOP_MAP_m32fi64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32fi64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint64", string(value), objKey)
					}
					this.MapInt32Fixed64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32fi64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32bl":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_bool | keyKind: Int32Kind | valueKind: BoolKind | goName: MapInt32Bool
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]bool", string(value), objKey)
				} else {
					this.MapInt32Bool = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]bool", string(value), objKey)
				}
				if this.MapInt32Bool == nil { // create map if not initialized.
					this.MapInt32Bool = make(map[int32]bool)
				}
			LOOP_MAP_m32bl:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32bl
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]bool", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseBool(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]bool", string(value), objKey)
					}
					this.MapInt32Bool[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32bl
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32s":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_string | keyKind: Int32Kind | valueKind: StringKind | goName: MapInt32String
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]string", string(value), objKey)
				} else {
					this.MapInt32String = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]string", string(value), objKey)
				}
				if this.MapInt32String == nil { // create map if not initialized.
					this.MapInt32String = make(map[int32]string)
				}
			LOOP_MAP_m32s:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32s
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]string", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]string", string(value), objKey)
						}
					}
					this.MapInt32String[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32s
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32b":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_bytes | keyKind: Int32Kind | valueKind: BytesKind | goName: MapInt32Bytes
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32][]byte", string(value), objKey)
				} else {
					this.MapInt32Bytes = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32][]byte", string(value), objKey)
				}
				if this.MapInt32Bytes == nil { // create map if not initialized.
					this.MapInt32Bytes = make(map[int32][]byte)
				}
			LOOP_MAP_m32b:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32b
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32][]byte", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapInt32Bytes[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32b
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32e1":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_enum1 | keyKind: Int32Kind | valueKind: EnumKind | goName: MapInt32Enum1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]FieldCustomName_Enum", string(value), objKey)
				} else {
					this.MapInt32Enum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]FieldCustomName_Enum", string(value), objKey)
				}
				if this.MapInt32Enum1 == nil { // create map if not initialized.
					this.MapInt32Enum1 = make(map[int32]FieldCustomName_Enum)
				}
			LOOP_MAP_m32e1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32e1
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]FieldCustomName_Enum", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]FieldCustomName_Enum", string(value), objKey)
					}
					_, ok := FieldCustomName_Enum_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := FieldCustomName_Enum(x1)
					this.MapInt32Enum1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32e1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32e2":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_enum2 | keyKind: Int32Kind | valueKind: EnumKind | goName: MapInt32Enum2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]FieldCustomName_Enum", string(value), objKey)
				} else {
					this.MapInt32Enum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]FieldCustomName_Enum", string(value), objKey)
				}
				if this.MapInt32Enum2 == nil { // create map if not initialized.
					this.MapInt32Enum2 = make(map[int32]FieldCustomName_Enum)
				}
			LOOP_MAP_m32e2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32e2
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]FieldCustomName_Enum", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]FieldCustomName_Enum", string(value), objKey)
					}
					x1, ok := FieldCustomName_Enum_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := FieldCustomName_Enum(x1)
					this.MapInt32Enum2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32e2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32a":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_aliases | keyKind: Int32Kind | valueKind: MessageKind | goName: MapInt32Aliases
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*FieldCustomName_Aliases", string(value), objKey)
				} else {
					this.MapInt32Aliases = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*FieldCustomName_Aliases", string(value), objKey)
				}
				if this.MapInt32Aliases == nil { // create map if not initialized.
					this.MapInt32Aliases = make(map[int32]*FieldCustomName_Aliases)
				}
			LOOP_MAP_m32a:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32a
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]*FieldCustomName_Aliases", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *FieldCustomName_Aliases
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapInt32Aliases[mapKey]
						if x == nil {
							x = new(FieldCustomName_Aliases)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapInt32Aliases[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32a
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m32c":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int32_config | keyKind: Int32Kind | valueKind: MessageKind | goName: MapInt32Config
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*FieldCustomName_Config", string(value), objKey)
				} else {
					this.MapInt32Config = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*FieldCustomName_Config", string(value), objKey)
				}
				if this.MapInt32Config == nil { // create map if not initialized.
					this.MapInt32Config = make(map[int32]*FieldCustomName_Config)
				}
			LOOP_MAP_m32c:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m32c
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]*FieldCustomName_Config", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *FieldCustomName_Config
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapInt32Config[mapKey]
						if x == nil {
							x = new(FieldCustomName_Config)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapInt32Config[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m32c
					}
				}
				decoder.ScanNext()
			}
		case objKey == "mi64i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_int64_int32 | keyKind: Int64Kind | valueKind: Int32Kind | goName: MapInt64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapInt64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapInt64Int32 == nil { // create map if not initialized.
					this.MapInt64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_mi64i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_mi64i32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapInt64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_mi64i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "mu32i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_uint32_int32 | keyKind: Uint32Kind | valueKind: Int32Kind | goName: MapUint32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				} else {
					this.MapUint32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				}
				if this.MapUint32Int32 == nil { // create map if not initialized.
					this.MapUint32Int32 = make(map[uint32]int32)
				}
			LOOP_MAP_mu32i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_mu32i32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseUint(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint32]int32", key, objKey)
					}
					mapKey := uint32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint32]int32", string(value), objKey)
					}
					this.MapUint32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_mu32i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "mu64i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_uint64_int32 | keyKind: Uint64Kind | valueKind: Int32Kind | goName: MapUint64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				} else {
					this.MapUint64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				}
				if this.MapUint64Int32 == nil { // create map if not initialized.
					this.MapUint64Int32 = make(map[uint64]int32)
				}
			LOOP_MAP_mu64i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_mu64i32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseUint(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint64]int32", string(value), objKey)
					}
					this.MapUint64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_mu64i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "ms32i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_sint32_int32 | keyKind: Sint32Kind | valueKind: Int32Kind | goName: MapSint32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapSint32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapSint32Int32 == nil { // create map if not initialized.
					this.MapSint32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_ms32i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_ms32i32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapSint32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_ms32i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "ms64i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_sint64_int32 | keyKind: Sint64Kind | valueKind: Int32Kind | goName: MapSint64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapSint64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapSint64Int32 == nil { // create map if not initialized.
					this.MapSint64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_ms64i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_ms64i32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapSint64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_ms64i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "mf32i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_fixed32_int32 | keyKind: Fixed32Kind | valueKind: Int32Kind | goName: MapFixed32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				} else {
					this.MapFixed32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				}
				if this.MapFixed32Int32 == nil { // create map if not initialized.
					this.MapFixed32Int32 = make(map[uint32]int32)
				}
			LOOP_MAP_mf32i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_mf32i32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseUint(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint32]int32", key, objKey)
					}
					mapKey := uint32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint32]int32", string(value), objKey)
					}
					this.MapFixed32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_mf32i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "mf64i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_fixed64_int32 | keyKind: Fixed64Kind | valueKind: Int32Kind | goName: MapFixed64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				} else {
					this.MapFixed64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				}
				if this.MapFixed64Int32 == nil { // create map if not initialized.
					this.MapFixed64Int32 = make(map[uint64]int32)
				}
			LOOP_MAP_mf64i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_mf64i32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseUint(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint64]int32", string(value), objKey)
					}
					this.MapFixed64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_mf64i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "msf32i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_sfixed32_int32 | keyKind: Sfixed32Kind | valueKind: Int32Kind | goName: MapSfixed32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapSfixed32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapSfixed32Int32 == nil { // create map if not initialized.
					this.MapSfixed32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_msf32i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_msf32i32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapSfixed32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_msf32i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "msf64i32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_sfixed64_int32 | keyKind: Sfixed64Kind | valueKind: Int32Kind | goName: MapSfixed64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapSfixed64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapSfixed64Int32 == nil { // create map if not initialized.
					this.MapSfixed64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_msf64i32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_msf64i32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapSfixed64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_msf64i32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "msi32":
			// decode filed type of map; | field: gojsontest.FieldCustomName.map_string_int32 | keyKind: StringKind | valueKind: Int32Kind | goName: MapStringInt32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				} else {
					this.MapStringInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				}
				if this.MapStringInt32 == nil { // create map if not initialized.
					this.MapStringInt32 = make(map[string]int32)
				}
			LOOP_MAP_msi32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_msi32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]int32", string(value), objKey)
					}
					this.MapStringInt32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_msi32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt1":
			// decode filed type of oneof; | field: gojsontest.FieldCustomName.DataType1 | GoName: DataType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dt1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "o1ts":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TString)
						ot.One1TString = x
						this.DataType1 = ot
					case oneofKey == "o1i32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TInt32)
						ot.One1TInt32 = x
						this.DataType1 = ot
					case oneofKey == "o1i64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TInt64)
						ot.One1TInt64 = x
						this.DataType1 = ot
					case oneofKey == "o1u32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TUint32)
						ot.One1TUint32 = x
						this.DataType1 = ot
					case oneofKey == "o1u64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TUint64)
						ot.One1TUint64 = x
						this.DataType1 = ot
					case oneofKey == "o1si32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TSint32)
						ot.One1TSint32 = x
						this.DataType1 = ot
					case oneofKey == "o1si64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TSint64)
						ot.One1TSint64 = x
						this.DataType1 = ot
					case oneofKey == "o1sf32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TSfixed32)
						ot.One1TSfixed32 = x
						this.DataType1 = ot
					case oneofKey == "o1sf64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TSfixed64)
						ot.One1TSfixed64 = x
						this.DataType1 = ot
					case oneofKey == "o1fi32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TFixed32)
						ot.One1TFixed32 = x
						this.DataType1 = ot
					case oneofKey == "o1fi64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TFixed64)
						ot.One1TFixed64 = x
						this.DataType1 = ot
					case oneofKey == "o1tf":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TFloat)
						ot.One1TFloat = x
						this.DataType1 = ot
					case oneofKey == "o1df":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TDouble)
						ot.One1TDouble = x
						this.DataType1 = ot
					case oneofKey == "o1bl":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TBool)
						ot.One1TBool = x
						this.DataType1 = ot
					case oneofKey == "o1e1":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type FieldCustomName_Enum", string(value), objKey)
						}
						_, ok := FieldCustomName_Enum_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := FieldCustomName_Enum(x1)
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TEnum1)
						ot.One1TEnum1 = x
						this.DataType1 = ot
					case oneofKey == "o1e2":
						value := decoder.ReadItem()
						s, ok := jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type FieldCustomName_Enum", string(value), objKey)
						}
						x1, ok := FieldCustomName_Enum_value[s]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := FieldCustomName_Enum(x1)
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TEnum2)
						ot.One1TEnum2 = x
						this.DataType1 = ot
					case oneofKey == "o1tb":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TBytes)
						ot.One1TBytes = x
						this.DataType1 = ot
					case oneofKey == "o1ta":
						value := decoder.ReadItem()
						var x *FieldCustomName_Aliases
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(FieldCustomName_Aliases)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TAliases)
						ot.One1TAliases = x
						this.DataType1 = ot
					case oneofKey == "o1tc":
						value := decoder.ReadItem()
						var x *FieldCustomName_Config
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(FieldCustomName_Config)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldCustomName_One1TConfig)
						ot.One1TConfig = x
						this.DataType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "o2ts":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TString)
			ot.One2TString = x
			this.DataType2 = ot
		case objKey == "o2i32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TInt32)
			ot.One2TInt32 = x
			this.DataType2 = ot
		case objKey == "o2i64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TInt64)
			ot.One2TInt64 = x
			this.DataType2 = ot
		case objKey == "o2u32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TUint32)
			ot.One2TUint32 = x
			this.DataType2 = ot
		case objKey == "o2u64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TUint64)
			ot.One2TUint64 = x
			this.DataType2 = ot
		case objKey == "o2si32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TSint32)
			ot.One2TSint32 = x
			this.DataType2 = ot
		case objKey == "o2si64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TSint64)
			ot.One2TSint64 = x
			this.DataType2 = ot
		case objKey == "o2sf32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TSfixed32)
			ot.One2TSfixed32 = x
			this.DataType2 = ot
		case objKey == "o2sf64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TSfixed64)
			ot.One2TSfixed64 = x
			this.DataType2 = ot
		case objKey == "o2fi32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TFixed32)
			ot.One2TFixed32 = x
			this.DataType2 = ot
		case objKey == "o2fi64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TFixed64)
			ot.One2TFixed64 = x
			this.DataType2 = ot
		case objKey == "o2tf":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TFloat)
			ot.One2TFloat = x
			this.DataType2 = ot
		case objKey == "o2df":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TDouble)
			ot.One2TDouble = x
			this.DataType2 = ot
		case objKey == "o2bl":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TBool)
			ot.One2TBool = x
			this.DataType2 = ot
		case objKey == "o2e1":
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type FieldCustomName_Enum", string(value), objKey)
			}
			_, ok := FieldCustomName_Enum_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := FieldCustomName_Enum(x1)
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TEnum1)
			ot.One2TEnum1 = x
			this.DataType2 = ot
		case objKey == "o2e2":
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type FieldCustomName_Enum", string(value), objKey)
			}
			x1, ok := FieldCustomName_Enum_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := FieldCustomName_Enum(x1)
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TEnum2)
			ot.One2TEnum2 = x
			this.DataType2 = ot
		case objKey == "o2tb":
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TBytes)
			ot.One2TBytes = x
			this.DataType2 = ot
		case objKey == "o2ta":
			value := decoder.ReadItem()
			var x *FieldCustomName_Aliases
			if value[0] != 'n' { // value[0] == 'n' means null
				x = new(FieldCustomName_Aliases)
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TAliases)
			ot.One2TAliases = x
			this.DataType2 = ot
		case objKey == "o2tc":
			value := decoder.ReadItem()
			var x *FieldCustomName_Config
			if value[0] != 'n' { // value[0] == 'n' means null
				x = new(FieldCustomName_Config)
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(FieldCustomName_One2TConfig)
			ot.One2TConfig = x
			this.DataType2 = ot
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldCustomName_Aliases) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(2)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldCustomName_Aliases) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldCustomName_Aliases) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldCustomName_Config) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(18)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.FieldCustomName.Config.ip | kind: StringKind | GoName: Ip | omitempty: false | ignore: false
	encoder.AppendObjectKey("cf")
	encoder.AppendString(this.Ip)
	// encode filed type of basic; | field: gojsontest.FieldCustomName.Config.port | kind: Int32Kind | GoName: Port | omitempty: false | ignore: false
	encoder.AppendObjectKey("cp")
	encoder.AppendInt32(this.Port)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldCustomName_Config) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldCustomName_Config) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "cf":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.Config.ip | kind: StringKind | GoName: Ip
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Ip = x
		case objKey == "cp":
			// decode filed type of basic; | field: gojsontest.FieldCustomName.Config.port | kind: Int32Kind | GoName: Port
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Port = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OneofHide1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(50)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Encode field type of oneof; | field: gojsontest.OneofHide1.data_type1 | GoName: DataType1 | omitempty: false | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *OneofHide1_One1String1:
			// encode filed type of basic; | field: gojsontest.OneofHide1.one1_string1 | kind: StringKind | GoName: One1String1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("one1_string1")
			encoder.AppendString(v.One1String1)
		case *OneofHide1_One1String2:
			// encode filed type of basic; | field: gojsontest.OneofHide1.one1_string2 | kind: StringKind | GoName: One1String2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("one1_string2")
			encoder.AppendString(v.One1String2)
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type1, goName: DataType1, field: gojsontest.OneofHide1.data_type1", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.OneofHide1.data_type2 | GoName: DataType2 | omitempty: false | ignore: false
	if this.DataType2 != nil {
		switch v := this.DataType2.(type) {
		case *OneofHide1_One2String1:
			// encode filed type of basic; | field: gojsontest.OneofHide1.one2_string1 | kind: StringKind | GoName: One2String1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("one2_string1")
			encoder.AppendString(v.One2String1)
		case *OneofHide1_One2String2:
			// encode filed type of basic; | field: gojsontest.OneofHide1.one2_string2 | kind: StringKind | GoName: One2String2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("one2_string2")
			encoder.AppendString(v.One2String2)
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type2, goName: DataType2, field: gojsontest.OneofHide1.data_type2", v)
		}
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OneofHide1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OneofHide1) is nil")
	}
	var oneofDataType1isStore bool
	var oneofDataType2isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "one1_string1":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofDataType1isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType1isStore = true
			ot := new(OneofHide1_One1String1)
			ot.One1String1 = x
			this.DataType1 = ot
		case objKey == "one1_string2":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofDataType1isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType1isStore = true
			ot := new(OneofHide1_One1String2)
			ot.One1String2 = x
			this.DataType1 = ot
		case objKey == "one2_string1":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(OneofHide1_One2String1)
			ot.One2String1 = x
			this.DataType2 = ot
		case objKey == "one2_string2":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofDataType2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType2isStore = true
			ot := new(OneofHide1_One2String2)
			ot.One2String2 = x
			this.DataType2 = ot
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OneofHide2) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(50)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Encode field type of oneof; | field: gojsontest.OneofHide2.data_type1 | GoName: DataType1 | omitempty: false | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *OneofHide2_One1String1:
			// encode filed type of basic; | field: gojsontest.OneofHide2.one1_string1 | kind: StringKind | GoName: One1String1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("one1_string1")
			encoder.AppendString(v.One1String1)
		case *OneofHide2_One1String2:
			// encode filed type of basic; | field: gojsontest.OneofHide2.one1_string2 | kind: StringKind | GoName: One1String2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("one1_string2")
			encoder.AppendString(v.One1String2)
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type1, goName: DataType1, field: gojsontest.OneofHide2.data_type1", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.OneofHide2.data_type2 | GoName: DataType2 | omitempty: false | ignore: false
	if this.DataType2 != nil {
		switch v := this.DataType2.(type) {
		case *OneofHide2_One2String1:
			// encode filed type of basic; | field: gojsontest.OneofHide2.one2_string1 | kind: StringKind | GoName: One2String1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one2_string1")
			encoder.AppendString(v.One2String1)
			encoder.AppendObjectEnd()
		case *OneofHide2_One2String2:
			// encode filed type of basic; | field: gojsontest.OneofHide2.one2_string2 | kind: StringKind | GoName: One2String2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one2_string2")
			encoder.AppendString(v.One2String2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type2, goName: DataType2, field: gojsontest.OneofHide2.data_type2", v)
		}
	} else {
		encoder.AppendObjectKey("data_type2")
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OneofHide2) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OneofHide2) is nil")
	}
	var oneofDataType1isStore bool
	var oneofDataType2isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "one1_string1":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofDataType1isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType1isStore = true
			ot := new(OneofHide2_One1String1)
			ot.One1String1 = x
			this.DataType1 = ot
		case objKey == "one1_string2":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofDataType1isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType1isStore = true
			ot := new(OneofHide2_One1String2)
			ot.One1String2 = x
			this.DataType1 = ot
		case objKey == "data_type2":
			// decode filed type of oneof; | field: gojsontest.OneofHide2.data_type2 | GoName: DataType2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_type2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one2_string1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(OneofHide2_One2String1)
						ot.One2String1 = x
						this.DataType2 = ot
					case oneofKey == "one2_string2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(OneofHide2_One2String2)
						ot.One2String2 = x
						this.DataType2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type2
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OneofHide3) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(50)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Encode field type of oneof; | field: gojsontest.OneofHide3.data_type1 | GoName: DataType1 | omitempty: false | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *OneofHide3_One1String1:
			// encode filed type of basic; | field: gojsontest.OneofHide3.one1_string1 | kind: StringKind | GoName: One1String1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("one1_string1")
			encoder.AppendString(v.One1String1)
		case *OneofHide3_One1String2:
			// encode filed type of basic; | field: gojsontest.OneofHide3.one1_string2 | kind: StringKind | GoName: One1String2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("one1_string2")
			encoder.AppendString(v.One1String2)
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type1, goName: DataType1, field: gojsontest.OneofHide3.data_type1", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.OneofHide3.data_type2 | GoName: DataType2 | omitempty: false | ignore: false
	if this.DataType2 != nil {
		switch v := this.DataType2.(type) {
		case *OneofHide3_One2String1:
			// encode filed type of basic; | field: gojsontest.OneofHide3.one2_string1 | kind: StringKind | GoName: One2String1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one2_string1")
			encoder.AppendString(v.One2String1)
			encoder.AppendObjectEnd()
		case *OneofHide3_One2String2:
			// encode filed type of basic; | field: gojsontest.OneofHide3.one2_string2 | kind: StringKind | GoName: One2String2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one2_string2")
			encoder.AppendString(v.One2String2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type2, goName: DataType2, field: gojsontest.OneofHide3.data_type2", v)
		}
	} else {
		encoder.AppendObjectKey("data_type2")
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OneofHide3) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OneofHide3) is nil")
	}
	var oneofDataType1isStore bool
	var oneofDataType2isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "one1_string1":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofDataType1isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType1isStore = true
			ot := new(OneofHide3_One1String1)
			ot.One1String1 = x
			this.DataType1 = ot
		case objKey == "one1_string2":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofDataType1isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofDataType1isStore = true
			ot := new(OneofHide3_One1String2)
			ot.One1String2 = x
			this.DataType1 = ot
		case objKey == "data_type2":
			// decode filed type of oneof; | field: gojsontest.OneofHide3.data_type2 | GoName: DataType2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_type2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one2_string1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(OneofHide3_One2String1)
						ot.One2String1 = x
						this.DataType2 = ot
					case oneofKey == "one2_string2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(OneofHide3_One2String2)
						ot.One2String2 = x
						this.DataType2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type2
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OneofHide4) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(50)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Encode field type of oneof; | field: gojsontest.OneofHide4.data_type1 | GoName: DataType1 | omitempty: false | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *OneofHide4_One1String1:
			// encode filed type of basic; | field: gojsontest.OneofHide4.one1_string1 | kind: StringKind | GoName: One1String1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one1_string1")
			encoder.AppendString(v.One1String1)
			encoder.AppendObjectEnd()
		case *OneofHide4_One1String2:
			// encode filed type of basic; | field: gojsontest.OneofHide4.one1_string2 | kind: StringKind | GoName: One1String2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one1_string2")
			encoder.AppendString(v.One1String2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type1, goName: DataType1, field: gojsontest.OneofHide4.data_type1", v)
		}
	} else {
		encoder.AppendObjectKey("data_type1")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.OneofHide4.data_type2 | GoName: DataType2 | omitempty: false | ignore: false
	if this.DataType2 != nil {
		switch v := this.DataType2.(type) {
		case *OneofHide4_One2String1:
			// encode filed type of basic; | field: gojsontest.OneofHide4.one2_string1 | kind: StringKind | GoName: One2String1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one2_string1")
			encoder.AppendString(v.One2String1)
			encoder.AppendObjectEnd()
		case *OneofHide4_One2String2:
			// encode filed type of basic; | field: gojsontest.OneofHide4.one2_string2 | kind: StringKind | GoName: One2String2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one2_string2")
			encoder.AppendString(v.One2String2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type2, goName: DataType2, field: gojsontest.OneofHide4.data_type2", v)
		}
	} else {
		encoder.AppendObjectKey("data_type2")
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OneofHide4) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OneofHide4) is nil")
	}
	var oneofDataType1isStore bool
	var oneofDataType2isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "data_type1":
			// decode filed type of oneof; | field: gojsontest.OneofHide4.data_type1 | GoName: DataType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_type1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one1_string1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(OneofHide4_One1String1)
						ot.One1String1 = x
						this.DataType1 = ot
					case oneofKey == "one1_string2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(OneofHide4_One1String2)
						ot.One1String2 = x
						this.DataType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type2":
			// decode filed type of oneof; | field: gojsontest.OneofHide4.data_type2 | GoName: DataType2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_type2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one2_string1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(OneofHide4_One2String1)
						ot.One2String1 = x
						this.DataType2 = ot
					case oneofKey == "one2_string2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(OneofHide4_One2String2)
						ot.One2String2 = x
						this.DataType2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type2
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldOmitempty1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(118)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.FieldOmitempty1.t_string1 | kind: StringKind | GoName: TString1 | omitempty: true | ignore: false
	if this.TString1 != "" {
		encoder.AppendObjectKey("t_string1")
		encoder.AppendString(this.TString1)
	}
	// encode filed type of basic; | field: gojsontest.FieldOmitempty1.t_string2 | kind: StringKind | GoName: TString2 | omitempty: true | ignore: false
	if this.TString2 != "" {
		encoder.AppendObjectKey("t_string2")
		encoder.AppendString(this.TString2)
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty1.data_type1 | GoName: DataType1 | omitempty: true | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *FieldOmitempty1_One1Int32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty1.one1_int32 | kind: Int32Kind | GoName: One1Int32 | omitempty: true | ignore: false
			if v.One1Int32 != 0 {
				encoder.AppendObjectKey("data_type1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one1_int32")
				encoder.AppendInt32(v.One1Int32)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type1, goName: DataType1, field: gojsontest.FieldOmitempty1.data_type1", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty1.data_type2 | GoName: DataType2 | omitempty: true | ignore: false
	if this.DataType2 != nil {
		switch v := this.DataType2.(type) {
		case *FieldOmitempty1_One2Int64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty1.one2_int64 | kind: Int64Kind | GoName: One2Int64 | omitempty: true | ignore: false
			if v.One2Int64 != 0 {
				encoder.AppendObjectKey("data_type2")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one2_int64")
				encoder.AppendInt64(v.One2Int64)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type2, goName: DataType2, field: gojsontest.FieldOmitempty1.data_type2", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty1.data_type3 | GoName: DataType3 | omitempty: true | ignore: false
	if this.DataType3 != nil {
		switch v := this.DataType3.(type) {
		case *FieldOmitempty1_One3Uint32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty1.one3_uint32 | kind: Uint32Kind | GoName: One3Uint32 | omitempty: true | ignore: false
			if v.One3Uint32 != 0 {
				encoder.AppendObjectKey("data_type3")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one3_uint32")
				encoder.AppendUint32(v.One3Uint32)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type3, goName: DataType3, field: gojsontest.FieldOmitempty1.data_type3", v)
		}
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldOmitempty1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldOmitempty1) is nil")
	}
	var oneofDataType1isStore bool
	var oneofDataType2isStore bool
	var oneofDataType3isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_string1":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty1.t_string1 | kind: StringKind | GoName: TString1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString1 = x
		case objKey == "t_string2":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty1.t_string2 | kind: StringKind | GoName: TString2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString2 = x
		case objKey == "data_type1":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty1.data_type1 | GoName: DataType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			LOOP_ONEOF_data_type1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one1_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldOmitempty1_One1Int32)
						ot.One1Int32 = x
						this.DataType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type2":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty1.data_type2 | GoName: DataType2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int64", string(value), objKey)
				}
			LOOP_ONEOF_data_type2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one2_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(FieldOmitempty1_One2Int64)
						ot.One2Int64 = x
						this.DataType2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type3":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty1.data_type3 | GoName: DataType3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), objKey)
				}
			LOOP_ONEOF_data_type3:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type3
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one3_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofDataType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType3isStore = true
						ot := new(FieldOmitempty1_One3Uint32)
						ot.One3Uint32 = x
						this.DataType3 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type3
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldOmitempty2) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(244)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.FieldOmitempty2.t_string1 | kind: StringKind | GoName: TString1 | omitempty: true | ignore: false
	if this.TString1 != "" {
		encoder.AppendObjectKey("t_string1")
		encoder.AppendString(this.TString1)
	}
	// encode filed type of basic; | field: gojsontest.FieldOmitempty2.t_string2 | kind: StringKind | GoName: TString2 | omitempty: true | ignore: false
	if this.TString2 != "" {
		encoder.AppendObjectKey("t_string2")
		encoder.AppendString(this.TString2)
	}
	// encode filed type of basic; | field: gojsontest.FieldOmitempty2.t_string3 | kind: StringKind | GoName: TString3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string3")
	encoder.AppendString(this.TString3)
	// encode filed type of basic; | field: gojsontest.FieldOmitempty2.t_string4 | kind: StringKind | GoName: TString4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string4")
	encoder.AppendString(this.TString4)
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty2.data_type1 | GoName: DataType1 | omitempty: true | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *FieldOmitempty2_One1Int32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty2.one1_int32 | kind: Int32Kind | GoName: One1Int32 | omitempty: true | ignore: false
			if v.One1Int32 != 0 {
				encoder.AppendObjectKey("data_type1")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one1_int32")
				encoder.AppendInt32(v.One1Int32)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type1, goName: DataType1, field: gojsontest.FieldOmitempty2.data_type1", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty2.data_type2 | GoName: DataType2 | omitempty: true | ignore: false
	if this.DataType2 != nil {
		switch v := this.DataType2.(type) {
		case *FieldOmitempty2_One2Int64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty2.one2_int64 | kind: Int64Kind | GoName: One2Int64 | omitempty: true | ignore: false
			if v.One2Int64 != 0 {
				encoder.AppendObjectKey("data_type2")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one2_int64")
				encoder.AppendInt64(v.One2Int64)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type2, goName: DataType2, field: gojsontest.FieldOmitempty2.data_type2", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty2.data_type3 | GoName: DataType3 | omitempty: true | ignore: false
	if this.DataType3 != nil {
		switch v := this.DataType3.(type) {
		case *FieldOmitempty2_One3Uint32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty2.one3_uint32 | kind: Uint32Kind | GoName: One3Uint32 | omitempty: true | ignore: false
			if v.One3Uint32 != 0 {
				encoder.AppendObjectKey("data_type3")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one3_uint32")
				encoder.AppendUint32(v.One3Uint32)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type3, goName: DataType3, field: gojsontest.FieldOmitempty2.data_type3", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty2.data_type4 | GoName: DataType4 | omitempty: false | ignore: false
	if this.DataType4 != nil {
		switch v := this.DataType4.(type) {
		case *FieldOmitempty2_One4Uint64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty2.one4_uint64 | kind: Uint64Kind | GoName: One4Uint64 | omitempty: true | ignore: false
			if v.One4Uint64 != 0 {
				encoder.AppendObjectKey("data_type4")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one4_uint64")
				encoder.AppendUint64(v.One4Uint64)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type4, goName: DataType4, field: gojsontest.FieldOmitempty2.data_type4", v)
		}
	} else {
		encoder.AppendObjectKey("data_type4")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty2.data_type5 | GoName: DataType5 | omitempty: false | ignore: false
	if this.DataType5 != nil {
		switch v := this.DataType5.(type) {
		case *FieldOmitempty2_One5String1:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty2.one5_string1 | kind: StringKind | GoName: One5String1 | omitempty: true | ignore: false
			if v.One5String1 != "" {
				encoder.AppendObjectKey("data_type5")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one5_string1")
				encoder.AppendString(v.One5String1)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type5, goName: DataType5, field: gojsontest.FieldOmitempty2.data_type5", v)
		}
	} else {
		encoder.AppendObjectKey("data_type5")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty2.data_type6 | GoName: DataType6 | omitempty: true | ignore: false
	if this.DataType6 != nil {
		switch v := this.DataType6.(type) {
		case *FieldOmitempty2_One6Sint32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty2.one6_sint32 | kind: Sint32Kind | GoName: One6Sint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one6_sint32")
			encoder.AppendInt32(v.One6Sint32)
			encoder.AppendObjectEnd()
		case *FieldOmitempty2_One6Sint64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty2.one6_sint64 | kind: Sint64Kind | GoName: One6Sint64 | omitempty: true | ignore: false
			if v.One6Sint64 != 0 {
				encoder.AppendObjectKey("data_type6")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one6_sint64")
				encoder.AppendInt64(v.One6Sint64)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type6, goName: DataType6, field: gojsontest.FieldOmitempty2.data_type6", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty2.data_type7 | GoName: DataType7 | omitempty: true | ignore: false
	if this.DataType7 != nil {
		switch v := this.DataType7.(type) {
		case *FieldOmitempty2_One7Bool1:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty2.one7_bool1 | kind: BoolKind | GoName: One7Bool1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one7_bool1")
			encoder.AppendBool(v.One7Bool1)
			encoder.AppendObjectEnd()
		case *FieldOmitempty2_One7Bool2:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty2.one7_bool2 | kind: BoolKind | GoName: One7Bool2 | omitempty: true | ignore: false
			if v.One7Bool2 {
				encoder.AppendObjectKey("dt7")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one7_bool2")
				encoder.AppendBool(v.One7Bool2)
				encoder.AppendObjectEnd()
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt7, goName: DataType7, field: gojsontest.FieldOmitempty2.data_type7", v)
		}
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldOmitempty2) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldOmitempty2) is nil")
	}
	var oneofDataType1isStore bool
	var oneofDataType2isStore bool
	var oneofDataType3isStore bool
	var oneofDataType4isStore bool
	var oneofDataType5isStore bool
	var oneofDataType6isStore bool
	var oneofDataType7isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_string1":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty2.t_string1 | kind: StringKind | GoName: TString1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString1 = x
		case objKey == "t_string2":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty2.t_string2 | kind: StringKind | GoName: TString2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString2 = x
		case objKey == "t_string3":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty2.t_string3 | kind: StringKind | GoName: TString3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString3 = x
		case objKey == "t_string4":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty2.t_string4 | kind: StringKind | GoName: TString4
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString4 = x
		case objKey == "data_type1":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty2.data_type1 | GoName: DataType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			LOOP_ONEOF_data_type1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one1_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldOmitempty2_One1Int32)
						ot.One1Int32 = x
						this.DataType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type2":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty2.data_type2 | GoName: DataType2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int64", string(value), objKey)
				}
			LOOP_ONEOF_data_type2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one2_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(FieldOmitempty2_One2Int64)
						ot.One2Int64 = x
						this.DataType2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type3":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty2.data_type3 | GoName: DataType3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), objKey)
				}
			LOOP_ONEOF_data_type3:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type3
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one3_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofDataType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType3isStore = true
						ot := new(FieldOmitempty2_One3Uint32)
						ot.One3Uint32 = x
						this.DataType3 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type4":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty2.data_type4 | GoName: DataType4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint64", string(value), objKey)
				}
			LOOP_ONEOF_data_type4:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type4
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one4_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(FieldOmitempty2_One4Uint64)
						ot.One4Uint64 = x
						this.DataType4 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type4
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type5":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty2.data_type5 | GoName: DataType5
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_type5:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type5
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one5_string1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType5isStore = true
						ot := new(FieldOmitempty2_One5String1)
						ot.One5String1 = x
						this.DataType5 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type5
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type6":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty2.data_type6 | GoName: DataType6
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			LOOP_ONEOF_data_type6:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type6
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one6_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(FieldOmitempty2_One6Sint32)
						ot.One6Sint32 = x
						this.DataType6 = ot
					case oneofKey == "one6_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(FieldOmitempty2_One6Sint64)
						ot.One6Sint64 = x
						this.DataType6 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type6
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt7":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty2.data_type7 | GoName: DataType7
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), objKey)
				}
			LOOP_ONEOF_dt7:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt7
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one7_bool1":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(FieldOmitempty2_One7Bool1)
						ot.One7Bool1 = x
						this.DataType7 = ot
					case oneofKey == "one7_bool2":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(FieldOmitempty2_One7Bool2)
						ot.One7Bool2 = x
						this.DataType7 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt7
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldOmitempty3) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(192)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string1 | kind: StringKind | GoName: TString1 | omitempty: true | ignore: false
	if this.TString1 != "" {
		encoder.AppendObjectKey("t_string1")
		encoder.AppendString(this.TString1)
	}
	// encode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string2 | kind: StringKind | GoName: TString2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string2")
	encoder.AppendString(this.TString2)
	// encode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string3 | kind: StringKind | GoName: TString3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string3")
	encoder.AppendString(this.TString3)
	// encode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string4 | kind: StringKind | GoName: TString4 | omitempty: true | ignore: false
	if this.TString4 != "" {
		encoder.AppendObjectKey("t_string4")
		encoder.AppendString(this.TString4)
	}
	// encode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string5 | kind: StringKind | GoName: TString5 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string5")
	encoder.AppendString(this.TString5)
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty3.data_type1 | GoName: DataType1 | omitempty: true | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *FieldOmitempty3_One1Int32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one1_int32 | kind: Int32Kind | GoName: One1Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one1_int32")
			encoder.AppendInt32(v.One1Int32)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt1, goName: DataType1, field: gojsontest.FieldOmitempty3.data_type1", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty3.data_type2 | GoName: DataType2 | omitempty: true | ignore: false
	if this.DataType2 != nil {
		switch v := this.DataType2.(type) {
		case *FieldOmitempty3_One2Int64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one2_int64 | kind: Int64Kind | GoName: One2Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one2_int64")
			encoder.AppendInt64(v.One2Int64)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt2, goName: DataType2, field: gojsontest.FieldOmitempty3.data_type2", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty3.data_type3 | GoName: DataType3 | omitempty: true | ignore: false
	if this.DataType3 != nil {
		switch v := this.DataType3.(type) {
		case *FieldOmitempty3_One3Uint32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one3_uint32 | kind: Uint32Kind | GoName: One3Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one3_uint32")
			encoder.AppendUint32(v.One3Uint32)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt3, goName: DataType3, field: gojsontest.FieldOmitempty3.data_type3", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty3.data_type4 | GoName: DataType4 | omitempty: false | ignore: false
	if this.DataType4 != nil {
		switch v := this.DataType4.(type) {
		case *FieldOmitempty3_One4Uint64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one4_uint64 | kind: Uint64Kind | GoName: One4Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one4_uint64")
			encoder.AppendUint64(v.One4Uint64)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt4, goName: DataType4, field: gojsontest.FieldOmitempty3.data_type4", v)
		}
	} else {
		encoder.AppendObjectKey("dt4")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty3.data_type5 | GoName: DataType5 | omitempty: false | ignore: false
	if this.DataType5 != nil {
		switch v := this.DataType5.(type) {
		case *FieldOmitempty3_One5String1:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one5_string1 | kind: StringKind | GoName: One5String1 | omitempty: true | ignore: false
			if v.One5String1 != "" {
				encoder.AppendObjectKey("dt5")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one5_string1")
				encoder.AppendString(v.One5String1)
				encoder.AppendObjectEnd()
			}
		case *FieldOmitempty3_One5String2:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one5_string2 | kind: StringKind | GoName: One5String2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one5_string2")
			encoder.AppendString(v.One5String2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt5, goName: DataType5, field: gojsontest.FieldOmitempty3.data_type5", v)
		}
	} else {
		encoder.AppendObjectKey("dt5")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty3.data_type6 | GoName: DataType6 | omitempty: false | ignore: false
	if this.DataType6 != nil {
		switch v := this.DataType6.(type) {
		case *FieldOmitempty3_One6Sint32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one6_sint32 | kind: Sint32Kind | GoName: One6Sint32 | omitempty: true | ignore: false
			if v.One6Sint32 != 0 {
				encoder.AppendObjectKey("dt6")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one6_sint32")
				encoder.AppendInt32(v.One6Sint32)
				encoder.AppendObjectEnd()
			}
		case *FieldOmitempty3_One6Sint64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one6_sint64 | kind: Sint64Kind | GoName: One6Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one6_sint64")
			encoder.AppendInt64(v.One6Sint64)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt6, goName: DataType6, field: gojsontest.FieldOmitempty3.data_type6", v)
		}
	} else {
		encoder.AppendObjectKey("dt6")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty3.data_type7 | GoName: DataType7 | omitempty: false | ignore: false
	if this.DataType7 != nil {
		switch v := this.DataType7.(type) {
		case *FieldOmitempty3_One7Bool1:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one7_bool1 | kind: BoolKind | GoName: One7Bool1 | omitempty: true | ignore: false
			if v.One7Bool1 {
				encoder.AppendObjectKey("dt7")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one7_bool1")
				encoder.AppendBool(v.One7Bool1)
				encoder.AppendObjectEnd()
			}
		case *FieldOmitempty3_One7Bool2:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one7_bool2 | kind: BoolKind | GoName: One7Bool2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one7_bool2")
			encoder.AppendBool(v.One7Bool2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt7, goName: DataType7, field: gojsontest.FieldOmitempty3.data_type7", v)
		}
	} else {
		encoder.AppendObjectKey("dt7")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty3.data_type8 | GoName: DataType8 | omitempty: false | ignore: false
	if this.DataType8 != nil {
		switch v := this.DataType8.(type) {
		case *FieldOmitempty3_One8Bool1:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one8_bool1 | kind: BoolKind | GoName: One8Bool1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one8_bool1")
			encoder.AppendBool(v.One8Bool1)
			encoder.AppendObjectEnd()
		case *FieldOmitempty3_One8Bool2:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty3.one8_bool2 | kind: BoolKind | GoName: One8Bool2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one8_bool2")
			encoder.AppendBool(v.One8Bool2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt8, goName: DataType8, field: gojsontest.FieldOmitempty3.data_type8", v)
		}
	} else {
		encoder.AppendObjectKey("dt8")
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldOmitempty3) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldOmitempty3) is nil")
	}
	var oneofDataType1isStore bool
	var oneofDataType2isStore bool
	var oneofDataType3isStore bool
	var oneofDataType4isStore bool
	var oneofDataType5isStore bool
	var oneofDataType6isStore bool
	var oneofDataType7isStore bool
	var oneofDataType8isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_string1":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string1 | kind: StringKind | GoName: TString1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString1 = x
		case objKey == "t_string2":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string2 | kind: StringKind | GoName: TString2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString2 = x
		case objKey == "t_string3":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string3 | kind: StringKind | GoName: TString3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString3 = x
		case objKey == "t_string4":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string4 | kind: StringKind | GoName: TString4
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString4 = x
		case objKey == "t_string5":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty3.t_string5 | kind: StringKind | GoName: TString5
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString5 = x
		case objKey == "dt1":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty3.data_type1 | GoName: DataType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			LOOP_ONEOF_dt1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one1_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldOmitempty3_One1Int32)
						ot.One1Int32 = x
						this.DataType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt2":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty3.data_type2 | GoName: DataType2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int64", string(value), objKey)
				}
			LOOP_ONEOF_dt2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one2_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(FieldOmitempty3_One2Int64)
						ot.One2Int64 = x
						this.DataType2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt3":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty3.data_type3 | GoName: DataType3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), objKey)
				}
			LOOP_ONEOF_dt3:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt3
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one3_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofDataType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType3isStore = true
						ot := new(FieldOmitempty3_One3Uint32)
						ot.One3Uint32 = x
						this.DataType3 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt4":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty3.data_type4 | GoName: DataType4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint64", string(value), objKey)
				}
			LOOP_ONEOF_dt4:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt4
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one4_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(FieldOmitempty3_One4Uint64)
						ot.One4Uint64 = x
						this.DataType4 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt4
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt5":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty3.data_type5 | GoName: DataType5
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dt5:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt5
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one5_string1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType5isStore = true
						ot := new(FieldOmitempty3_One5String1)
						ot.One5String1 = x
						this.DataType5 = ot
					case oneofKey == "one5_string2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType5isStore = true
						ot := new(FieldOmitempty3_One5String2)
						ot.One5String2 = x
						this.DataType5 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt5
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt6":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty3.data_type6 | GoName: DataType6
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			LOOP_ONEOF_dt6:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt6
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one6_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(FieldOmitempty3_One6Sint32)
						ot.One6Sint32 = x
						this.DataType6 = ot
					case oneofKey == "one6_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(FieldOmitempty3_One6Sint64)
						ot.One6Sint64 = x
						this.DataType6 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt6
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt7":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty3.data_type7 | GoName: DataType7
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), objKey)
				}
			LOOP_ONEOF_dt7:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt7
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one7_bool1":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(FieldOmitempty3_One7Bool1)
						ot.One7Bool1 = x
						this.DataType7 = ot
					case oneofKey == "one7_bool2":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(FieldOmitempty3_One7Bool2)
						ot.One7Bool2 = x
						this.DataType7 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt7
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt8":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty3.data_type8 | GoName: DataType8
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), objKey)
				}
			LOOP_ONEOF_dt8:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt8
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one8_bool1":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofDataType8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType8isStore = true
						ot := new(FieldOmitempty3_One8Bool1)
						ot.One8Bool1 = x
						this.DataType8 = ot
					case oneofKey == "one8_bool2":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofDataType8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType8isStore = true
						ot := new(FieldOmitempty3_One8Bool2)
						ot.One8Bool2 = x
						this.DataType8 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt8
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldOmitempty4) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(258)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.FieldOmitempty4.t_string1 | kind: StringKind | GoName: TString1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string1")
	encoder.AppendString(this.TString1)
	// encode filed type of basic; | field: gojsontest.FieldOmitempty4.t_string2 | kind: StringKind | GoName: TString2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string2")
	encoder.AppendString(this.TString2)
	// encode filed type of basic; | field: gojsontest.FieldOmitempty4.t_string3 | kind: StringKind | GoName: TString3 | omitempty: true | ignore: false
	if this.TString3 != "" {
		encoder.AppendObjectKey("t_string3")
		encoder.AppendString(this.TString3)
	}
	// encode filed type of basic; | field: gojsontest.FieldOmitempty4.t_string4 | kind: StringKind | GoName: TString4 | omitempty: true | ignore: false
	if this.TString4 != "" {
		encoder.AppendObjectKey("t_string4")
		encoder.AppendString(this.TString4)
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty4.data_type1 | GoName: DataType1 | omitempty: false | ignore: false
	if this.DataType1 != nil {
		switch v := this.DataType1.(type) {
		case *FieldOmitempty4_One1Int32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty4.one1_int32 | kind: Int32Kind | GoName: One1Int32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one1_int32")
			encoder.AppendInt32(v.One1Int32)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type1, goName: DataType1, field: gojsontest.FieldOmitempty4.data_type1", v)
		}
	} else {
		encoder.AppendObjectKey("data_type1")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty4.data_type2 | GoName: DataType2 | omitempty: false | ignore: false
	if this.DataType2 != nil {
		switch v := this.DataType2.(type) {
		case *FieldOmitempty4_One2Int64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty4.one2_int64 | kind: Int64Kind | GoName: One2Int64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type2")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one2_int64")
			encoder.AppendInt64(v.One2Int64)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type2, goName: DataType2, field: gojsontest.FieldOmitempty4.data_type2", v)
		}
	} else {
		encoder.AppendObjectKey("data_type2")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty4.data_type3 | GoName: DataType3 | omitempty: false | ignore: false
	if this.DataType3 != nil {
		switch v := this.DataType3.(type) {
		case *FieldOmitempty4_One3Uint32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty4.one3_uint32 | kind: Uint32Kind | GoName: One3Uint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one3_uint32")
			encoder.AppendUint32(v.One3Uint32)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type3, goName: DataType3, field: gojsontest.FieldOmitempty4.data_type3", v)
		}
	} else {
		encoder.AppendObjectKey("data_type3")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty4.data_type4 | GoName: DataType4 | omitempty: true | ignore: false
	if this.DataType4 != nil {
		switch v := this.DataType4.(type) {
		case *FieldOmitempty4_One4Uint64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty4.one4_uint64 | kind: Uint64Kind | GoName: One4Uint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one4_uint64")
			encoder.AppendUint64(v.One4Uint64)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type4, goName: DataType4, field: gojsontest.FieldOmitempty4.data_type4", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty4.data_type5 | GoName: DataType5 | omitempty: true | ignore: false
	if this.DataType5 != nil {
		switch v := this.DataType5.(type) {
		case *FieldOmitempty4_One5String1:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty4.one5_string1 | kind: StringKind | GoName: One5String1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one5_string1")
			encoder.AppendString(v.One5String1)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type5, goName: DataType5, field: gojsontest.FieldOmitempty4.data_type5", v)
		}
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty4.data_type6 | GoName: DataType6 | omitempty: false | ignore: false
	if this.DataType6 != nil {
		switch v := this.DataType6.(type) {
		case *FieldOmitempty4_One6Sint32:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty4.one6_sint32 | kind: Sint32Kind | GoName: One6Sint32 | omitempty: true | ignore: false
			if v.One6Sint32 != 0 {
				encoder.AppendObjectKey("data_type6")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one6_sint32")
				encoder.AppendInt32(v.One6Sint32)
				encoder.AppendObjectEnd()
			}
		case *FieldOmitempty4_One6Sint64:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty4.one6_sint64 | kind: Sint64Kind | GoName: One6Sint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one6_sint64")
			encoder.AppendInt64(v.One6Sint64)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type6, goName: DataType6, field: gojsontest.FieldOmitempty4.data_type6", v)
		}
	} else {
		encoder.AppendObjectKey("data_type6")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldOmitempty4.data_type7 | GoName: DataType7 | omitempty: false | ignore: false
	if this.DataType7 != nil {
		switch v := this.DataType7.(type) {
		case *FieldOmitempty4_One7Bool1:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty4.one7_bool1 | kind: BoolKind | GoName: One7Bool1 | omitempty: true | ignore: false
			if v.One7Bool1 {
				encoder.AppendObjectKey("data_type7")
				encoder.AppendObjectBegin()
				encoder.AppendObjectKey("one7_bool1")
				encoder.AppendBool(v.One7Bool1)
				encoder.AppendObjectEnd()
			}
		case *FieldOmitempty4_One7Bool2:
			// encode filed type of basic; | field: gojsontest.FieldOmitempty4.one7_bool2 | kind: BoolKind | GoName: One7Bool2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("data_type7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("one7_bool2")
			encoder.AppendBool(v.One7Bool2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: data_type7, goName: DataType7, field: gojsontest.FieldOmitempty4.data_type7", v)
		}
	} else {
		encoder.AppendObjectKey("data_type7")
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldOmitempty4) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldOmitempty4) is nil")
	}
	var oneofDataType1isStore bool
	var oneofDataType2isStore bool
	var oneofDataType3isStore bool
	var oneofDataType4isStore bool
	var oneofDataType5isStore bool
	var oneofDataType6isStore bool
	var oneofDataType7isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_string1":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty4.t_string1 | kind: StringKind | GoName: TString1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString1 = x
		case objKey == "t_string2":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty4.t_string2 | kind: StringKind | GoName: TString2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString2 = x
		case objKey == "t_string3":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty4.t_string3 | kind: StringKind | GoName: TString3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString3 = x
		case objKey == "t_string4":
			// decode filed type of basic; | field: gojsontest.FieldOmitempty4.t_string4 | kind: StringKind | GoName: TString4
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString4 = x
		case objKey == "data_type1":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty4.data_type1 | GoName: DataType1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			LOOP_ONEOF_data_type1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one1_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType1isStore = true
						ot := new(FieldOmitempty4_One1Int32)
						ot.One1Int32 = x
						this.DataType1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type2":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty4.data_type2 | GoName: DataType2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int64", string(value), objKey)
				}
			LOOP_ONEOF_data_type2:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type2
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one2_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType2isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType2isStore = true
						ot := new(FieldOmitempty4_One2Int64)
						ot.One2Int64 = x
						this.DataType2 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type3":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty4.data_type3 | GoName: DataType3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), objKey)
				}
			LOOP_ONEOF_data_type3:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type3
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one3_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofDataType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType3isStore = true
						ot := new(FieldOmitempty4_One3Uint32)
						ot.One3Uint32 = x
						this.DataType3 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type4":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty4.data_type4 | GoName: DataType4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint64", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint64", string(value), objKey)
				}
			LOOP_ONEOF_data_type4:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type4
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one4_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(FieldOmitempty4_One4Uint64)
						ot.One4Uint64 = x
						this.DataType4 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type4
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type5":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty4.data_type5 | GoName: DataType5
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_data_type5:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type5
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one5_string1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType5isStore = true
						ot := new(FieldOmitempty4_One5String1)
						ot.One5String1 = x
						this.DataType5 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type5
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type6":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty4.data_type6 | GoName: DataType6
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), objKey)
				}
			LOOP_ONEOF_data_type6:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type6
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one6_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(FieldOmitempty4_One6Sint32)
						ot.One6Sint32 = x
						this.DataType6 = ot
					case oneofKey == "one6_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(FieldOmitempty4_One6Sint64)
						ot.One6Sint64 = x
						this.DataType6 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type6
					}
				}
				decoder.ScanNext()
			}
		case objKey == "data_type7":
			// decode filed type of oneof; | field: gojsontest.FieldOmitempty4.data_type7 | GoName: DataType7
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), objKey)
				}
			LOOP_ONEOF_data_type7:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_data_type7
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "one7_bool1":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(FieldOmitempty4_One7Bool1)
						ot.One7Bool1 = x
						this.DataType7 = ot
					case oneofKey == "one7_bool2":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(FieldOmitempty4_One7Bool2)
						ot.One7Bool2 = x
						this.DataType7 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_data_type7
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldIgnore2) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(92)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.FieldIgnore2.name_style1 | kind: Int32Kind | GoName: NameStyle1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("ns1")
	encoder.AppendInt32(this.NameStyle1)
	// encode filed type of basic; | field: gojsontest.FieldIgnore2.names_Style2 | kind: Int32Kind | GoName: Names_Style2 | omitempty: false | ignore: true
	// encode filed type of basic; | field: gojsontest.FieldIgnore2.Name_Style3 | kind: Int32Kind | GoName: Name_Style3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("ns3")
	encoder.AppendInt32(this.Name_Style3)
	// encode filed type of basic; | field: gojsontest.FieldIgnore2.nameStyle4 | kind: Int32Kind | GoName: NameStyle4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("ns4")
	encoder.AppendInt32(this.NameStyle4)
	// encode filed type of basic; | field: gojsontest.FieldIgnore2.NameStyle5 | kind: Int32Kind | GoName: NameStyle5 | omitempty: false | ignore: true
	// Encode field type of oneof; | field: gojsontest.FieldIgnore2.data_type1 | GoName: DataType1 | omitempty: false | ignore: true
	// Encode field type of oneof; | field: gojsontest.FieldIgnore2.data_type2 | GoName: DataType2 | omitempty: false | ignore: true
	// Encode field type of oneof; | field: gojsontest.FieldIgnore2.data_type3 | GoName: DataType3 | omitempty: false | ignore: false
	if this.DataType3 != nil {
		switch v := this.DataType3.(type) {
		case *FieldIgnore2_Integer3:
			// encode filed type of basic; | field: gojsontest.FieldIgnore2.integer3 | kind: StringKind | GoName: Integer3 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt3")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("i3")
			encoder.AppendString(v.Integer3)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt3, goName: DataType3, field: gojsontest.FieldIgnore2.data_type3", v)
		}
	} else {
		encoder.AppendObjectKey("dt3")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldIgnore2.data_type4 | GoName: DataType4 | omitempty: false | ignore: false
	if this.DataType4 != nil {
		switch v := this.DataType4.(type) {
		case *FieldIgnore2_Integer4:
			// encode filed type of basic; | field: gojsontest.FieldIgnore2.integer4 | kind: StringKind | GoName: Integer4 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt4")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("i4")
			encoder.AppendString(v.Integer4)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt4, goName: DataType4, field: gojsontest.FieldIgnore2.data_type4", v)
		}
	} else {
		encoder.AppendObjectKey("dt4")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldIgnore2.data_type5 | GoName: DataType5 | omitempty: false | ignore: false
	if this.DataType5 != nil {
		switch v := this.DataType5.(type) {
		case *FieldIgnore2_Integer5:
		// encode filed type of basic; | field: gojsontest.FieldIgnore2.integer5 | kind: StringKind | GoName: Integer5 | omitempty: false | ignore: true
		case *FieldIgnore2_Float5:
			// encode filed type of basic; | field: gojsontest.FieldIgnore2.float5 | kind: StringKind | GoName: Float5 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt5")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("f5")
			encoder.AppendString(v.Float5)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt5, goName: DataType5, field: gojsontest.FieldIgnore2.data_type5", v)
		}
	} else {
		encoder.AppendObjectKey("dt5")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldIgnore2.data_type6 | GoName: DataType6 | omitempty: false | ignore: false
	if this.DataType6 != nil {
		switch v := this.DataType6.(type) {
		case *FieldIgnore2_Integer6:
		// encode filed type of basic; | field: gojsontest.FieldIgnore2.integer6 | kind: StringKind | GoName: Integer6 | omitempty: false | ignore: true
		case *FieldIgnore2_Float6:
			// encode filed type of basic; | field: gojsontest.FieldIgnore2.float6 | kind: StringKind | GoName: Float6 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt6")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("f6")
			encoder.AppendString(v.Float6)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt6, goName: DataType6, field: gojsontest.FieldIgnore2.data_type6", v)
		}
	} else {
		encoder.AppendObjectKey("dt6")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldIgnore2.data_type7 | GoName: DataType7 | omitempty: false | ignore: false
	if this.DataType7 != nil {
		switch v := this.DataType7.(type) {
		case *FieldIgnore2_Integer7:
		// encode filed type of basic; | field: gojsontest.FieldIgnore2.integer7 | kind: StringKind | GoName: Integer7 | omitempty: false | ignore: true
		case *FieldIgnore2_Float7:
			// encode filed type of basic; | field: gojsontest.FieldIgnore2.float7 | kind: StringKind | GoName: Float7 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt7")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("f7")
			encoder.AppendString(v.Float7)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt7, goName: DataType7, field: gojsontest.FieldIgnore2.data_type7", v)
		}
	} else {
		encoder.AppendObjectKey("dt7")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldIgnore2.data_type8 | GoName: DataType8 | omitempty: false | ignore: false
	if this.DataType8 != nil {
		switch v := this.DataType8.(type) {
		case *FieldIgnore2_Integer8:
		// encode filed type of basic; | field: gojsontest.FieldIgnore2.integer8 | kind: StringKind | GoName: Integer8 | omitempty: false | ignore: true
		case *FieldIgnore2_Float8:
			// encode filed type of basic; | field: gojsontest.FieldIgnore2.float8 | kind: StringKind | GoName: Float8 | omitempty: false | ignore: false
			encoder.AppendObjectKey("dt8")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("f8")
			encoder.AppendString(v.Float8)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: dt8, goName: DataType8, field: gojsontest.FieldIgnore2.data_type8", v)
		}
	} else {
		encoder.AppendObjectKey("dt8")
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldIgnore2) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldIgnore2) is nil")
	}
	var oneofDataType3isStore bool
	var oneofDataType4isStore bool
	var oneofDataType5isStore bool
	var oneofDataType6isStore bool
	var oneofDataType7isStore bool
	var oneofDataType8isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ns1":
			// decode filed type of basic; | field: gojsontest.FieldIgnore2.name_style1 | kind: Int32Kind | GoName: NameStyle1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle1 = x
		case objKey == "ns3":
			// decode filed type of basic; | field: gojsontest.FieldIgnore2.Name_Style3 | kind: Int32Kind | GoName: Name_Style3
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Name_Style3 = x
		case objKey == "ns4":
			// decode filed type of basic; | field: gojsontest.FieldIgnore2.nameStyle4 | kind: Int32Kind | GoName: NameStyle4
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle4 = x
		case objKey == "dt3":
			// decode filed type of oneof; | field: gojsontest.FieldIgnore2.data_type3 | GoName: DataType3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dt3:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt3
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "i3":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType3isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType3isStore = true
						ot := new(FieldIgnore2_Integer3)
						ot.Integer3 = x
						this.DataType3 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt4":
			// decode filed type of oneof; | field: gojsontest.FieldIgnore2.data_type4 | GoName: DataType4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dt4:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt4
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "i4":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType4isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType4isStore = true
						ot := new(FieldIgnore2_Integer4)
						ot.Integer4 = x
						this.DataType4 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt4
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt5":
			// decode filed type of oneof; | field: gojsontest.FieldIgnore2.data_type5 | GoName: DataType5
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dt5:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt5
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "f5":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType5isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType5isStore = true
						ot := new(FieldIgnore2_Float5)
						ot.Float5 = x
						this.DataType5 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt5
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt6":
			// decode filed type of oneof; | field: gojsontest.FieldIgnore2.data_type6 | GoName: DataType6
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dt6:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt6
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "f6":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType6isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType6isStore = true
						ot := new(FieldIgnore2_Float6)
						ot.Float6 = x
						this.DataType6 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt6
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt7":
			// decode filed type of oneof; | field: gojsontest.FieldIgnore2.data_type7 | GoName: DataType7
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dt7:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt7
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "f7":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType7isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType7isStore = true
						ot := new(FieldIgnore2_Float7)
						ot.Float7 = x
						this.DataType7 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt7
					}
				}
				decoder.ScanNext()
			}
		case objKey == "dt8":
			// decode filed type of oneof; | field: gojsontest.FieldIgnore2.data_type8 | GoName: DataType8
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_dt8:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_dt8
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "f8":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofDataType8isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofDataType8isStore = true
						ot := new(FieldIgnore2_Float8)
						ot.Float8 = x
						this.DataType8 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_dt8
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldDisallowUnknown) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(44)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.FieldDisallowUnknown.name_style1 | kind: Int32Kind | GoName: NameStyle1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("ns1")
	encoder.AppendInt32(this.NameStyle1)
	// Encode field type of oneof; | field: gojsontest.FieldDisallowUnknown.Oneof1 | GoName: Oneof1 | omitempty: false | ignore: false
	if this.Oneof1 != nil {
		switch v := this.Oneof1.(type) {
		case *FieldDisallowUnknown_TString1:
			// encode filed type of basic; | field: gojsontest.FieldDisallowUnknown.t_string1 | kind: StringKind | GoName: TString1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("ts1")
			encoder.AppendString(v.TString1)
			encoder.AppendObjectEnd()
		case *FieldDisallowUnknown_TString2:
			// encode filed type of basic; | field: gojsontest.FieldDisallowUnknown.t_string2 | kind: StringKind | GoName: TString2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("ts2")
			encoder.AppendString(v.TString2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: oneof1, goName: Oneof1, field: gojsontest.FieldDisallowUnknown.Oneof1", v)
		}
	} else {
		encoder.AppendObjectKey("oneof1")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldDisallowUnknown.Oneof2 | GoName: Oneof2 | omitempty: false | ignore: false
	if this.Oneof2 != nil {
		switch v := this.Oneof2.(type) {
		case *FieldDisallowUnknown_TInt1:
			// encode filed type of basic; | field: gojsontest.FieldDisallowUnknown.t_int1 | kind: Int32Kind | GoName: TInt1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("ti1")
			encoder.AppendInt32(v.TInt1)
		case *FieldDisallowUnknown_TInt2:
			// encode filed type of basic; | field: gojsontest.FieldDisallowUnknown.t_int2 | kind: Int32Kind | GoName: TInt2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("ti2")
			encoder.AppendInt32(v.TInt2)
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: oneof2, goName: Oneof2, field: gojsontest.FieldDisallowUnknown.Oneof2", v)
		}
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldDisallowUnknown) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldDisallowUnknown) is nil")
	}
	var oneofOneof1isStore bool
	var oneofOneof2isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ns1":
			// decode filed type of basic; | field: gojsontest.FieldDisallowUnknown.name_style1 | kind: Int32Kind | GoName: NameStyle1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle1 = x
		case objKey == "oneof1":
			// decode filed type of oneof; | field: gojsontest.FieldDisallowUnknown.Oneof1 | GoName: Oneof1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_oneof1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_oneof1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "ts1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof1isStore = true
						ot := new(FieldDisallowUnknown_TString1)
						ot.TString1 = x
						this.Oneof1 = ot
					case oneofKey == "ts2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof1isStore = true
						ot := new(FieldDisallowUnknown_TString2)
						ot.TString2 = x
						this.Oneof1 = ot
					default:
						return fmt.Errorf("json: unknown oneof field %q", oneofKey)
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_oneof1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "ti1":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofOneof2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofOneof2isStore = true
			ot := new(FieldDisallowUnknown_TInt1)
			ot.TInt1 = x
			this.Oneof2 = ot
		case objKey == "ti2":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofOneof2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofOneof2isStore = true
			ot := new(FieldDisallowUnknown_TInt2)
			ot.TInt2 = x
			this.Oneof2 = ot
		default:
			return fmt.Errorf("json: unknown field %q", objKey)
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *FieldAllowUnknown) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(44)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.FieldAllowUnknown.name_style1 | kind: Int32Kind | GoName: NameStyle1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("ns1")
	encoder.AppendInt32(this.NameStyle1)
	// Encode field type of oneof; | field: gojsontest.FieldAllowUnknown.Oneof1 | GoName: Oneof1 | omitempty: false | ignore: false
	if this.Oneof1 != nil {
		switch v := this.Oneof1.(type) {
		case *FieldAllowUnknown_TString1:
			// encode filed type of basic; | field: gojsontest.FieldAllowUnknown.t_string1 | kind: StringKind | GoName: TString1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("ts1")
			encoder.AppendString(v.TString1)
			encoder.AppendObjectEnd()
		case *FieldAllowUnknown_TString2:
			// encode filed type of basic; | field: gojsontest.FieldAllowUnknown.t_string2 | kind: StringKind | GoName: TString2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("oneof1")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("ts2")
			encoder.AppendString(v.TString2)
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: oneof1, goName: Oneof1, field: gojsontest.FieldAllowUnknown.Oneof1", v)
		}
	} else {
		encoder.AppendObjectKey("oneof1")
		encoder.AppendNil()
	}
	// Encode field type of oneof; | field: gojsontest.FieldAllowUnknown.Oneof2 | GoName: Oneof2 | omitempty: false | ignore: false
	if this.Oneof2 != nil {
		switch v := this.Oneof2.(type) {
		case *FieldAllowUnknown_TInt1:
			// encode filed type of basic; | field: gojsontest.FieldAllowUnknown.t_int1 | kind: Int32Kind | GoName: TInt1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("ti1")
			encoder.AppendInt32(v.TInt1)
		case *FieldAllowUnknown_TInt2:
			// encode filed type of basic; | field: gojsontest.FieldAllowUnknown.t_int2 | kind: Int32Kind | GoName: TInt2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("ti2")
			encoder.AppendInt32(v.TInt2)
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: oneof2, goName: Oneof2, field: gojsontest.FieldAllowUnknown.Oneof2", v)
		}
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *FieldAllowUnknown) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*FieldAllowUnknown) is nil")
	}
	var oneofOneof1isStore bool
	var oneofOneof2isStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ns1":
			// decode filed type of basic; | field: gojsontest.FieldAllowUnknown.name_style1 | kind: Int32Kind | GoName: NameStyle1
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.NameStyle1 = x
		case objKey == "oneof1":
			// decode filed type of oneof; | field: gojsontest.FieldAllowUnknown.Oneof1 | GoName: Oneof1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_oneof1:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_oneof1
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "ts1":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof1isStore = true
						ot := new(FieldAllowUnknown_TString1)
						ot.TString1 = x
						this.Oneof1 = ot
					case oneofKey == "ts2":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofOneof1isStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofOneof1isStore = true
						ot := new(FieldAllowUnknown_TString2)
						ot.TString2 = x
						this.Oneof1 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_oneof1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "ti1":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofOneof2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofOneof2isStore = true
			ot := new(FieldAllowUnknown_TInt1)
			ot.TInt1 = x
			this.Oneof2 = ot
		case objKey == "ti2":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofOneof2isStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofOneof2isStore = true
			ot := new(FieldAllowUnknown_TInt2)
			ot.TInt2 = x
			this.Oneof2 = ot
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *EnumUseString1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(178)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.EnumUseString1.t_status1 | kind: EnumKind | GoName: TStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_status1")
	encoder.AppendString(this.TStatus1.String())
	// encode filed type of basic; | field: gojsontest.EnumUseString1.t_status2 | kind: EnumKind | GoName: TStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_status2")
	encoder.AppendInt32(int32(this.TStatus2.Number()))
	// encode field type of list; | field: gojsontest.EnumUseString1.a_status1 | kind:EnumKind | goName: AStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status1")
	if this.AStatus1 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus1 {
			encoder.AppendString(this.AStatus1[i].String())
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.EnumUseString1.a_status2 | kind:EnumKind | goName: AStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status2")
	if this.AStatus2 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus2 {
			encoder.AppendInt32(int32(this.AStatus2[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.EnumUseString1.a_status3 | kind:EnumKind | goName: AStatus3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status3")
	if this.AStatus3 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus3 {
			encoder.AppendString(this.AStatus3[i].String())
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString1.m_status1 | keyKind: string | valueKind: enum | goName: MStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status1")
	if this.MStatus1 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus1 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString1.m_status2 | keyKind: string | valueKind: enum | goName: MStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status2")
	if this.MStatus2 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus2 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString1.m_status3 | keyKind: string | valueKind: enum | goName: MStatus3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status3")
	if this.MStatus3 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus3 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *EnumUseString1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*EnumUseString1) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_status1":
			// decode filed type of basic; | field: gojsontest.EnumUseString1.t_status1 | kind: EnumKind | GoName: TStatus1
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type EnumUseString1_Status1", string(value), objKey)
			}
			x1, ok := EnumUseString1_Status1_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := EnumUseString1_Status1(x1)
			this.TStatus1 = x
		case objKey == "t_status2":
			// decode filed type of basic; | field: gojsontest.EnumUseString1.t_status2 | kind: EnumKind | GoName: TStatus2
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type EnumUseString1_Status2", string(value), objKey)
			}
			_, ok := EnumUseString1_Status2_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := EnumUseString1_Status2(x1)
			this.TStatus2 = x
		case objKey == "a_status1":
			// decode filed type of list; | field: gojsontest.EnumUseString1.a_status1 | kind: EnumKind | GoName: AStatus1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString1_Status1", string(value), objKey)
				} else {
					this.AStatus1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString1_Status1", string(value), objKey)
				}
				if this.AStatus1 == nil {
					this.AStatus1 = make([]EnumUseString1_Status1, 0)
				}
				i := 0
				length := len(this.AStatus1)
			LOOP_LIST_a_status1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status1
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString1_Status1", string(value), objKey)
					}
					x1, ok := EnumUseString1_Status1_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString1_Status1(x1)
					if i < length {
						this.AStatus1[i] = x
					} else {
						this.AStatus1 = append(this.AStatus1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status1
					}
				}
				if i < length {
					this.AStatus1 = this.AStatus1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "a_status2":
			// decode filed type of list; | field: gojsontest.EnumUseString1.a_status2 | kind: EnumKind | GoName: AStatus2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString1_Status2", string(value), objKey)
				} else {
					this.AStatus2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString1_Status2", string(value), objKey)
				}
				if this.AStatus2 == nil {
					this.AStatus2 = make([]EnumUseString1_Status2, 0)
				}
				i := 0
				length := len(this.AStatus2)
			LOOP_LIST_a_status2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status2
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString1_Status2", string(value), objKey)
					}
					_, ok := EnumUseString1_Status2_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString1_Status2(x1)
					if i < length {
						this.AStatus2[i] = x
					} else {
						this.AStatus2 = append(this.AStatus2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status2
					}
				}
				if i < length {
					this.AStatus2 = this.AStatus2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "a_status3":
			// decode filed type of list; | field: gojsontest.EnumUseString1.a_status3 | kind: EnumKind | GoName: AStatus3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString1_Status1", string(value), objKey)
				} else {
					this.AStatus3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString1_Status1", string(value), objKey)
				}
				if this.AStatus3 == nil {
					this.AStatus3 = make([]EnumUseString1_Status1, 0)
				}
				i := 0
				length := len(this.AStatus3)
			LOOP_LIST_a_status3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status3
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString1_Status1", string(value), objKey)
					}
					x1, ok := EnumUseString1_Status1_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString1_Status1(x1)
					if i < length {
						this.AStatus3[i] = x
					} else {
						this.AStatus3 = append(this.AStatus3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status3
					}
				}
				if i < length {
					this.AStatus3 = this.AStatus3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "m_status1":
			// decode filed type of map; | field: gojsontest.EnumUseString1.m_status1 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString1_Status1", string(value), objKey)
				} else {
					this.MStatus1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString1_Status1", string(value), objKey)
				}
				if this.MStatus1 == nil { // create map if not initialized.
					this.MStatus1 = make(map[string]EnumUseString1_Status1)
				}
			LOOP_MAP_m_status1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString1_Status1", string(value), objKey)
					}
					_, ok := EnumUseString1_Status1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString1_Status1(x1)
					this.MStatus1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m_status2":
			// decode filed type of map; | field: gojsontest.EnumUseString1.m_status2 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString1_Status2", string(value), objKey)
				} else {
					this.MStatus2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString1_Status2", string(value), objKey)
				}
				if this.MStatus2 == nil { // create map if not initialized.
					this.MStatus2 = make(map[string]EnumUseString1_Status2)
				}
			LOOP_MAP_m_status2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString1_Status2", string(value), objKey)
					}
					_, ok := EnumUseString1_Status2_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString1_Status2(x1)
					this.MStatus2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m_status3":
			// decode filed type of map; | field: gojsontest.EnumUseString1.m_status3 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString1_Status1", string(value), objKey)
				} else {
					this.MStatus3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString1_Status1", string(value), objKey)
				}
				if this.MStatus3 == nil { // create map if not initialized.
					this.MStatus3 = make(map[string]EnumUseString1_Status1)
				}
			LOOP_MAP_m_status3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString1_Status1", string(value), objKey)
					}
					_, ok := EnumUseString1_Status1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString1_Status1(x1)
					this.MStatus3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status3
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *EnumUseString2) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(178)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.EnumUseString2.t_status1 | kind: EnumKind | GoName: TStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_status1")
	encoder.AppendString(this.TStatus1.String())
	// encode filed type of basic; | field: gojsontest.EnumUseString2.t_status2 | kind: EnumKind | GoName: TStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_status2")
	encoder.AppendString(this.TStatus2.String())
	// encode field type of list; | field: gojsontest.EnumUseString2.a_status1 | kind:EnumKind | goName: AStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status1")
	if this.AStatus1 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus1 {
			encoder.AppendString(this.AStatus1[i].String())
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.EnumUseString2.a_status2 | kind:EnumKind | goName: AStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status2")
	if this.AStatus2 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus2 {
			encoder.AppendString(this.AStatus2[i].String())
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.EnumUseString2.a_status3 | kind:EnumKind | goName: AStatus3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status3")
	if this.AStatus3 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus3 {
			encoder.AppendString(this.AStatus3[i].String())
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString2.m_status1 | keyKind: string | valueKind: enum | goName: MStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status1")
	if this.MStatus1 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus1 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v.String())
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString2.m_status2 | keyKind: string | valueKind: enum | goName: MStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status2")
	if this.MStatus2 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus2 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v.String())
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString2.m_status3 | keyKind: string | valueKind: enum | goName: MStatus3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status3")
	if this.MStatus3 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus3 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v.String())
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *EnumUseString2) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*EnumUseString2) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_status1":
			// decode filed type of basic; | field: gojsontest.EnumUseString2.t_status1 | kind: EnumKind | GoName: TStatus1
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type EnumUseString2_Status1", string(value), objKey)
			}
			x1, ok := EnumUseString2_Status1_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := EnumUseString2_Status1(x1)
			this.TStatus1 = x
		case objKey == "t_status2":
			// decode filed type of basic; | field: gojsontest.EnumUseString2.t_status2 | kind: EnumKind | GoName: TStatus2
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type EnumUseString2_Status2", string(value), objKey)
			}
			x1, ok := EnumUseString2_Status2_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := EnumUseString2_Status2(x1)
			this.TStatus2 = x
		case objKey == "a_status1":
			// decode filed type of list; | field: gojsontest.EnumUseString2.a_status1 | kind: EnumKind | GoName: AStatus1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString2_Status1", string(value), objKey)
				} else {
					this.AStatus1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString2_Status1", string(value), objKey)
				}
				if this.AStatus1 == nil {
					this.AStatus1 = make([]EnumUseString2_Status1, 0)
				}
				i := 0
				length := len(this.AStatus1)
			LOOP_LIST_a_status1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status1
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString2_Status1", string(value), objKey)
					}
					x1, ok := EnumUseString2_Status1_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString2_Status1(x1)
					if i < length {
						this.AStatus1[i] = x
					} else {
						this.AStatus1 = append(this.AStatus1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status1
					}
				}
				if i < length {
					this.AStatus1 = this.AStatus1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "a_status2":
			// decode filed type of list; | field: gojsontest.EnumUseString2.a_status2 | kind: EnumKind | GoName: AStatus2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString2_Status2", string(value), objKey)
				} else {
					this.AStatus2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString2_Status2", string(value), objKey)
				}
				if this.AStatus2 == nil {
					this.AStatus2 = make([]EnumUseString2_Status2, 0)
				}
				i := 0
				length := len(this.AStatus2)
			LOOP_LIST_a_status2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status2
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString2_Status2", string(value), objKey)
					}
					x1, ok := EnumUseString2_Status2_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString2_Status2(x1)
					if i < length {
						this.AStatus2[i] = x
					} else {
						this.AStatus2 = append(this.AStatus2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status2
					}
				}
				if i < length {
					this.AStatus2 = this.AStatus2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "a_status3":
			// decode filed type of list; | field: gojsontest.EnumUseString2.a_status3 | kind: EnumKind | GoName: AStatus3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString2_Status1", string(value), objKey)
				} else {
					this.AStatus3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString2_Status1", string(value), objKey)
				}
				if this.AStatus3 == nil {
					this.AStatus3 = make([]EnumUseString2_Status1, 0)
				}
				i := 0
				length := len(this.AStatus3)
			LOOP_LIST_a_status3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status3
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString2_Status1", string(value), objKey)
					}
					x1, ok := EnumUseString2_Status1_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString2_Status1(x1)
					if i < length {
						this.AStatus3[i] = x
					} else {
						this.AStatus3 = append(this.AStatus3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status3
					}
				}
				if i < length {
					this.AStatus3 = this.AStatus3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "m_status1":
			// decode filed type of map; | field: gojsontest.EnumUseString2.m_status1 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString2_Status1", string(value), objKey)
				} else {
					this.MStatus1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString2_Status1", string(value), objKey)
				}
				if this.MStatus1 == nil { // create map if not initialized.
					this.MStatus1 = make(map[string]EnumUseString2_Status1)
				}
			LOOP_MAP_m_status1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString2_Status1", string(value), objKey)
					}
					x1, ok := EnumUseString2_Status1_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString2_Status1(x1)
					this.MStatus1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m_status2":
			// decode filed type of map; | field: gojsontest.EnumUseString2.m_status2 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString2_Status2", string(value), objKey)
				} else {
					this.MStatus2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString2_Status2", string(value), objKey)
				}
				if this.MStatus2 == nil { // create map if not initialized.
					this.MStatus2 = make(map[string]EnumUseString2_Status2)
				}
			LOOP_MAP_m_status2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString2_Status2", string(value), objKey)
					}
					x1, ok := EnumUseString2_Status2_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString2_Status2(x1)
					this.MStatus2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m_status3":
			// decode filed type of map; | field: gojsontest.EnumUseString2.m_status3 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString2_Status1", string(value), objKey)
				} else {
					this.MStatus3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString2_Status1", string(value), objKey)
				}
				if this.MStatus3 == nil { // create map if not initialized.
					this.MStatus3 = make(map[string]EnumUseString2_Status1)
				}
			LOOP_MAP_m_status3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString2_Status1", string(value), objKey)
					}
					x1, ok := EnumUseString2_Status1_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString2_Status1(x1)
					this.MStatus3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status3
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *EnumUseString3) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(178)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.EnumUseString3.t_status1 | kind: EnumKind | GoName: TStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_status1")
	encoder.AppendInt32(int32(this.TStatus1.Number()))
	// encode filed type of basic; | field: gojsontest.EnumUseString3.t_status2 | kind: EnumKind | GoName: TStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_status2")
	encoder.AppendInt32(int32(this.TStatus2.Number()))
	// encode field type of list; | field: gojsontest.EnumUseString3.a_status1 | kind:EnumKind | goName: AStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status1")
	if this.AStatus1 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus1 {
			encoder.AppendInt32(int32(this.AStatus1[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.EnumUseString3.a_status2 | kind:EnumKind | goName: AStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status2")
	if this.AStatus2 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus2 {
			encoder.AppendInt32(int32(this.AStatus2[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.EnumUseString3.a_status3 | kind:EnumKind | goName: AStatus3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status3")
	if this.AStatus3 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus3 {
			encoder.AppendInt32(int32(this.AStatus3[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString3.m_status1 | keyKind: string | valueKind: enum | goName: MStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status1")
	if this.MStatus1 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus1 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString3.m_status2 | keyKind: string | valueKind: enum | goName: MStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status2")
	if this.MStatus2 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus2 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString3.m_status3 | keyKind: string | valueKind: enum | goName: MStatus3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status3")
	if this.MStatus3 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus3 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *EnumUseString3) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*EnumUseString3) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_status1":
			// decode filed type of basic; | field: gojsontest.EnumUseString3.t_status1 | kind: EnumKind | GoName: TStatus1
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type EnumUseString3_Status1", string(value), objKey)
			}
			_, ok := EnumUseString3_Status1_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := EnumUseString3_Status1(x1)
			this.TStatus1 = x
		case objKey == "t_status2":
			// decode filed type of basic; | field: gojsontest.EnumUseString3.t_status2 | kind: EnumKind | GoName: TStatus2
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type EnumUseString3_Status2", string(value), objKey)
			}
			_, ok := EnumUseString3_Status2_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := EnumUseString3_Status2(x1)
			this.TStatus2 = x
		case objKey == "a_status1":
			// decode filed type of list; | field: gojsontest.EnumUseString3.a_status1 | kind: EnumKind | GoName: AStatus1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString3_Status1", string(value), objKey)
				} else {
					this.AStatus1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString3_Status1", string(value), objKey)
				}
				if this.AStatus1 == nil {
					this.AStatus1 = make([]EnumUseString3_Status1, 0)
				}
				i := 0
				length := len(this.AStatus1)
			LOOP_LIST_a_status1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status1
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString3_Status1", string(value), objKey)
					}
					_, ok := EnumUseString3_Status1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString3_Status1(x1)
					if i < length {
						this.AStatus1[i] = x
					} else {
						this.AStatus1 = append(this.AStatus1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status1
					}
				}
				if i < length {
					this.AStatus1 = this.AStatus1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "a_status2":
			// decode filed type of list; | field: gojsontest.EnumUseString3.a_status2 | kind: EnumKind | GoName: AStatus2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString3_Status2", string(value), objKey)
				} else {
					this.AStatus2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString3_Status2", string(value), objKey)
				}
				if this.AStatus2 == nil {
					this.AStatus2 = make([]EnumUseString3_Status2, 0)
				}
				i := 0
				length := len(this.AStatus2)
			LOOP_LIST_a_status2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status2
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString3_Status2", string(value), objKey)
					}
					_, ok := EnumUseString3_Status2_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString3_Status2(x1)
					if i < length {
						this.AStatus2[i] = x
					} else {
						this.AStatus2 = append(this.AStatus2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status2
					}
				}
				if i < length {
					this.AStatus2 = this.AStatus2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "a_status3":
			// decode filed type of list; | field: gojsontest.EnumUseString3.a_status3 | kind: EnumKind | GoName: AStatus3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString3_Status1", string(value), objKey)
				} else {
					this.AStatus3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString3_Status1", string(value), objKey)
				}
				if this.AStatus3 == nil {
					this.AStatus3 = make([]EnumUseString3_Status1, 0)
				}
				i := 0
				length := len(this.AStatus3)
			LOOP_LIST_a_status3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status3
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString3_Status1", string(value), objKey)
					}
					_, ok := EnumUseString3_Status1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString3_Status1(x1)
					if i < length {
						this.AStatus3[i] = x
					} else {
						this.AStatus3 = append(this.AStatus3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status3
					}
				}
				if i < length {
					this.AStatus3 = this.AStatus3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "m_status1":
			// decode filed type of map; | field: gojsontest.EnumUseString3.m_status1 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString3_Status1", string(value), objKey)
				} else {
					this.MStatus1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString3_Status1", string(value), objKey)
				}
				if this.MStatus1 == nil { // create map if not initialized.
					this.MStatus1 = make(map[string]EnumUseString3_Status1)
				}
			LOOP_MAP_m_status1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString3_Status1", string(value), objKey)
					}
					_, ok := EnumUseString3_Status1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString3_Status1(x1)
					this.MStatus1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m_status2":
			// decode filed type of map; | field: gojsontest.EnumUseString3.m_status2 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString3_Status2", string(value), objKey)
				} else {
					this.MStatus2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString3_Status2", string(value), objKey)
				}
				if this.MStatus2 == nil { // create map if not initialized.
					this.MStatus2 = make(map[string]EnumUseString3_Status2)
				}
			LOOP_MAP_m_status2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString3_Status2", string(value), objKey)
					}
					_, ok := EnumUseString3_Status2_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString3_Status2(x1)
					this.MStatus2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m_status3":
			// decode filed type of map; | field: gojsontest.EnumUseString3.m_status3 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString3_Status1", string(value), objKey)
				} else {
					this.MStatus3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString3_Status1", string(value), objKey)
				}
				if this.MStatus3 == nil { // create map if not initialized.
					this.MStatus3 = make(map[string]EnumUseString3_Status1)
				}
			LOOP_MAP_m_status3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString3_Status1", string(value), objKey)
					}
					_, ok := EnumUseString3_Status1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString3_Status1(x1)
					this.MStatus3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status3
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *EnumUseString4) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(178)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.EnumUseString4.t_status1 | kind: EnumKind | GoName: TStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_status1")
	encoder.AppendString(this.TStatus1.String())
	// encode filed type of basic; | field: gojsontest.EnumUseString4.t_status2 | kind: EnumKind | GoName: TStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_status2")
	encoder.AppendInt32(int32(this.TStatus2.Number()))
	// encode field type of list; | field: gojsontest.EnumUseString4.a_status1 | kind:EnumKind | goName: AStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status1")
	if this.AStatus1 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus1 {
			encoder.AppendString(this.AStatus1[i].String())
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.EnumUseString4.a_status2 | kind:EnumKind | goName: AStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status2")
	if this.AStatus2 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus2 {
			encoder.AppendInt32(int32(this.AStatus2[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.EnumUseString4.a_status3 | kind:EnumKind | goName: AStatus3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status3")
	if this.AStatus3 != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus3 {
			encoder.AppendString(this.AStatus3[i].String())
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString4.m_status1 | keyKind: string | valueKind: enum | goName: MStatus1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status1")
	if this.MStatus1 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus1 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v.String())
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString4.m_status2 | keyKind: string | valueKind: enum | goName: MStatus2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status2")
	if this.MStatus2 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus2 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString4.m_status3 | keyKind: string | valueKind: enum | goName: MStatus3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status3")
	if this.MStatus3 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus3 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v.String())
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *EnumUseString4) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*EnumUseString4) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_status1":
			// decode filed type of basic; | field: gojsontest.EnumUseString4.t_status1 | kind: EnumKind | GoName: TStatus1
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type EnumUseString4_Status", string(value), objKey)
			}
			x1, ok := EnumUseString4_Status_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := EnumUseString4_Status(x1)
			this.TStatus1 = x
		case objKey == "t_status2":
			// decode filed type of basic; | field: gojsontest.EnumUseString4.t_status2 | kind: EnumKind | GoName: TStatus2
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type EnumUseString4_Status", string(value), objKey)
			}
			_, ok := EnumUseString4_Status_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := EnumUseString4_Status(x1)
			this.TStatus2 = x
		case objKey == "a_status1":
			// decode filed type of list; | field: gojsontest.EnumUseString4.a_status1 | kind: EnumKind | GoName: AStatus1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString4_Status", string(value), objKey)
				} else {
					this.AStatus1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString4_Status", string(value), objKey)
				}
				if this.AStatus1 == nil {
					this.AStatus1 = make([]EnumUseString4_Status, 0)
				}
				i := 0
				length := len(this.AStatus1)
			LOOP_LIST_a_status1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status1
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString4_Status", string(value), objKey)
					}
					x1, ok := EnumUseString4_Status_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString4_Status(x1)
					if i < length {
						this.AStatus1[i] = x
					} else {
						this.AStatus1 = append(this.AStatus1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status1
					}
				}
				if i < length {
					this.AStatus1 = this.AStatus1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "a_status2":
			// decode filed type of list; | field: gojsontest.EnumUseString4.a_status2 | kind: EnumKind | GoName: AStatus2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString4_Status", string(value), objKey)
				} else {
					this.AStatus2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString4_Status", string(value), objKey)
				}
				if this.AStatus2 == nil {
					this.AStatus2 = make([]EnumUseString4_Status, 0)
				}
				i := 0
				length := len(this.AStatus2)
			LOOP_LIST_a_status2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status2
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString4_Status", string(value), objKey)
					}
					_, ok := EnumUseString4_Status_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString4_Status(x1)
					if i < length {
						this.AStatus2[i] = x
					} else {
						this.AStatus2 = append(this.AStatus2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status2
					}
				}
				if i < length {
					this.AStatus2 = this.AStatus2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "a_status3":
			// decode filed type of list; | field: gojsontest.EnumUseString4.a_status3 | kind: EnumKind | GoName: AStatus3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString4_Status", string(value), objKey)
				} else {
					this.AStatus3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString4_Status", string(value), objKey)
				}
				if this.AStatus3 == nil {
					this.AStatus3 = make([]EnumUseString4_Status, 0)
				}
				i := 0
				length := len(this.AStatus3)
			LOOP_LIST_a_status3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status3
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString4_Status", string(value), objKey)
					}
					x1, ok := EnumUseString4_Status_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString4_Status(x1)
					if i < length {
						this.AStatus3[i] = x
					} else {
						this.AStatus3 = append(this.AStatus3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status3
					}
				}
				if i < length {
					this.AStatus3 = this.AStatus3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "m_status1":
			// decode filed type of map; | field: gojsontest.EnumUseString4.m_status1 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString4_Status", string(value), objKey)
				} else {
					this.MStatus1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString4_Status", string(value), objKey)
				}
				if this.MStatus1 == nil { // create map if not initialized.
					this.MStatus1 = make(map[string]EnumUseString4_Status)
				}
			LOOP_MAP_m_status1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString4_Status", string(value), objKey)
					}
					x1, ok := EnumUseString4_Status_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString4_Status(x1)
					this.MStatus1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m_status2":
			// decode filed type of map; | field: gojsontest.EnumUseString4.m_status2 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString4_Status", string(value), objKey)
				} else {
					this.MStatus2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString4_Status", string(value), objKey)
				}
				if this.MStatus2 == nil { // create map if not initialized.
					this.MStatus2 = make(map[string]EnumUseString4_Status)
				}
			LOOP_MAP_m_status2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString4_Status", string(value), objKey)
					}
					_, ok := EnumUseString4_Status_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString4_Status(x1)
					this.MStatus2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "m_status3":
			// decode filed type of map; | field: gojsontest.EnumUseString4.m_status3 | keyKind: StringKind | valueKind: EnumKind | goName: MStatus3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString4_Status", string(value), objKey)
				} else {
					this.MStatus3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString4_Status", string(value), objKey)
				}
				if this.MStatus3 == nil { // create map if not initialized.
					this.MStatus3 = make(map[string]EnumUseString4_Status)
				}
			LOOP_MAP_m_status3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString4_Status", string(value), objKey)
					}
					x1, ok := EnumUseString4_Status_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString4_Status(x1)
					this.MStatus3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status3
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *EnumUseString5) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(62)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.EnumUseString5.t_status | kind: EnumKind | GoName: TStatus | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_status")
	encoder.AppendString(this.TStatus.String())
	// encode field type of list; | field: gojsontest.EnumUseString5.a_status | kind:EnumKind | goName: AStatus | omitempty: false | ignore: false
	encoder.AppendObjectKey("a_status")
	if this.AStatus != nil {
		encoder.AppendListBegin()
		for i := range this.AStatus {
			encoder.AppendString(this.AStatus[i].String())
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.EnumUseString5.m_status | keyKind: string | valueKind: enum | goName: MStatus | omitempty: false | ignore: false
	encoder.AppendObjectKey("m_status")
	if this.MStatus != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MStatus {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v.String())
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *EnumUseString5) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*EnumUseString5) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_status":
			// decode filed type of basic; | field: gojsontest.EnumUseString5.t_status | kind: EnumKind | GoName: TStatus
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type EnumUseString5_Status", string(value), objKey)
			}
			x1, ok := EnumUseString5_Status_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := EnumUseString5_Status(x1)
			this.TStatus = x
		case objKey == "a_status":
			// decode filed type of list; | field: gojsontest.EnumUseString5.a_status | kind: EnumKind | GoName: AStatus
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString5_Status", string(value), objKey)
				} else {
					this.AStatus = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumUseString5_Status", string(value), objKey)
				}
				if this.AStatus == nil {
					this.AStatus = make([]EnumUseString5_Status, 0)
				}
				i := 0
				length := len(this.AStatus)
			LOOP_LIST_a_status:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_a_status
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []EnumUseString5_Status", string(value), objKey)
					}
					x1, ok := EnumUseString5_Status_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString5_Status(x1)
					if i < length {
						this.AStatus[i] = x
					} else {
						this.AStatus = append(this.AStatus, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_a_status
					}
				}
				if i < length {
					this.AStatus = this.AStatus[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "m_status":
			// decode filed type of map; | field: gojsontest.EnumUseString5.m_status | keyKind: StringKind | valueKind: EnumKind | goName: MStatus
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString5_Status", string(value), objKey)
				} else {
					this.MStatus = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]EnumUseString5_Status", string(value), objKey)
				}
				if this.MStatus == nil { // create map if not initialized.
					this.MStatus = make(map[string]EnumUseString5_Status)
				}
			LOOP_MAP_m_status:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_m_status
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]EnumUseString5_Status", string(value), objKey)
					}
					x1, ok := EnumUseString5_Status_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := EnumUseString5_Status(x1)
					this.MStatus[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_m_status
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *SerializeBytes1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(230)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.SerializeBytes1.bytes1 | kind: BytesKind | GoName: Bytes1 | omitempty: true | ignore: false
	if len(this.Bytes1) != 0 {
		encoder.AppendObjectKey("bytes1")
		encoder.AppendBytes(this.Bytes1)
	}
	// encode filed type of basic; | field: gojsontest.SerializeBytes1.bytes2 | kind: BytesKind | GoName: Bytes2 | omitempty: true | ignore: false
	if len(this.Bytes2) != 0 {
		encoder.AppendObjectKey("bytes2")
		encoder.AppendBytes(this.Bytes2)
	}
	// encode filed type of basic; | field: gojsontest.SerializeBytes1.bytes3 | kind: BytesKind | GoName: Bytes3 | omitempty: true | ignore: false
	if len(this.Bytes3) != 0 {
		encoder.AppendObjectKey("bytes3")
		encoder.AppendBytes(this.Bytes3)
	}
	// encode field type of list; | field: gojsontest.SerializeBytes1.array_bytes1 | kind:BytesKind | goName: ArrayBytes1 | omitempty: true | ignore: false
	if len(this.ArrayBytes1) != 0 {
		encoder.AppendObjectKey("array_bytes1")
		encoder.AppendListBegin()
		for i := range this.ArrayBytes1 {
			encoder.AppendBytes(this.ArrayBytes1[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeBytes1.array_bytes2 | kind:BytesKind | goName: ArrayBytes2 | omitempty: true | ignore: false
	if len(this.ArrayBytes2) != 0 {
		encoder.AppendObjectKey("array_bytes2")
		encoder.AppendListBegin()
		for i := range this.ArrayBytes2 {
			encoder.AppendBytes(this.ArrayBytes2[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeBytes1.array_bytes3 | kind:BytesKind | goName: ArrayBytes3 | omitempty: true | ignore: false
	if len(this.ArrayBytes3) != 0 {
		encoder.AppendObjectKey("array_bytes3")
		encoder.AppendListBegin()
		for i := range this.ArrayBytes3 {
			encoder.AppendBytes(this.ArrayBytes3[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeBytes1.map_bytes1 | keyKind: string | valueKind: bytes | goName: MapBytes1 | omitempty: true | ignore: false
	if len(this.MapBytes1) != 0 {
		encoder.AppendObjectKey("map_bytes1")
		encoder.AppendObjectBegin()
		for k, v := range this.MapBytes1 {
			encoder.AppendObjectKey(k)
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeBytes1.map_bytes2 | keyKind: string | valueKind: bytes | goName: MapBytes2 | omitempty: true | ignore: false
	if len(this.MapBytes2) != 0 {
		encoder.AppendObjectKey("map_bytes2")
		encoder.AppendObjectBegin()
		for k, v := range this.MapBytes2 {
			encoder.AppendObjectKey(k)
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeBytes1.map_bytes3 | keyKind: string | valueKind: bytes | goName: MapBytes3 | omitempty: true | ignore: false
	if len(this.MapBytes3) != 0 {
		encoder.AppendObjectKey("map_bytes3")
		encoder.AppendObjectBegin()
		for k, v := range this.MapBytes3 {
			encoder.AppendObjectKey(k)
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeBytes1.map_bytes4 | keyKind: string | valueKind: bytes | goName: MapBytes4 | omitempty: true | ignore: false
	if len(this.MapBytes4) != 0 {
		encoder.AppendObjectKey("map_bytes4")
		encoder.AppendObjectBegin()
		for k, v := range this.MapBytes4 {
			encoder.AppendObjectKey(k)
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *SerializeBytes1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*SerializeBytes1) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "bytes1":
			// decode filed type of basic; | field: gojsontest.SerializeBytes1.bytes1 | kind: BytesKind | GoName: Bytes1
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes1 = x
		case objKey == "bytes2":
			// decode filed type of basic; | field: gojsontest.SerializeBytes1.bytes2 | kind: BytesKind | GoName: Bytes2
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes2 = x
		case objKey == "bytes3":
			// decode filed type of basic; | field: gojsontest.SerializeBytes1.bytes3 | kind: BytesKind | GoName: Bytes3
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes3 = x
		case objKey == "array_bytes1":
			// decode filed type of list; | field: gojsontest.SerializeBytes1.array_bytes1 | kind: BytesKind | GoName: ArrayBytes1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes1 == nil {
					this.ArrayBytes1 = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes1)
			LOOP_LIST_array_bytes1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bytes1
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes1[i] = x
					} else {
						this.ArrayBytes1 = append(this.ArrayBytes1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bytes1
					}
				}
				if i < length {
					this.ArrayBytes1 = this.ArrayBytes1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bytes2":
			// decode filed type of list; | field: gojsontest.SerializeBytes1.array_bytes2 | kind: BytesKind | GoName: ArrayBytes2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes2 == nil {
					this.ArrayBytes2 = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes2)
			LOOP_LIST_array_bytes2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bytes2
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes2[i] = x
					} else {
						this.ArrayBytes2 = append(this.ArrayBytes2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bytes2
					}
				}
				if i < length {
					this.ArrayBytes2 = this.ArrayBytes2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bytes3":
			// decode filed type of list; | field: gojsontest.SerializeBytes1.array_bytes3 | kind: BytesKind | GoName: ArrayBytes3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes3 == nil {
					this.ArrayBytes3 = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes3)
			LOOP_LIST_array_bytes3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bytes3
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes3[i] = x
					} else {
						this.ArrayBytes3 = append(this.ArrayBytes3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bytes3
					}
				}
				if i < length {
					this.ArrayBytes3 = this.ArrayBytes3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "map_bytes1":
			// decode filed type of map; | field: gojsontest.SerializeBytes1.map_bytes1 | keyKind: StringKind | valueKind: BytesKind | goName: MapBytes1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				} else {
					this.MapBytes1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				}
				if this.MapBytes1 == nil { // create map if not initialized.
					this.MapBytes1 = make(map[string][]byte)
				}
			LOOP_MAP_map_bytes1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_bytes1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapBytes1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_bytes1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_bytes2":
			// decode filed type of map; | field: gojsontest.SerializeBytes1.map_bytes2 | keyKind: StringKind | valueKind: BytesKind | goName: MapBytes2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				} else {
					this.MapBytes2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				}
				if this.MapBytes2 == nil { // create map if not initialized.
					this.MapBytes2 = make(map[string][]byte)
				}
			LOOP_MAP_map_bytes2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_bytes2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapBytes2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_bytes2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_bytes3":
			// decode filed type of map; | field: gojsontest.SerializeBytes1.map_bytes3 | keyKind: StringKind | valueKind: BytesKind | goName: MapBytes3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				} else {
					this.MapBytes3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				}
				if this.MapBytes3 == nil { // create map if not initialized.
					this.MapBytes3 = make(map[string][]byte)
				}
			LOOP_MAP_map_bytes3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_bytes3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapBytes3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_bytes3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_bytes4":
			// decode filed type of map; | field: gojsontest.SerializeBytes1.map_bytes4 | keyKind: StringKind | valueKind: BytesKind | goName: MapBytes4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				} else {
					this.MapBytes4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				}
				if this.MapBytes4 == nil { // create map if not initialized.
					this.MapBytes4 = make(map[string][]byte)
				}
			LOOP_MAP_map_bytes4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_bytes4
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapBytes4[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_bytes4
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *SerializeBytes2) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(230)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.SerializeBytes2.bytes1 | kind: BytesKind | GoName: Bytes1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("bytes1")
	encoder.AppendBytes(this.Bytes1)
	// encode filed type of basic; | field: gojsontest.SerializeBytes2.bytes2 | kind: BytesKind | GoName: Bytes2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("bytes2")
	encoder.AppendBytes(this.Bytes2)
	// encode filed type of basic; | field: gojsontest.SerializeBytes2.bytes3 | kind: BytesKind | GoName: Bytes3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("bytes3")
	encoder.AppendBytes(this.Bytes3)
	// encode field type of list; | field: gojsontest.SerializeBytes2.array_bytes1 | kind:BytesKind | goName: ArrayBytes1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_bytes1")
	if this.ArrayBytes1 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayBytes1 {
			encoder.AppendBytes(this.ArrayBytes1[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeBytes2.array_bytes2 | kind:BytesKind | goName: ArrayBytes2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_bytes2")
	if this.ArrayBytes2 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayBytes2 {
			encoder.AppendBytes(this.ArrayBytes2[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeBytes2.array_bytes3 | kind:BytesKind | goName: ArrayBytes3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_bytes3")
	if this.ArrayBytes3 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayBytes3 {
			encoder.AppendBytes(this.ArrayBytes3[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeBytes2.map_bytes1 | keyKind: string | valueKind: bytes | goName: MapBytes1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_bytes1")
	if this.MapBytes1 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapBytes1 {
			encoder.AppendObjectKey(k)
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeBytes2.map_bytes2 | keyKind: string | valueKind: bytes | goName: MapBytes2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_bytes2")
	if this.MapBytes2 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapBytes2 {
			encoder.AppendObjectKey(k)
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeBytes2.map_bytes3 | keyKind: string | valueKind: bytes | goName: MapBytes3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_bytes3")
	if this.MapBytes3 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapBytes3 {
			encoder.AppendObjectKey(k)
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeBytes2.map_bytes4 | keyKind: string | valueKind: bytes | goName: MapBytes4 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_bytes4")
	if this.MapBytes4 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapBytes4 {
			encoder.AppendObjectKey(k)
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *SerializeBytes2) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*SerializeBytes2) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "bytes1":
			// decode filed type of basic; | field: gojsontest.SerializeBytes2.bytes1 | kind: BytesKind | GoName: Bytes1
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes1 = x
		case objKey == "bytes2":
			// decode filed type of basic; | field: gojsontest.SerializeBytes2.bytes2 | kind: BytesKind | GoName: Bytes2
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes2 = x
		case objKey == "bytes3":
			// decode filed type of basic; | field: gojsontest.SerializeBytes2.bytes3 | kind: BytesKind | GoName: Bytes3
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes3 = x
		case objKey == "array_bytes1":
			// decode filed type of list; | field: gojsontest.SerializeBytes2.array_bytes1 | kind: BytesKind | GoName: ArrayBytes1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes1 == nil {
					this.ArrayBytes1 = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes1)
			LOOP_LIST_array_bytes1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bytes1
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes1[i] = x
					} else {
						this.ArrayBytes1 = append(this.ArrayBytes1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bytes1
					}
				}
				if i < length {
					this.ArrayBytes1 = this.ArrayBytes1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bytes2":
			// decode filed type of list; | field: gojsontest.SerializeBytes2.array_bytes2 | kind: BytesKind | GoName: ArrayBytes2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes2 == nil {
					this.ArrayBytes2 = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes2)
			LOOP_LIST_array_bytes2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bytes2
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes2[i] = x
					} else {
						this.ArrayBytes2 = append(this.ArrayBytes2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bytes2
					}
				}
				if i < length {
					this.ArrayBytes2 = this.ArrayBytes2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bytes3":
			// decode filed type of list; | field: gojsontest.SerializeBytes2.array_bytes3 | kind: BytesKind | GoName: ArrayBytes3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes3 == nil {
					this.ArrayBytes3 = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes3)
			LOOP_LIST_array_bytes3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bytes3
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes3[i] = x
					} else {
						this.ArrayBytes3 = append(this.ArrayBytes3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bytes3
					}
				}
				if i < length {
					this.ArrayBytes3 = this.ArrayBytes3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "map_bytes1":
			// decode filed type of map; | field: gojsontest.SerializeBytes2.map_bytes1 | keyKind: StringKind | valueKind: BytesKind | goName: MapBytes1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				} else {
					this.MapBytes1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				}
				if this.MapBytes1 == nil { // create map if not initialized.
					this.MapBytes1 = make(map[string][]byte)
				}
			LOOP_MAP_map_bytes1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_bytes1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapBytes1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_bytes1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_bytes2":
			// decode filed type of map; | field: gojsontest.SerializeBytes2.map_bytes2 | keyKind: StringKind | valueKind: BytesKind | goName: MapBytes2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				} else {
					this.MapBytes2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				}
				if this.MapBytes2 == nil { // create map if not initialized.
					this.MapBytes2 = make(map[string][]byte)
				}
			LOOP_MAP_map_bytes2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_bytes2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapBytes2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_bytes2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_bytes3":
			// decode filed type of map; | field: gojsontest.SerializeBytes2.map_bytes3 | keyKind: StringKind | valueKind: BytesKind | goName: MapBytes3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				} else {
					this.MapBytes3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				}
				if this.MapBytes3 == nil { // create map if not initialized.
					this.MapBytes3 = make(map[string][]byte)
				}
			LOOP_MAP_map_bytes3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_bytes3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapBytes3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_bytes3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_bytes4":
			// decode filed type of map; | field: gojsontest.SerializeBytes2.map_bytes4 | keyKind: StringKind | valueKind: BytesKind | goName: MapBytes4
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				} else {
					this.MapBytes4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), objKey)
				}
				if this.MapBytes4 == nil { // create map if not initialized.
					this.MapBytes4 = make(map[string][]byte)
				}
			LOOP_MAP_map_bytes4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_bytes4
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapBytes4[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_bytes4
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *SerializeOmitempty1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(578)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.SerializeOmitempty1.string1 | kind: StringKind | GoName: String1 | omitempty: true | ignore: false
	if this.String1 != "" {
		encoder.AppendObjectKey("string1")
		encoder.AppendString(this.String1)
	}
	// encode filed type of basic; | field: gojsontest.SerializeOmitempty1.string2 | kind: StringKind | GoName: String2 | omitempty: true | ignore: false
	if this.String2 != "" {
		encoder.AppendObjectKey("string2")
		encoder.AppendString(this.String2)
	}
	// encode filed type of basic; | field: gojsontest.SerializeOmitempty1.bytes1 | kind: BytesKind | GoName: Bytes1 | omitempty: true | ignore: false
	if len(this.Bytes1) != 0 {
		encoder.AppendObjectKey("bytes1")
		encoder.AppendBytes(this.Bytes1)
	}
	// encode filed type of basic; | field: gojsontest.SerializeOmitempty1.bytes2 | kind: BytesKind | GoName: Bytes2 | omitempty: true | ignore: false
	if len(this.Bytes2) != 0 {
		encoder.AppendObjectKey("bytes2")
		encoder.AppendBytes(this.Bytes2)
	}
	// encode filed type of basic; | field: gojsontest.SerializeOmitempty1.bytes3 | kind: BytesKind | GoName: Bytes3 | omitempty: true | ignore: false
	if len(this.Bytes3) != 0 {
		encoder.AppendObjectKey("bytes3")
		encoder.AppendBytes(this.Bytes3)
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty1.array_string1 | kind:StringKind | goName: ArrayString1 | omitempty: true | ignore: false
	if len(this.ArrayString1) != 0 {
		encoder.AppendObjectKey("array_string1")
		encoder.AppendListBegin()
		for i := range this.ArrayString1 {
			encoder.AppendString(this.ArrayString1[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty1.array_string2 | kind:StringKind | goName: ArrayString2 | omitempty: true | ignore: false
	if len(this.ArrayString2) != 0 {
		encoder.AppendObjectKey("array_string2")
		encoder.AppendListBegin()
		for i := range this.ArrayString2 {
			encoder.AppendString(this.ArrayString2[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty1.array_string3 | kind:StringKind | goName: ArrayString3 | omitempty: true | ignore: false
	if len(this.ArrayString3) != 0 {
		encoder.AppendObjectKey("array_string3")
		encoder.AppendListBegin()
		for i := range this.ArrayString3 {
			encoder.AppendString(this.ArrayString3[i])
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty1.array_message1 | kind:MessageKind | goName: ArrayMessage1 | omitempty: true | ignore: false
	if len(this.ArrayMessage1) != 0 {
		encoder.AppendObjectKey("array_message1")
		encoder.AppendListBegin()
		for i := range this.ArrayMessage1 {
			err = encoder.AppendInterface(this.ArrayMessage1[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty1.array_message2 | kind:MessageKind | goName: ArrayMessage2 | omitempty: true | ignore: false
	if len(this.ArrayMessage2) != 0 {
		encoder.AppendObjectKey("array_message2")
		encoder.AppendListBegin()
		for i := range this.ArrayMessage2 {
			err = encoder.AppendInterface(this.ArrayMessage2[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty1.array_message3 | kind:MessageKind | goName: ArrayMessage3 | omitempty: true | ignore: false
	if len(this.ArrayMessage3) != 0 {
		encoder.AppendObjectKey("array_message3")
		encoder.AppendListBegin()
		for i := range this.ArrayMessage3 {
			err = encoder.AppendInterface(this.ArrayMessage3[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty1.array_enum1 | kind:EnumKind | goName: ArrayEnum1 | omitempty: true | ignore: false
	if len(this.ArrayEnum1) != 0 {
		encoder.AppendObjectKey("array_enum1")
		encoder.AppendListBegin()
		for i := range this.ArrayEnum1 {
			encoder.AppendInt32(int32(this.ArrayEnum1[i].Number()))
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty1.array_enum2 | kind:EnumKind | goName: ArrayEnum2 | omitempty: true | ignore: false
	if len(this.ArrayEnum2) != 0 {
		encoder.AppendObjectKey("array_enum2")
		encoder.AppendListBegin()
		for i := range this.ArrayEnum2 {
			encoder.AppendInt32(int32(this.ArrayEnum2[i].Number()))
		}
		encoder.AppendListEnd()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty1.array_enum3 | kind:EnumKind | goName: ArrayEnum3 | omitempty: true | ignore: false
	if len(this.ArrayEnum3) != 0 {
		encoder.AppendObjectKey("array_enum3")
		encoder.AppendListBegin()
		for i := range this.ArrayEnum3 {
			encoder.AppendInt32(int32(this.ArrayEnum3[i].Number()))
		}
		encoder.AppendListEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty1.map_string1 | keyKind: string | valueKind: string | goName: MapString1 | omitempty: true | ignore: false
	if len(this.MapString1) != 0 {
		encoder.AppendObjectKey("map_string1")
		encoder.AppendObjectBegin()
		for k, v := range this.MapString1 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty1.map_string2 | keyKind: string | valueKind: string | goName: MapString2 | omitempty: true | ignore: false
	if len(this.MapString2) != 0 {
		encoder.AppendObjectKey("map_string2")
		encoder.AppendObjectBegin()
		for k, v := range this.MapString2 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty1.map_string3 | keyKind: string | valueKind: string | goName: MapString3 | omitempty: true | ignore: false
	if len(this.MapString3) != 0 {
		encoder.AppendObjectKey("map_string3")
		encoder.AppendObjectBegin()
		for k, v := range this.MapString3 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty1.map_message1 | keyKind: string | valueKind: message | goName: MapMessage1 | omitempty: true | ignore: false
	if len(this.MapMessage1) != 0 {
		encoder.AppendObjectKey("map_message1")
		encoder.AppendObjectBegin()
		for k, v := range this.MapMessage1 {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty1.map_message2 | keyKind: string | valueKind: message | goName: MapMessage2 | omitempty: true | ignore: false
	if len(this.MapMessage2) != 0 {
		encoder.AppendObjectKey("map_message2")
		encoder.AppendObjectBegin()
		for k, v := range this.MapMessage2 {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty1.map_message3 | keyKind: string | valueKind: message | goName: MapMessage3 | omitempty: true | ignore: false
	if len(this.MapMessage3) != 0 {
		encoder.AppendObjectKey("map_message3")
		encoder.AppendObjectBegin()
		for k, v := range this.MapMessage3 {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty1.map_enum1 | keyKind: string | valueKind: enum | goName: MapEnum1 | omitempty: true | ignore: false
	if len(this.MapEnum1) != 0 {
		encoder.AppendObjectKey("map_enum1")
		encoder.AppendObjectBegin()
		for k, v := range this.MapEnum1 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty1.map_enum2 | keyKind: string | valueKind: enum | goName: MapEnum2 | omitempty: true | ignore: false
	if len(this.MapEnum2) != 0 {
		encoder.AppendObjectKey("map_enum2")
		encoder.AppendObjectBegin()
		for k, v := range this.MapEnum2 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty1.map_enum3 | keyKind: string | valueKind: enum | goName: MapEnum3 | omitempty: true | ignore: false
	if len(this.MapEnum3) != 0 {
		encoder.AppendObjectKey("map_enum3")
		encoder.AppendObjectBegin()
		for k, v := range this.MapEnum3 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *SerializeOmitempty1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*SerializeOmitempty1) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "string1":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty1.string1 | kind: StringKind | GoName: String1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.String1 = x
		case objKey == "string2":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty1.string2 | kind: StringKind | GoName: String2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.String2 = x
		case objKey == "bytes1":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty1.bytes1 | kind: BytesKind | GoName: Bytes1
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes1 = x
		case objKey == "bytes2":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty1.bytes2 | kind: BytesKind | GoName: Bytes2
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes2 = x
		case objKey == "bytes3":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty1.bytes3 | kind: BytesKind | GoName: Bytes3
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes3 = x
		case objKey == "array_string1":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty1.array_string1 | kind: StringKind | GoName: ArrayString1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString1 == nil {
					this.ArrayString1 = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString1)
			LOOP_LIST_array_string1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_string1
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString1[i] = x
					} else {
						this.ArrayString1 = append(this.ArrayString1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_string1
					}
				}
				if i < length {
					this.ArrayString1 = this.ArrayString1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_string2":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty1.array_string2 | kind: StringKind | GoName: ArrayString2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString2 == nil {
					this.ArrayString2 = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString2)
			LOOP_LIST_array_string2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_string2
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString2[i] = x
					} else {
						this.ArrayString2 = append(this.ArrayString2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_string2
					}
				}
				if i < length {
					this.ArrayString2 = this.ArrayString2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_string3":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty1.array_string3 | kind: StringKind | GoName: ArrayString3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString3 == nil {
					this.ArrayString3 = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString3)
			LOOP_LIST_array_string3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_string3
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString3[i] = x
					} else {
						this.ArrayString3 = append(this.ArrayString3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_string3
					}
				}
				if i < length {
					this.ArrayString3 = this.ArrayString3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_message1":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty1.array_message1 | kind: MessageKind | GoName: ArrayMessage1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.ArrayMessage1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.ArrayMessage1 == nil {
					this.ArrayMessage1 = make([]*gojsonexternal.ExternalMessage1, 0)
				}
				i := 0
				length := len(this.ArrayMessage1)
			LOOP_LIST_array_message1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_message1
					}
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayMessage1[i]
						}
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayMessage1[i] = x
					} else {
						this.ArrayMessage1 = append(this.ArrayMessage1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_message1
					}
				}
				if i < length {
					this.ArrayMessage1 = this.ArrayMessage1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_message2":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty1.array_message2 | kind: MessageKind | GoName: ArrayMessage2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.ArrayMessage2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.ArrayMessage2 == nil {
					this.ArrayMessage2 = make([]*gojsonexternal.ExternalMessage1, 0)
				}
				i := 0
				length := len(this.ArrayMessage2)
			LOOP_LIST_array_message2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_message2
					}
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayMessage2[i]
						}
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayMessage2[i] = x
					} else {
						this.ArrayMessage2 = append(this.ArrayMessage2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_message2
					}
				}
				if i < length {
					this.ArrayMessage2 = this.ArrayMessage2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_message3":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty1.array_message3 | kind: MessageKind | GoName: ArrayMessage3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.ArrayMessage3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.ArrayMessage3 == nil {
					this.ArrayMessage3 = make([]*gojsonexternal.ExternalMessage1, 0)
				}
				i := 0
				length := len(this.ArrayMessage3)
			LOOP_LIST_array_message3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_message3
					}
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayMessage3[i]
						}
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayMessage3[i] = x
					} else {
						this.ArrayMessage3 = append(this.ArrayMessage3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_message3
					}
				}
				if i < length {
					this.ArrayMessage3 = this.ArrayMessage3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_enum1":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty1.array_enum1 | kind: EnumKind | GoName: ArrayEnum1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.ArrayEnum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.ArrayEnum1 == nil {
					this.ArrayEnum1 = make([]gojsonexternal.ExternalEnum1, 0)
				}
				i := 0
				length := len(this.ArrayEnum1)
			LOOP_LIST_array_enum1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_enum1
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					if i < length {
						this.ArrayEnum1[i] = x
					} else {
						this.ArrayEnum1 = append(this.ArrayEnum1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_enum1
					}
				}
				if i < length {
					this.ArrayEnum1 = this.ArrayEnum1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_enum2":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty1.array_enum2 | kind: EnumKind | GoName: ArrayEnum2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.ArrayEnum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.ArrayEnum2 == nil {
					this.ArrayEnum2 = make([]gojsonexternal.ExternalEnum1, 0)
				}
				i := 0
				length := len(this.ArrayEnum2)
			LOOP_LIST_array_enum2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_enum2
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					if i < length {
						this.ArrayEnum2[i] = x
					} else {
						this.ArrayEnum2 = append(this.ArrayEnum2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_enum2
					}
				}
				if i < length {
					this.ArrayEnum2 = this.ArrayEnum2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_enum3":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty1.array_enum3 | kind: EnumKind | GoName: ArrayEnum3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.ArrayEnum3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.ArrayEnum3 == nil {
					this.ArrayEnum3 = make([]gojsonexternal.ExternalEnum1, 0)
				}
				i := 0
				length := len(this.ArrayEnum3)
			LOOP_LIST_array_enum3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_enum3
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					if i < length {
						this.ArrayEnum3[i] = x
					} else {
						this.ArrayEnum3 = append(this.ArrayEnum3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_enum3
					}
				}
				if i < length {
					this.ArrayEnum3 = this.ArrayEnum3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "map_string1":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty1.map_string1 | keyKind: StringKind | valueKind: StringKind | goName: MapString1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				} else {
					this.MapString1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				}
				if this.MapString1 == nil { // create map if not initialized.
					this.MapString1 = make(map[string]string)
				}
			LOOP_MAP_map_string1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]string", string(value), objKey)
						}
					}
					this.MapString1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string2":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty1.map_string2 | keyKind: StringKind | valueKind: StringKind | goName: MapString2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				} else {
					this.MapString2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				}
				if this.MapString2 == nil { // create map if not initialized.
					this.MapString2 = make(map[string]string)
				}
			LOOP_MAP_map_string2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]string", string(value), objKey)
						}
					}
					this.MapString2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string3":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty1.map_string3 | keyKind: StringKind | valueKind: StringKind | goName: MapString3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				} else {
					this.MapString3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				}
				if this.MapString3 == nil { // create map if not initialized.
					this.MapString3 = make(map[string]string)
				}
			LOOP_MAP_map_string3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]string", string(value), objKey)
						}
					}
					this.MapString3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_message1":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty1.map_message1 | keyKind: StringKind | valueKind: MessageKind | goName: MapMessage1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.MapMessage1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.MapMessage1 == nil { // create map if not initialized.
					this.MapMessage1 = make(map[string]*gojsonexternal.ExternalMessage1)
				}
			LOOP_MAP_map_message1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_message1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapMessage1[mapKey]
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapMessage1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_message1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_message2":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty1.map_message2 | keyKind: StringKind | valueKind: MessageKind | goName: MapMessage2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.MapMessage2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.MapMessage2 == nil { // create map if not initialized.
					this.MapMessage2 = make(map[string]*gojsonexternal.ExternalMessage1)
				}
			LOOP_MAP_map_message2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_message2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapMessage2[mapKey]
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapMessage2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_message2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_message3":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty1.map_message3 | keyKind: StringKind | valueKind: MessageKind | goName: MapMessage3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.MapMessage3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.MapMessage3 == nil { // create map if not initialized.
					this.MapMessage3 = make(map[string]*gojsonexternal.ExternalMessage1)
				}
			LOOP_MAP_map_message3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_message3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapMessage3[mapKey]
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapMessage3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_message3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_enum1":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty1.map_enum1 | keyKind: StringKind | valueKind: EnumKind | goName: MapEnum1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.MapEnum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.MapEnum1 == nil { // create map if not initialized.
					this.MapEnum1 = make(map[string]gojsonexternal.ExternalEnum1)
				}
			LOOP_MAP_map_enum1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_enum1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					this.MapEnum1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_enum1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_enum2":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty1.map_enum2 | keyKind: StringKind | valueKind: EnumKind | goName: MapEnum2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.MapEnum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.MapEnum2 == nil { // create map if not initialized.
					this.MapEnum2 = make(map[string]gojsonexternal.ExternalEnum1)
				}
			LOOP_MAP_map_enum2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_enum2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					this.MapEnum2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_enum2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_enum3":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty1.map_enum3 | keyKind: StringKind | valueKind: EnumKind | goName: MapEnum3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.MapEnum3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.MapEnum3 == nil { // create map if not initialized.
					this.MapEnum3 = make(map[string]gojsonexternal.ExternalEnum1)
				}
			LOOP_MAP_map_enum3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_enum3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					this.MapEnum3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_enum3
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *SerializeOmitempty2) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(578)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.SerializeOmitempty2.string1 | kind: StringKind | GoName: String1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("string1")
	encoder.AppendString(this.String1)
	// encode filed type of basic; | field: gojsontest.SerializeOmitempty2.string2 | kind: StringKind | GoName: String2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("string2")
	encoder.AppendString(this.String2)
	// encode filed type of basic; | field: gojsontest.SerializeOmitempty2.bytes1 | kind: BytesKind | GoName: Bytes1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("bytes1")
	encoder.AppendBytes(this.Bytes1)
	// encode filed type of basic; | field: gojsontest.SerializeOmitempty2.bytes2 | kind: BytesKind | GoName: Bytes2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("bytes2")
	encoder.AppendBytes(this.Bytes2)
	// encode filed type of basic; | field: gojsontest.SerializeOmitempty2.bytes3 | kind: BytesKind | GoName: Bytes3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("bytes3")
	encoder.AppendBytes(this.Bytes3)
	// encode field type of list; | field: gojsontest.SerializeOmitempty2.array_string1 | kind:StringKind | goName: ArrayString1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_string1")
	if this.ArrayString1 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayString1 {
			encoder.AppendString(this.ArrayString1[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty2.array_string2 | kind:StringKind | goName: ArrayString2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_string2")
	if this.ArrayString2 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayString2 {
			encoder.AppendString(this.ArrayString2[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty2.array_string3 | kind:StringKind | goName: ArrayString3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_string3")
	if this.ArrayString3 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayString3 {
			encoder.AppendString(this.ArrayString3[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty2.array_message1 | kind:MessageKind | goName: ArrayMessage1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_message1")
	if this.ArrayMessage1 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayMessage1 {
			err = encoder.AppendInterface(this.ArrayMessage1[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty2.array_message2 | kind:MessageKind | goName: ArrayMessage2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_message2")
	if this.ArrayMessage2 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayMessage2 {
			err = encoder.AppendInterface(this.ArrayMessage2[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty2.array_message3 | kind:MessageKind | goName: ArrayMessage3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_message3")
	if this.ArrayMessage3 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayMessage3 {
			err = encoder.AppendInterface(this.ArrayMessage3[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty2.array_enum1 | kind:EnumKind | goName: ArrayEnum1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_enum1")
	if this.ArrayEnum1 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayEnum1 {
			encoder.AppendInt32(int32(this.ArrayEnum1[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty2.array_enum2 | kind:EnumKind | goName: ArrayEnum2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_enum2")
	if this.ArrayEnum2 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayEnum2 {
			encoder.AppendInt32(int32(this.ArrayEnum2[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.SerializeOmitempty2.array_enum3 | kind:EnumKind | goName: ArrayEnum3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_enum3")
	if this.ArrayEnum3 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayEnum3 {
			encoder.AppendInt32(int32(this.ArrayEnum3[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty2.map_string1 | keyKind: string | valueKind: string | goName: MapString1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string1")
	if this.MapString1 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapString1 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty2.map_string2 | keyKind: string | valueKind: string | goName: MapString2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string2")
	if this.MapString2 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapString2 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty2.map_string3 | keyKind: string | valueKind: string | goName: MapString3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string3")
	if this.MapString3 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapString3 {
			encoder.AppendObjectKey(k)
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty2.map_message1 | keyKind: string | valueKind: message | goName: MapMessage1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_message1")
	if this.MapMessage1 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapMessage1 {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty2.map_message2 | keyKind: string | valueKind: message | goName: MapMessage2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_message2")
	if this.MapMessage2 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapMessage2 {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty2.map_message3 | keyKind: string | valueKind: message | goName: MapMessage3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_message3")
	if this.MapMessage3 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapMessage3 {
			encoder.AppendObjectKey(k)
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty2.map_enum1 | keyKind: string | valueKind: enum | goName: MapEnum1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_enum1")
	if this.MapEnum1 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapEnum1 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty2.map_enum2 | keyKind: string | valueKind: enum | goName: MapEnum2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_enum2")
	if this.MapEnum2 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapEnum2 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.SerializeOmitempty2.map_enum3 | keyKind: string | valueKind: enum | goName: MapEnum3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_enum3")
	if this.MapEnum3 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapEnum3 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *SerializeOmitempty2) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*SerializeOmitempty2) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "string1":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty2.string1 | kind: StringKind | GoName: String1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.String1 = x
		case objKey == "string2":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty2.string2 | kind: StringKind | GoName: String2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.String2 = x
		case objKey == "bytes1":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty2.bytes1 | kind: BytesKind | GoName: Bytes1
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes1 = x
		case objKey == "bytes2":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty2.bytes2 | kind: BytesKind | GoName: Bytes2
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes2 = x
		case objKey == "bytes3":
			// decode filed type of basic; | field: gojsontest.SerializeOmitempty2.bytes3 | kind: BytesKind | GoName: Bytes3
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.Bytes3 = x
		case objKey == "array_string1":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty2.array_string1 | kind: StringKind | GoName: ArrayString1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString1 == nil {
					this.ArrayString1 = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString1)
			LOOP_LIST_array_string1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_string1
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString1[i] = x
					} else {
						this.ArrayString1 = append(this.ArrayString1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_string1
					}
				}
				if i < length {
					this.ArrayString1 = this.ArrayString1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_string2":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty2.array_string2 | kind: StringKind | GoName: ArrayString2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString2 == nil {
					this.ArrayString2 = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString2)
			LOOP_LIST_array_string2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_string2
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString2[i] = x
					} else {
						this.ArrayString2 = append(this.ArrayString2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_string2
					}
				}
				if i < length {
					this.ArrayString2 = this.ArrayString2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_string3":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty2.array_string3 | kind: StringKind | GoName: ArrayString3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString3 == nil {
					this.ArrayString3 = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString3)
			LOOP_LIST_array_string3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_string3
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString3[i] = x
					} else {
						this.ArrayString3 = append(this.ArrayString3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_string3
					}
				}
				if i < length {
					this.ArrayString3 = this.ArrayString3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_message1":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty2.array_message1 | kind: MessageKind | GoName: ArrayMessage1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.ArrayMessage1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.ArrayMessage1 == nil {
					this.ArrayMessage1 = make([]*gojsonexternal.ExternalMessage1, 0)
				}
				i := 0
				length := len(this.ArrayMessage1)
			LOOP_LIST_array_message1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_message1
					}
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayMessage1[i]
						}
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayMessage1[i] = x
					} else {
						this.ArrayMessage1 = append(this.ArrayMessage1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_message1
					}
				}
				if i < length {
					this.ArrayMessage1 = this.ArrayMessage1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_message2":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty2.array_message2 | kind: MessageKind | GoName: ArrayMessage2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.ArrayMessage2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.ArrayMessage2 == nil {
					this.ArrayMessage2 = make([]*gojsonexternal.ExternalMessage1, 0)
				}
				i := 0
				length := len(this.ArrayMessage2)
			LOOP_LIST_array_message2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_message2
					}
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayMessage2[i]
						}
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayMessage2[i] = x
					} else {
						this.ArrayMessage2 = append(this.ArrayMessage2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_message2
					}
				}
				if i < length {
					this.ArrayMessage2 = this.ArrayMessage2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_message3":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty2.array_message3 | kind: MessageKind | GoName: ArrayMessage3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.ArrayMessage3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.ArrayMessage3 == nil {
					this.ArrayMessage3 = make([]*gojsonexternal.ExternalMessage1, 0)
				}
				i := 0
				length := len(this.ArrayMessage3)
			LOOP_LIST_array_message3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_message3
					}
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayMessage3[i]
						}
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayMessage3[i] = x
					} else {
						this.ArrayMessage3 = append(this.ArrayMessage3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_message3
					}
				}
				if i < length {
					this.ArrayMessage3 = this.ArrayMessage3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_enum1":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty2.array_enum1 | kind: EnumKind | GoName: ArrayEnum1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.ArrayEnum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.ArrayEnum1 == nil {
					this.ArrayEnum1 = make([]gojsonexternal.ExternalEnum1, 0)
				}
				i := 0
				length := len(this.ArrayEnum1)
			LOOP_LIST_array_enum1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_enum1
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					if i < length {
						this.ArrayEnum1[i] = x
					} else {
						this.ArrayEnum1 = append(this.ArrayEnum1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_enum1
					}
				}
				if i < length {
					this.ArrayEnum1 = this.ArrayEnum1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_enum2":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty2.array_enum2 | kind: EnumKind | GoName: ArrayEnum2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.ArrayEnum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.ArrayEnum2 == nil {
					this.ArrayEnum2 = make([]gojsonexternal.ExternalEnum1, 0)
				}
				i := 0
				length := len(this.ArrayEnum2)
			LOOP_LIST_array_enum2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_enum2
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					if i < length {
						this.ArrayEnum2[i] = x
					} else {
						this.ArrayEnum2 = append(this.ArrayEnum2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_enum2
					}
				}
				if i < length {
					this.ArrayEnum2 = this.ArrayEnum2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_enum3":
			// decode filed type of list; | field: gojsontest.SerializeOmitempty2.array_enum3 | kind: EnumKind | GoName: ArrayEnum3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.ArrayEnum3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.ArrayEnum3 == nil {
					this.ArrayEnum3 = make([]gojsonexternal.ExternalEnum1, 0)
				}
				i := 0
				length := len(this.ArrayEnum3)
			LOOP_LIST_array_enum3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_enum3
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					if i < length {
						this.ArrayEnum3[i] = x
					} else {
						this.ArrayEnum3 = append(this.ArrayEnum3, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_enum3
					}
				}
				if i < length {
					this.ArrayEnum3 = this.ArrayEnum3[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "map_string1":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty2.map_string1 | keyKind: StringKind | valueKind: StringKind | goName: MapString1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				} else {
					this.MapString1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				}
				if this.MapString1 == nil { // create map if not initialized.
					this.MapString1 = make(map[string]string)
				}
			LOOP_MAP_map_string1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]string", string(value), objKey)
						}
					}
					this.MapString1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string2":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty2.map_string2 | keyKind: StringKind | valueKind: StringKind | goName: MapString2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				} else {
					this.MapString2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				}
				if this.MapString2 == nil { // create map if not initialized.
					this.MapString2 = make(map[string]string)
				}
			LOOP_MAP_map_string2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]string", string(value), objKey)
						}
					}
					this.MapString2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string3":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty2.map_string3 | keyKind: StringKind | valueKind: StringKind | goName: MapString3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				} else {
					this.MapString3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), objKey)
				}
				if this.MapString3 == nil { // create map if not initialized.
					this.MapString3 = make(map[string]string)
				}
			LOOP_MAP_map_string3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]string", string(value), objKey)
						}
					}
					this.MapString3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_message1":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty2.map_message1 | keyKind: StringKind | valueKind: MessageKind | goName: MapMessage1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.MapMessage1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.MapMessage1 == nil { // create map if not initialized.
					this.MapMessage1 = make(map[string]*gojsonexternal.ExternalMessage1)
				}
			LOOP_MAP_map_message1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_message1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapMessage1[mapKey]
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapMessage1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_message1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_message2":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty2.map_message2 | keyKind: StringKind | valueKind: MessageKind | goName: MapMessage2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.MapMessage2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.MapMessage2 == nil { // create map if not initialized.
					this.MapMessage2 = make(map[string]*gojsonexternal.ExternalMessage1)
				}
			LOOP_MAP_map_message2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_message2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapMessage2[mapKey]
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapMessage2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_message2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_message3":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty2.map_message3 | keyKind: StringKind | valueKind: MessageKind | goName: MapMessage3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				} else {
					this.MapMessage3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*gojsonexternal.ExternalMessage1", string(value), objKey)
				}
				if this.MapMessage3 == nil { // create map if not initialized.
					this.MapMessage3 = make(map[string]*gojsonexternal.ExternalMessage1)
				}
			LOOP_MAP_map_message3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_message3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *gojsonexternal.ExternalMessage1
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapMessage3[mapKey]
						if x == nil {
							x = new(gojsonexternal.ExternalMessage1)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapMessage3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_message3
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_enum1":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty2.map_enum1 | keyKind: StringKind | valueKind: EnumKind | goName: MapEnum1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.MapEnum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.MapEnum1 == nil { // create map if not initialized.
					this.MapEnum1 = make(map[string]gojsonexternal.ExternalEnum1)
				}
			LOOP_MAP_map_enum1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_enum1
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					this.MapEnum1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_enum1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_enum2":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty2.map_enum2 | keyKind: StringKind | valueKind: EnumKind | goName: MapEnum2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.MapEnum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.MapEnum2 == nil { // create map if not initialized.
					this.MapEnum2 = make(map[string]gojsonexternal.ExternalEnum1)
				}
			LOOP_MAP_map_enum2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_enum2
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					this.MapEnum2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_enum2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_enum3":
			// decode filed type of map; | field: gojsontest.SerializeOmitempty2.map_enum3 | keyKind: StringKind | valueKind: EnumKind | goName: MapEnum3
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				} else {
					this.MapEnum3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
				}
				if this.MapEnum3 == nil { // create map if not initialized.
					this.MapEnum3 = make(map[string]gojsonexternal.ExternalEnum1)
				}
			LOOP_MAP_map_enum3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_enum3
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]gojsonexternal.ExternalEnum1", string(value), objKey)
					}
					_, ok := gojsonexternal.ExternalEnum1_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := gojsonexternal.ExternalEnum1(x1)
					this.MapEnum3[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_enum3
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *UnmarshalData) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(1962)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_string | kind: StringKind | GoName: TString | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string")
	encoder.AppendString(this.TString)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_int32 | kind: Int32Kind | GoName: TInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_int32")
	encoder.AppendInt32(this.TInt32)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_int64 | kind: Int64Kind | GoName: TInt64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_int64")
	encoder.AppendInt64(this.TInt64)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_uint32 | kind: Uint32Kind | GoName: TUint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_uint32")
	encoder.AppendUint32(this.TUint32)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_uint64 | kind: Uint64Kind | GoName: TUint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_uint64")
	encoder.AppendUint64(this.TUint64)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_sint32 | kind: Sint32Kind | GoName: TSint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sint32")
	encoder.AppendInt32(this.TSint32)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_sint64 | kind: Sint64Kind | GoName: TSint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sint64")
	encoder.AppendInt64(this.TSint64)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sfixed32")
	encoder.AppendInt32(this.TSfixed32)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sfixed64")
	encoder.AppendInt64(this.TSfixed64)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_fixed32")
	encoder.AppendUint32(this.TFixed32)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_fixed64")
	encoder.AppendUint64(this.TFixed64)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_float | kind: FloatKind | GoName: TFloat | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_float")
	encoder.AppendFloat32(this.TFloat)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_double | kind: DoubleKind | GoName: TDouble | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_double")
	encoder.AppendFloat64(this.TDouble)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_bool | kind: BoolKind | GoName: TBool | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_bool")
	encoder.AppendBool(this.TBool)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_enum1 | kind: EnumKind | GoName: TEnum1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_enum1")
	encoder.AppendInt32(int32(this.TEnum1.Number()))
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_enum2 | kind: EnumKind | GoName: TEnum2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_enum2")
	encoder.AppendString(this.TEnum2.String())
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_bytes | kind: BytesKind | GoName: TBytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_bytes")
	encoder.AppendBytes(this.TBytes)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_aliases | kind: MessageKind | GoName: TAliases | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_aliases")
	err = encoder.AppendInterface(this.TAliases)
	if err != nil {
		return nil, err
	}
	// encode filed type of basic; | field: gojsontest.UnmarshalData.t_config | kind: MessageKind | GoName: TConfig | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_config")
	err = encoder.AppendInterface(this.TConfig)
	if err != nil {
		return nil, err
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_double | kind:DoubleKind | goName: ArrayDouble | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_double")
	if this.ArrayDouble != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayDouble {
			encoder.AppendFloat64(this.ArrayDouble[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_float | kind:FloatKind | goName: ArrayFloat | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_float")
	if this.ArrayFloat != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayFloat {
			encoder.AppendFloat32(this.ArrayFloat[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_int32 | kind:Int32Kind | goName: ArrayInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_int32")
	if this.ArrayInt32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayInt32 {
			encoder.AppendInt32(this.ArrayInt32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_int64 | kind:Int64Kind | goName: ArrayInt64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_int64")
	if this.ArrayInt64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayInt64 {
			encoder.AppendInt64(this.ArrayInt64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_uint32 | kind:Uint32Kind | goName: ArrayUint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_uint32")
	if this.ArrayUint32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayUint32 {
			encoder.AppendUint32(this.ArrayUint32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_uint64 | kind:Uint64Kind | goName: ArrayUint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_uint64")
	if this.ArrayUint64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayUint64 {
			encoder.AppendUint64(this.ArrayUint64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_sint32 | kind:Sint32Kind | goName: ArraySint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sint32")
	if this.ArraySint32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySint32 {
			encoder.AppendInt32(this.ArraySint32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_sint64 | kind:Sint64Kind | goName: ArraySint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sint64")
	if this.ArraySint64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySint64 {
			encoder.AppendInt64(this.ArraySint64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_sfixed32 | kind:Sfixed32Kind | goName: ArraySfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sfixed32")
	if this.ArraySfixed32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySfixed32 {
			encoder.AppendInt32(this.ArraySfixed32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_sfixed64 | kind:Sfixed64Kind | goName: ArraySfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_sfixed64")
	if this.ArraySfixed64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArraySfixed64 {
			encoder.AppendInt64(this.ArraySfixed64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_fixed32 | kind:Fixed32Kind | goName: ArrayFixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_fixed32")
	if this.ArrayFixed32 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayFixed32 {
			encoder.AppendUint32(this.ArrayFixed32[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_fixed64 | kind:Fixed64Kind | goName: ArrayFixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_fixed64")
	if this.ArrayFixed64 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayFixed64 {
			encoder.AppendUint64(this.ArrayFixed64[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_bool | kind:BoolKind | goName: ArrayBool | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_bool")
	if this.ArrayBool != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayBool {
			encoder.AppendBool(this.ArrayBool[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_string | kind:StringKind | goName: ArrayString | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_string")
	if this.ArrayString != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayString {
			encoder.AppendString(this.ArrayString[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_bytes | kind:BytesKind | goName: ArrayBytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_bytes")
	if this.ArrayBytes != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayBytes {
			encoder.AppendBytes(this.ArrayBytes[i])
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_enum1 | kind:EnumKind | goName: ArrayEnum1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_enum1")
	if this.ArrayEnum1 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayEnum1 {
			encoder.AppendInt32(int32(this.ArrayEnum1[i].Number()))
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_enum2 | kind:EnumKind | goName: ArrayEnum2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_enum2")
	if this.ArrayEnum2 != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayEnum2 {
			encoder.AppendString(this.ArrayEnum2[i].String())
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_aliases | kind:MessageKind | goName: ArrayAliases | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_aliases")
	if this.ArrayAliases != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayAliases {
			err = encoder.AppendInterface(this.ArrayAliases[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of list; | field: gojsontest.UnmarshalData.array_config | kind:MessageKind | goName: ArrayConfig | omitempty: false | ignore: false
	encoder.AppendObjectKey("array_config")
	if this.ArrayConfig != nil {
		encoder.AppendListBegin()
		for i := range this.ArrayConfig {
			err = encoder.AppendInterface(this.ArrayConfig[i])
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendListEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_double | keyKind: int32 | valueKind: double | goName: MapInt32Double | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_double")
	if this.MapInt32Double != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Double {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendFloat64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_float | keyKind: int32 | valueKind: float | goName: MapInt32Float | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_float")
	if this.MapInt32Float != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Float {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendFloat32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_int32 | keyKind: int32 | valueKind: int32 | goName: MapInt32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_int32")
	if this.MapInt32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_int64 | keyKind: int32 | valueKind: int64 | goName: MapInt32Int64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_int64")
	if this.MapInt32Int64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Int64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_uint32 | keyKind: int32 | valueKind: uint32 | goName: MapInt32Uint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_uint32")
	if this.MapInt32Uint32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Uint32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_uint64 | keyKind: int32 | valueKind: uint64 | goName: MapInt32Uint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_uint64")
	if this.MapInt32Uint64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Uint64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_sint32 | keyKind: int32 | valueKind: sint32 | goName: MapInt32Sint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sint32")
	if this.MapInt32Sint32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sint32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_sint64 | keyKind: int32 | valueKind: sint64 | goName: MapInt32Sint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sint64")
	if this.MapInt32Sint64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sint64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_sfixed32 | keyKind: int32 | valueKind: sfixed32 | goName: MapInt32Sfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sfixed32")
	if this.MapInt32Sfixed32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sfixed32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_sfixed64 | keyKind: int32 | valueKind: sfixed64 | goName: MapInt32Sfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_sfixed64")
	if this.MapInt32Sfixed64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Sfixed64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_fixed32 | keyKind: int32 | valueKind: fixed32 | goName: MapInt32Fixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_fixed32")
	if this.MapInt32Fixed32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Fixed32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_fixed64 | keyKind: int32 | valueKind: fixed64 | goName: MapInt32Fixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_fixed64")
	if this.MapInt32Fixed64 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Fixed64 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendUint64(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_bool | keyKind: int32 | valueKind: bool | goName: MapInt32Bool | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_bool")
	if this.MapInt32Bool != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Bool {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendBool(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_string | keyKind: int32 | valueKind: string | goName: MapInt32String | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_string")
	if this.MapInt32String != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32String {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendString(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_bytes | keyKind: int32 | valueKind: bytes | goName: MapInt32Bytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_bytes")
	if this.MapInt32Bytes != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Bytes {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendBytes(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_enum1 | keyKind: int32 | valueKind: enum | goName: MapInt32Enum1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_enum1")
	if this.MapInt32Enum1 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Enum1 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(int32(v.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_enum2 | keyKind: int32 | valueKind: enum | goName: MapInt32Enum2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_enum2")
	if this.MapInt32Enum2 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Enum2 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendString(v.String())
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_aliases | keyKind: int32 | valueKind: message | goName: MapInt32Aliases | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_aliases")
	if this.MapInt32Aliases != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Aliases {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int32_config | keyKind: int32 | valueKind: message | goName: MapInt32Config | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int32_config")
	if this.MapInt32Config != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt32Config {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			err = encoder.AppendInterface(v)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_int64_int32 | keyKind: int64 | valueKind: int32 | goName: MapInt64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_int64_int32")
	if this.MapInt64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapInt64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_uint32_int32 | keyKind: uint32 | valueKind: int32 | goName: MapUint32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_uint32_int32")
	if this.MapUint32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapUint32Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(uint64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_uint64_int32 | keyKind: uint64 | valueKind: int32 | goName: MapUint64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_uint64_int32")
	if this.MapUint64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapUint64Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_sint32_int32 | keyKind: sint32 | valueKind: int32 | goName: MapSint32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sint32_int32")
	if this.MapSint32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSint32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_sint64_int32 | keyKind: sint64 | valueKind: int32 | goName: MapSint64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sint64_int32")
	if this.MapSint64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSint64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_fixed32_int32 | keyKind: fixed32 | valueKind: int32 | goName: MapFixed32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_fixed32_int32")
	if this.MapFixed32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapFixed32Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(uint64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_fixed64_int32 | keyKind: fixed64 | valueKind: int32 | goName: MapFixed64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_fixed64_int32")
	if this.MapFixed64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapFixed64Int32 {
			encoder.AppendObjectKey(strconv.FormatUint(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_sfixed32_int32 | keyKind: sfixed32 | valueKind: int32 | goName: MapSfixed32Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sfixed32_int32")
	if this.MapSfixed32Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSfixed32Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(int64(k), 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_sfixed64_int32 | keyKind: sfixed64 | valueKind: int32 | goName: MapSfixed64Int32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_sfixed64_int32")
	if this.MapSfixed64Int32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapSfixed64Int32 {
			encoder.AppendObjectKey(strconv.FormatInt(k, 10))
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}
	// encode field type of map; | field: gojsontest.UnmarshalData.map_string_int32 | keyKind: string | valueKind: int32 | goName: MapStringInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("map_string_int32")
	if this.MapStringInt32 != nil {
		encoder.AppendObjectBegin()
		for k, v := range this.MapStringInt32 {
			encoder.AppendObjectKey(k)
			encoder.AppendInt32(v)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendNil()
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *UnmarshalData) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*UnmarshalData) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_string":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_string | kind: StringKind | GoName: TString
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString = x
		case objKey == "t_int32":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_int32 | kind: Int32Kind | GoName: TInt32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TInt32 = x
		case objKey == "t_int64":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_int64 | kind: Int64Kind | GoName: TInt64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TInt64 = x
		case objKey == "t_uint32":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_uint32 | kind: Uint32Kind | GoName: TUint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TUint32 = x
		case objKey == "t_uint64":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_uint64 | kind: Uint64Kind | GoName: TUint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TUint64 = x
		case objKey == "t_sint32":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_sint32 | kind: Sint32Kind | GoName: TSint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSint32 = x
		case objKey == "t_sint64":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_sint64 | kind: Sint64Kind | GoName: TSint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSint64 = x
		case objKey == "t_sfixed32":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSfixed32 = x
		case objKey == "t_sfixed64":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSfixed64 = x
		case objKey == "t_fixed32":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TFixed32 = x
		case objKey == "t_fixed64":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TFixed64 = x
		case objKey == "t_float":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_float | kind: FloatKind | GoName: TFloat
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
			}
			this.TFloat = x
		case objKey == "t_double":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_double | kind: DoubleKind | GoName: TDouble
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TDouble = x
		case objKey == "t_bool":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_bool | kind: BoolKind | GoName: TBool
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			this.TBool = x
		case objKey == "t_enum1":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_enum1 | kind: EnumKind | GoName: TEnum1
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type UnmarshalData_Enum", string(value), objKey)
			}
			_, ok := UnmarshalData_Enum_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := UnmarshalData_Enum(x1)
			this.TEnum1 = x
		case objKey == "t_enum2":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_enum2 | kind: EnumKind | GoName: TEnum2
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type UnmarshalData_Enum", string(value), objKey)
			}
			x1, ok := UnmarshalData_Enum_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := UnmarshalData_Enum(x1)
			this.TEnum2 = x
		case objKey == "t_bytes":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_bytes | kind: BytesKind | GoName: TBytes
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.TBytes = x
		case objKey == "t_aliases":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_aliases | kind: MessageKind | GoName: TAliases
			value := decoder.ReadItem()
			var x *UnmarshalData_Aliases
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TAliases == nil {
					x = new(UnmarshalData_Aliases)
				} else {
					x = this.TAliases
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TAliases = x
		case objKey == "t_config":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.t_config | kind: MessageKind | GoName: TConfig
			value := decoder.ReadItem()
			var x *UnmarshalData_Config
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TConfig == nil {
					x = new(UnmarshalData_Config)
				} else {
					x = this.TConfig
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TConfig = x
		case objKey == "array_double":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_double | kind: DoubleKind | GoName: ArrayDouble
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), objKey)
				} else {
					this.ArrayDouble = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), objKey)
				}
				if this.ArrayDouble == nil {
					this.ArrayDouble = make([]float64, 0)
				}
				i := 0
				length := len(this.ArrayDouble)
			LOOP_LIST_array_double:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_double
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []float64", string(value), objKey)
					}
					if i < length {
						this.ArrayDouble[i] = x
					} else {
						this.ArrayDouble = append(this.ArrayDouble, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_double
					}
				}
				if i < length {
					this.ArrayDouble = this.ArrayDouble[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_float":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_float | kind: FloatKind | GoName: ArrayFloat
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), objKey)
				} else {
					this.ArrayFloat = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), objKey)
				}
				if this.ArrayFloat == nil {
					this.ArrayFloat = make([]float32, 0)
				}
				i := 0
				length := len(this.ArrayFloat)
			LOOP_LIST_array_float:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_float
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []float32", string(value), objKey)
					}
					if i < length {
						this.ArrayFloat[i] = x
					} else {
						this.ArrayFloat = append(this.ArrayFloat, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_float
					}
				}
				if i < length {
					this.ArrayFloat = this.ArrayFloat[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_int32":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_int32 | kind: Int32Kind | GoName: ArrayInt32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArrayInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArrayInt32 == nil {
					this.ArrayInt32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArrayInt32)
			LOOP_LIST_array_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_int32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArrayInt32[i] = x
					} else {
						this.ArrayInt32 = append(this.ArrayInt32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_int32
					}
				}
				if i < length {
					this.ArrayInt32 = this.ArrayInt32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_int64":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_int64 | kind: Int64Kind | GoName: ArrayInt64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArrayInt64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArrayInt64 == nil {
					this.ArrayInt64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArrayInt64)
			LOOP_LIST_array_int64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_int64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArrayInt64[i] = x
					} else {
						this.ArrayInt64 = append(this.ArrayInt64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_int64
					}
				}
				if i < length {
					this.ArrayInt64 = this.ArrayInt64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_uint32":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_uint32 | kind: Uint32Kind | GoName: ArrayUint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				} else {
					this.ArrayUint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				}
				if this.ArrayUint32 == nil {
					this.ArrayUint32 = make([]uint32, 0)
				}
				i := 0
				length := len(this.ArrayUint32)
			LOOP_LIST_array_uint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_uint32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint32", string(value), objKey)
					}
					if i < length {
						this.ArrayUint32[i] = x
					} else {
						this.ArrayUint32 = append(this.ArrayUint32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_uint32
					}
				}
				if i < length {
					this.ArrayUint32 = this.ArrayUint32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_uint64":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_uint64 | kind: Uint64Kind | GoName: ArrayUint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				} else {
					this.ArrayUint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				}
				if this.ArrayUint64 == nil {
					this.ArrayUint64 = make([]uint64, 0)
				}
				i := 0
				length := len(this.ArrayUint64)
			LOOP_LIST_array_uint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_uint64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint64", string(value), objKey)
					}
					if i < length {
						this.ArrayUint64[i] = x
					} else {
						this.ArrayUint64 = append(this.ArrayUint64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_uint64
					}
				}
				if i < length {
					this.ArrayUint64 = this.ArrayUint64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sint32":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_sint32 | kind: Sint32Kind | GoName: ArraySint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArraySint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArraySint32 == nil {
					this.ArraySint32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArraySint32)
			LOOP_LIST_array_sint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sint32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArraySint32[i] = x
					} else {
						this.ArraySint32 = append(this.ArraySint32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sint32
					}
				}
				if i < length {
					this.ArraySint32 = this.ArraySint32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sint64":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_sint64 | kind: Sint64Kind | GoName: ArraySint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArraySint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArraySint64 == nil {
					this.ArraySint64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArraySint64)
			LOOP_LIST_array_sint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sint64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArraySint64[i] = x
					} else {
						this.ArraySint64 = append(this.ArraySint64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sint64
					}
				}
				if i < length {
					this.ArraySint64 = this.ArraySint64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sfixed32":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_sfixed32 | kind: Sfixed32Kind | GoName: ArraySfixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				} else {
					this.ArraySfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), objKey)
				}
				if this.ArraySfixed32 == nil {
					this.ArraySfixed32 = make([]int32, 0)
				}
				i := 0
				length := len(this.ArraySfixed32)
			LOOP_LIST_array_sfixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sfixed32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int32", string(value), objKey)
					}
					if i < length {
						this.ArraySfixed32[i] = x
					} else {
						this.ArraySfixed32 = append(this.ArraySfixed32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sfixed32
					}
				}
				if i < length {
					this.ArraySfixed32 = this.ArraySfixed32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_sfixed64":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_sfixed64 | kind: Sfixed64Kind | GoName: ArraySfixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				} else {
					this.ArraySfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), objKey)
				}
				if this.ArraySfixed64 == nil {
					this.ArraySfixed64 = make([]int64, 0)
				}
				i := 0
				length := len(this.ArraySfixed64)
			LOOP_LIST_array_sfixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_sfixed64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []int64", string(value), objKey)
					}
					if i < length {
						this.ArraySfixed64[i] = x
					} else {
						this.ArraySfixed64 = append(this.ArraySfixed64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_sfixed64
					}
				}
				if i < length {
					this.ArraySfixed64 = this.ArraySfixed64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_fixed32":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_fixed32 | kind: Fixed32Kind | GoName: ArrayFixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				} else {
					this.ArrayFixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), objKey)
				}
				if this.ArrayFixed32 == nil {
					this.ArrayFixed32 = make([]uint32, 0)
				}
				i := 0
				length := len(this.ArrayFixed32)
			LOOP_LIST_array_fixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_fixed32
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint32", string(value), objKey)
					}
					if i < length {
						this.ArrayFixed32[i] = x
					} else {
						this.ArrayFixed32 = append(this.ArrayFixed32, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_fixed32
					}
				}
				if i < length {
					this.ArrayFixed32 = this.ArrayFixed32[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_fixed64":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_fixed64 | kind: Fixed64Kind | GoName: ArrayFixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				} else {
					this.ArrayFixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), objKey)
				}
				if this.ArrayFixed64 == nil {
					this.ArrayFixed64 = make([]uint64, 0)
				}
				i := 0
				length := len(this.ArrayFixed64)
			LOOP_LIST_array_fixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_fixed64
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []uint64", string(value), objKey)
					}
					if i < length {
						this.ArrayFixed64[i] = x
					} else {
						this.ArrayFixed64 = append(this.ArrayFixed64, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_fixed64
					}
				}
				if i < length {
					this.ArrayFixed64 = this.ArrayFixed64[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bool":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_bool | kind: BoolKind | GoName: ArrayBool
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), objKey)
				} else {
					this.ArrayBool = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), objKey)
				}
				if this.ArrayBool == nil {
					this.ArrayBool = make([]bool, 0)
				}
				i := 0
				length := len(this.ArrayBool)
			LOOP_LIST_array_bool:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bool
					}
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseBool(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []bool", string(value), objKey)
					}
					if i < length {
						this.ArrayBool[i] = x
					} else {
						this.ArrayBool = append(this.ArrayBool, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bool
					}
				}
				if i < length {
					this.ArrayBool = this.ArrayBool[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_string":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_string | kind: StringKind | GoName: ArrayString
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				} else {
					this.ArrayString = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), objKey)
				}
				if this.ArrayString == nil {
					this.ArrayString = make([]string, 0)
				}
				i := 0
				length := len(this.ArrayString)
			LOOP_LIST_array_string:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_string
					}
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []string", string(value), objKey)
						}
					}
					if i < length {
						this.ArrayString[i] = x
					} else {
						this.ArrayString = append(this.ArrayString, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_string
					}
				}
				if i < length {
					this.ArrayString = this.ArrayString[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_bytes":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_bytes | kind: BytesKind | GoName: ArrayBytes
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				} else {
					this.ArrayBytes = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), objKey)
				}
				if this.ArrayBytes == nil {
					this.ArrayBytes = make([][]byte, 0)
				}
				i := 0
				length := len(this.ArrayBytes)
			LOOP_LIST_array_bytes:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_bytes
					}
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type [][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					if i < length {
						this.ArrayBytes[i] = x
					} else {
						this.ArrayBytes = append(this.ArrayBytes, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_bytes
					}
				}
				if i < length {
					this.ArrayBytes = this.ArrayBytes[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_enum1":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_enum1 | kind: EnumKind | GoName: ArrayEnum1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []UnmarshalData_Enum", string(value), objKey)
				} else {
					this.ArrayEnum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []UnmarshalData_Enum", string(value), objKey)
				}
				if this.ArrayEnum1 == nil {
					this.ArrayEnum1 = make([]UnmarshalData_Enum, 0)
				}
				i := 0
				length := len(this.ArrayEnum1)
			LOOP_LIST_array_enum1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_enum1
					}
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []UnmarshalData_Enum", string(value), objKey)
					}
					_, ok := UnmarshalData_Enum_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := UnmarshalData_Enum(x1)
					if i < length {
						this.ArrayEnum1[i] = x
					} else {
						this.ArrayEnum1 = append(this.ArrayEnum1, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_enum1
					}
				}
				if i < length {
					this.ArrayEnum1 = this.ArrayEnum1[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_enum2":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_enum2 | kind: EnumKind | GoName: ArrayEnum2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []UnmarshalData_Enum", string(value), objKey)
				} else {
					this.ArrayEnum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []UnmarshalData_Enum", string(value), objKey)
				}
				if this.ArrayEnum2 == nil {
					this.ArrayEnum2 = make([]UnmarshalData_Enum, 0)
				}
				i := 0
				length := len(this.ArrayEnum2)
			LOOP_LIST_array_enum2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_enum2
					}
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as array element into field %s of type []UnmarshalData_Enum", string(value), objKey)
					}
					x1, ok := UnmarshalData_Enum_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := UnmarshalData_Enum(x1)
					if i < length {
						this.ArrayEnum2[i] = x
					} else {
						this.ArrayEnum2 = append(this.ArrayEnum2, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_enum2
					}
				}
				if i < length {
					this.ArrayEnum2 = this.ArrayEnum2[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_aliases":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_aliases | kind: MessageKind | GoName: ArrayAliases
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*UnmarshalData_Aliases", string(value), objKey)
				} else {
					this.ArrayAliases = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*UnmarshalData_Aliases", string(value), objKey)
				}
				if this.ArrayAliases == nil {
					this.ArrayAliases = make([]*UnmarshalData_Aliases, 0)
				}
				i := 0
				length := len(this.ArrayAliases)
			LOOP_LIST_array_aliases:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_aliases
					}
					value := decoder.ReadItem()
					var x *UnmarshalData_Aliases
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayAliases[i]
						}
						if x == nil {
							x = new(UnmarshalData_Aliases)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayAliases[i] = x
					} else {
						this.ArrayAliases = append(this.ArrayAliases, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_aliases
					}
				}
				if i < length {
					this.ArrayAliases = this.ArrayAliases[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "array_config":
			// decode filed type of list; | field: gojsontest.UnmarshalData.array_config | kind: MessageKind | GoName: ArrayConfig
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*UnmarshalData_Config", string(value), objKey)
				} else {
					this.ArrayConfig = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginArray {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*UnmarshalData_Config", string(value), objKey)
				}
				if this.ArrayConfig == nil {
					this.ArrayConfig = make([]*UnmarshalData_Config, 0)
				}
				i := 0
				length := len(this.ArrayConfig)
			LOOP_LIST_array_config:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ArrayBeforeReadValue() { // Before read array value.
						break LOOP_LIST_array_config
					}
					value := decoder.ReadItem()
					var x *UnmarshalData_Config
					if value[0] != 'n' { // value[0] == 'n' means null
						if i < length {
							x = this.ArrayConfig[i]
						}
						if x == nil {
							x = new(UnmarshalData_Config)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					if i < length {
						this.ArrayConfig[i] = x
					} else {
						this.ArrayConfig = append(this.ArrayConfig, x)
					}
					i++
					if decoder.ArrayAfterReadValue() { // After read array value.
						break LOOP_LIST_array_config
					}
				}
				if i < length {
					this.ArrayConfig = this.ArrayConfig[:i]
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_double":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_double | keyKind: Int32Kind | valueKind: DoubleKind | goName: MapInt32Double
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float64", string(value), objKey)
				} else {
					this.MapInt32Double = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float64", string(value), objKey)
				}
				if this.MapInt32Double == nil { // create map if not initialized.
					this.MapInt32Double = make(map[int32]float64)
				}
			LOOP_MAP_map_int32_double:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_double
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]float64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]float64", string(value), objKey)
					}
					this.MapInt32Double[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_double
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_float":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_float | keyKind: Int32Kind | valueKind: FloatKind | goName: MapInt32Float
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float32", string(value), objKey)
				} else {
					this.MapInt32Float = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]float32", string(value), objKey)
				}
				if this.MapInt32Float == nil { // create map if not initialized.
					this.MapInt32Float = make(map[int32]float32)
				}
			LOOP_MAP_map_int32_float:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_float
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]float32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseFloat32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]float32", string(value), objKey)
					}
					this.MapInt32Float[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_float
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_int32 | keyKind: Int32Kind | valueKind: Int32Kind | goName: MapInt32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Int32 == nil { // create map if not initialized.
					this.MapInt32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_map_int32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_int64":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_int64 | keyKind: Int32Kind | valueKind: Int64Kind | goName: MapInt32Int64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Int64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Int64 == nil { // create map if not initialized.
					this.MapInt32Int64 = make(map[int32]int64)
				}
			LOOP_MAP_map_int32_int64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_int64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Int64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_int64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_uint32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_uint32 | keyKind: Int32Kind | valueKind: Uint32Kind | goName: MapInt32Uint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				} else {
					this.MapInt32Uint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				}
				if this.MapInt32Uint32 == nil { // create map if not initialized.
					this.MapInt32Uint32 = make(map[int32]uint32)
				}
			LOOP_MAP_map_int32_uint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_uint32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint32", string(value), objKey)
					}
					this.MapInt32Uint32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_uint32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_uint64":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_uint64 | keyKind: Int32Kind | valueKind: Uint64Kind | goName: MapInt32Uint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				} else {
					this.MapInt32Uint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				}
				if this.MapInt32Uint64 == nil { // create map if not initialized.
					this.MapInt32Uint64 = make(map[int32]uint64)
				}
			LOOP_MAP_map_int32_uint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_uint64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint64", string(value), objKey)
					}
					this.MapInt32Uint64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_uint64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sint32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_sint32 | keyKind: Int32Kind | valueKind: Sint32Kind | goName: MapInt32Sint32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Sint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Sint32 == nil { // create map if not initialized.
					this.MapInt32Sint32 = make(map[int32]int32)
				}
			LOOP_MAP_map_int32_sint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sint32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Sint32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sint32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sint64":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_sint64 | keyKind: Int32Kind | valueKind: Sint64Kind | goName: MapInt32Sint64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Sint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Sint64 == nil { // create map if not initialized.
					this.MapInt32Sint64 = make(map[int32]int64)
				}
			LOOP_MAP_map_int32_sint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sint64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Sint64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sint64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sfixed32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_sfixed32 | keyKind: Int32Kind | valueKind: Sfixed32Kind | goName: MapInt32Sfixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapInt32Sfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapInt32Sfixed32 == nil { // create map if not initialized.
					this.MapInt32Sfixed32 = make(map[int32]int32)
				}
			LOOP_MAP_map_int32_sfixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sfixed32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapInt32Sfixed32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sfixed32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_sfixed64":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_sfixed64 | keyKind: Int32Kind | valueKind: Sfixed64Kind | goName: MapInt32Sfixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				} else {
					this.MapInt32Sfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int64", string(value), objKey)
				}
				if this.MapInt32Sfixed64 == nil { // create map if not initialized.
					this.MapInt32Sfixed64 = make(map[int32]int64)
				}
			LOOP_MAP_map_int32_sfixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_sfixed64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int64", string(value), objKey)
					}
					this.MapInt32Sfixed64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_sfixed64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_fixed32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_fixed32 | keyKind: Int32Kind | valueKind: Fixed32Kind | goName: MapInt32Fixed32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				} else {
					this.MapInt32Fixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint32", string(value), objKey)
				}
				if this.MapInt32Fixed32 == nil { // create map if not initialized.
					this.MapInt32Fixed32 = make(map[int32]uint32)
				}
			LOOP_MAP_map_int32_fixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_fixed32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint32", string(value), objKey)
					}
					this.MapInt32Fixed32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_fixed32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_fixed64":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_fixed64 | keyKind: Int32Kind | valueKind: Fixed64Kind | goName: MapInt32Fixed64
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				} else {
					this.MapInt32Fixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]uint64", string(value), objKey)
				}
				if this.MapInt32Fixed64 == nil { // create map if not initialized.
					this.MapInt32Fixed64 = make(map[int32]uint64)
				}
			LOOP_MAP_map_int32_fixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_fixed64
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]uint64", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseUint64(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]uint64", string(value), objKey)
					}
					this.MapInt32Fixed64[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_fixed64
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_bool":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_bool | keyKind: Int32Kind | valueKind: BoolKind | goName: MapInt32Bool
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]bool", string(value), objKey)
				} else {
					this.MapInt32Bool = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]bool", string(value), objKey)
				}
				if this.MapInt32Bool == nil { // create map if not initialized.
					this.MapInt32Bool = make(map[int32]bool)
				}
			LOOP_MAP_map_int32_bool:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_bool
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]bool", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseBool(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]bool", string(value), objKey)
					}
					this.MapInt32Bool[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_bool
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_string":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_string | keyKind: Int32Kind | valueKind: StringKind | goName: MapInt32String
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]string", string(value), objKey)
				} else {
					this.MapInt32String = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]string", string(value), objKey)
				}
				if this.MapInt32String == nil { // create map if not initialized.
					this.MapInt32String = make(map[int32]string)
				}
			LOOP_MAP_map_int32_string:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_string
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]string", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x string
					if value[0] != 'n' { // 'n' means null
						var ok bool
						x, ok = jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]string", string(value), objKey)
						}
					}
					this.MapInt32String[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_string
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_bytes":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_bytes | keyKind: Int32Kind | valueKind: BytesKind | goName: MapInt32Bytes
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32][]byte", string(value), objKey)
				} else {
					this.MapInt32Bytes = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32][]byte", string(value), objKey)
				}
				if this.MapInt32Bytes == nil { // create map if not initialized.
					this.MapInt32Bytes = make(map[int32][]byte)
				}
			LOOP_MAP_map_int32_bytes:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_bytes
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32][]byte", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x []byte
					if value[0] != 'n' { // value[0] == 'n' means null
						s, ok := jsondecoder.UnquoteBytes(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32][]byte", string(value), objKey)
						}
						dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
						n, err := base64.StdEncoding.Decode(dst, s)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32][]byte", string(value), objKey)
						}
						x = dst[:n]
					}
					this.MapInt32Bytes[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_bytes
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_enum1":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_enum1 | keyKind: Int32Kind | valueKind: EnumKind | goName: MapInt32Enum1
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]UnmarshalData_Enum", string(value), objKey)
				} else {
					this.MapInt32Enum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]UnmarshalData_Enum", string(value), objKey)
				}
				if this.MapInt32Enum1 == nil { // create map if not initialized.
					this.MapInt32Enum1 = make(map[int32]UnmarshalData_Enum)
				}
			LOOP_MAP_map_int32_enum1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_enum1
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]UnmarshalData_Enum", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x1, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]UnmarshalData_Enum", string(value), objKey)
					}
					_, ok := UnmarshalData_Enum_name[x1]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := UnmarshalData_Enum(x1)
					this.MapInt32Enum1[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_enum1
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_enum2":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_enum2 | keyKind: Int32Kind | valueKind: EnumKind | goName: MapInt32Enum2
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]UnmarshalData_Enum", string(value), objKey)
				} else {
					this.MapInt32Enum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]UnmarshalData_Enum", string(value), objKey)
				}
				if this.MapInt32Enum2 == nil { // create map if not initialized.
					this.MapInt32Enum2 = make(map[int32]UnmarshalData_Enum)
				}
			LOOP_MAP_map_int32_enum2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_enum2
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]UnmarshalData_Enum", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					s, ok := jsondecoder.UnquoteString(value)
					if !ok {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]UnmarshalData_Enum", string(value), objKey)
					}
					x1, ok := UnmarshalData_Enum_value[s]
					if !ok {
						return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
					}
					x := UnmarshalData_Enum(x1)
					this.MapInt32Enum2[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_enum2
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_aliases":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_aliases | keyKind: Int32Kind | valueKind: MessageKind | goName: MapInt32Aliases
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*UnmarshalData_Aliases", string(value), objKey)
				} else {
					this.MapInt32Aliases = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*UnmarshalData_Aliases", string(value), objKey)
				}
				if this.MapInt32Aliases == nil { // create map if not initialized.
					this.MapInt32Aliases = make(map[int32]*UnmarshalData_Aliases)
				}
			LOOP_MAP_map_int32_aliases:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_aliases
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]*UnmarshalData_Aliases", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *UnmarshalData_Aliases
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapInt32Aliases[mapKey]
						if x == nil {
							x = new(UnmarshalData_Aliases)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapInt32Aliases[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_aliases
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int32_config":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int32_config | keyKind: Int32Kind | valueKind: MessageKind | goName: MapInt32Config
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*UnmarshalData_Config", string(value), objKey)
				} else {
					this.MapInt32Config = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]*UnmarshalData_Config", string(value), objKey)
				}
				if this.MapInt32Config == nil { // create map if not initialized.
					this.MapInt32Config = make(map[int32]*UnmarshalData_Config)
				}
			LOOP_MAP_map_int32_config:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int32_config
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]*UnmarshalData_Config", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					var x *UnmarshalData_Config
					if value[0] != 'n' { // value[0] == 'n' means null
						x = this.MapInt32Config[mapKey]
						if x == nil {
							x = new(UnmarshalData_Config)
						}
						if um, ok := interface{}(x).(json.Unmarshaler); ok {
							err = um.UnmarshalJSON(value)
						} else {
							err = json.Unmarshal(value, x)
						}
						if err != nil {
							return err
						}
					}
					this.MapInt32Config[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int32_config
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_int64_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_int64_int32 | keyKind: Int64Kind | valueKind: Int32Kind | goName: MapInt64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapInt64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapInt64Int32 == nil { // create map if not initialized.
					this.MapInt64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_map_int64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_int64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapInt64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_int64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_uint32_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_uint32_int32 | keyKind: Uint32Kind | valueKind: Int32Kind | goName: MapUint32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				} else {
					this.MapUint32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				}
				if this.MapUint32Int32 == nil { // create map if not initialized.
					this.MapUint32Int32 = make(map[uint32]int32)
				}
			LOOP_MAP_map_uint32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_uint32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseUint(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint32]int32", key, objKey)
					}
					mapKey := uint32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint32]int32", string(value), objKey)
					}
					this.MapUint32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_uint32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_uint64_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_uint64_int32 | keyKind: Uint64Kind | valueKind: Int32Kind | goName: MapUint64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				} else {
					this.MapUint64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				}
				if this.MapUint64Int32 == nil { // create map if not initialized.
					this.MapUint64Int32 = make(map[uint64]int32)
				}
			LOOP_MAP_map_uint64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_uint64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseUint(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint64]int32", string(value), objKey)
					}
					this.MapUint64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_uint64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sint32_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_sint32_int32 | keyKind: Sint32Kind | valueKind: Int32Kind | goName: MapSint32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapSint32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapSint32Int32 == nil { // create map if not initialized.
					this.MapSint32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_map_sint32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sint32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapSint32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sint32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sint64_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_sint64_int32 | keyKind: Sint64Kind | valueKind: Int32Kind | goName: MapSint64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapSint64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapSint64Int32 == nil { // create map if not initialized.
					this.MapSint64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_map_sint64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sint64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapSint64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sint64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_fixed32_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_fixed32_int32 | keyKind: Fixed32Kind | valueKind: Int32Kind | goName: MapFixed32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				} else {
					this.MapFixed32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint32]int32", string(value), objKey)
				}
				if this.MapFixed32Int32 == nil { // create map if not initialized.
					this.MapFixed32Int32 = make(map[uint32]int32)
				}
			LOOP_MAP_map_fixed32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_fixed32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseUint(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint32]int32", key, objKey)
					}
					mapKey := uint32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint32]int32", string(value), objKey)
					}
					this.MapFixed32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_fixed32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_fixed64_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_fixed64_int32 | keyKind: Fixed64Kind | valueKind: Int32Kind | goName: MapFixed64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				} else {
					this.MapFixed64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[uint64]int32", string(value), objKey)
				}
				if this.MapFixed64Int32 == nil { // create map if not initialized.
					this.MapFixed64Int32 = make(map[uint64]int32)
				}
			LOOP_MAP_map_fixed64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_fixed64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseUint(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[uint64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[uint64]int32", string(value), objKey)
					}
					this.MapFixed64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_fixed64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sfixed32_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_sfixed32_int32 | keyKind: Sfixed32Kind | valueKind: Int32Kind | goName: MapSfixed32Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				} else {
					this.MapSfixed32Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int32]int32", string(value), objKey)
				}
				if this.MapSfixed32Int32 == nil { // create map if not initialized.
					this.MapSfixed32Int32 = make(map[int32]int32)
				}
			LOOP_MAP_map_sfixed32_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sfixed32_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					v, err := strconv.ParseInt(key, 10, 32)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int32]int32", key, objKey)
					}
					mapKey := int32(v)
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int32]int32", string(value), objKey)
					}
					this.MapSfixed32Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sfixed32_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_sfixed64_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_sfixed64_int32 | keyKind: Sfixed64Kind | valueKind: Int32Kind | goName: MapSfixed64Int32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				} else {
					this.MapSfixed64Int32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[int64]int32", string(value), objKey)
				}
				if this.MapSfixed64Int32 == nil { // create map if not initialized.
					this.MapSfixed64Int32 = make(map[int64]int32)
				}
			LOOP_MAP_map_sfixed64_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_sfixed64_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey, err := strconv.ParseInt(key, 10, 64)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map key into field %s of type map[int64]int32", key, objKey)
					}
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[int64]int32", string(value), objKey)
					}
					this.MapSfixed64Int32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_sfixed64_int32
					}
				}
				decoder.ScanNext()
			}
		case objKey == "map_string_int32":
			// decode filed type of map; | field: gojsontest.UnmarshalData.map_string_int32 | keyKind: StringKind | valueKind: Int32Kind | goName: MapStringInt32
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				} else {
					this.MapStringInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), objKey)
				}
				if this.MapStringInt32 == nil { // create map if not initialized.
					this.MapStringInt32 = make(map[string]int32)
				}
			LOOP_MAP_map_string_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_MAP_map_string_int32
					}

					key := decoder.ReadObjectKey() // Read map key
					mapKey := key
					decoder.ObjectBeforeReadValue() // Before read object value
					value := decoder.ReadItem()
					x, err := jsondecoder.ParseInt32(value)
					if err != nil {
						return fmt.Errorf("json: cannot unmarshal %s as map value into field %s of type map[string]int32", string(value), objKey)
					}
					this.MapStringInt32[mapKey] = x
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_MAP_map_string_int32
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *UnmarshalData_Aliases) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(2)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *UnmarshalData_Aliases) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*UnmarshalData_Aliases) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *UnmarshalData_Config) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(22)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.UnmarshalData.Config.ip | kind: StringKind | GoName: Ip | omitempty: false | ignore: false
	encoder.AppendObjectKey("ip")
	encoder.AppendString(this.Ip)
	// encode filed type of basic; | field: gojsontest.UnmarshalData.Config.port | kind: Int32Kind | GoName: Port | omitempty: false | ignore: false
	encoder.AppendObjectKey("port")
	encoder.AppendInt32(this.Port)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *UnmarshalData_Config) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*UnmarshalData_Config) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ip":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.Config.ip | kind: StringKind | GoName: Ip
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Ip = x
		case objKey == "port":
			// decode filed type of basic; | field: gojsontest.UnmarshalData.Config.port | kind: Int32Kind | GoName: Port
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Port = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *UnmarshalOneofNotHide) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(30)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Encode field type of oneof; | field: gojsontest.UnmarshalOneofNotHide.Type | GoName: Type | omitempty: false | ignore: false
	if this.Type != nil {
		switch v := this.Type.(type) {
		case *UnmarshalOneofNotHide_TString:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_string | kind: StringKind | GoName: TString | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_string")
			encoder.AppendString(v.TString)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TInt32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_int32 | kind: Int32Kind | GoName: TInt32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_int32")
			encoder.AppendInt32(v.TInt32)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TInt64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_int64 | kind: Int64Kind | GoName: TInt64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_int64")
			encoder.AppendInt64(v.TInt64)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TUint32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_uint32 | kind: Uint32Kind | GoName: TUint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_uint32")
			encoder.AppendUint32(v.TUint32)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TUint64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_uint64 | kind: Uint64Kind | GoName: TUint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_uint64")
			encoder.AppendUint64(v.TUint64)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TSint32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_sint32 | kind: Sint32Kind | GoName: TSint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_sint32")
			encoder.AppendInt32(v.TSint32)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TSint64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_sint64 | kind: Sint64Kind | GoName: TSint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_sint64")
			encoder.AppendInt64(v.TSint64)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TSfixed32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_sfixed32")
			encoder.AppendInt32(v.TSfixed32)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TSfixed64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_sfixed64")
			encoder.AppendInt64(v.TSfixed64)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TFixed32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_fixed32")
			encoder.AppendUint32(v.TFixed32)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TFixed64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_fixed64")
			encoder.AppendUint64(v.TFixed64)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TFloat:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_float | kind: FloatKind | GoName: TFloat | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_float")
			encoder.AppendFloat32(v.TFloat)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TDouble:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_double | kind: DoubleKind | GoName: TDouble | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_double")
			encoder.AppendFloat64(v.TDouble)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TBool:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_bool | kind: BoolKind | GoName: TBool | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_bool")
			encoder.AppendBool(v.TBool)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TEnum1:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_enum1 | kind: EnumKind | GoName: TEnum1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_enum1")
			encoder.AppendInt32(int32(v.TEnum1.Number()))
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TEnum2:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_enum2 | kind: EnumKind | GoName: TEnum2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_enum2")
			encoder.AppendString(v.TEnum2.String())
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TBytes:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_bytes | kind: BytesKind | GoName: TBytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_bytes")
			encoder.AppendBytes(v.TBytes)
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TAliases:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_aliases | kind: MessageKind | GoName: TAliases | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_aliases")
			err = encoder.AppendInterface(v.TAliases)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		case *UnmarshalOneofNotHide_TConfig:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_config | kind: MessageKind | GoName: TConfig | omitempty: false | ignore: false
			encoder.AppendObjectKey("type")
			encoder.AppendObjectBegin()
			encoder.AppendObjectKey("t_config")
			err = encoder.AppendInterface(v.TConfig)
			if err != nil {
				return nil, err
			}
			encoder.AppendObjectEnd()
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: type, goName: Type, field: gojsontest.UnmarshalOneofNotHide.Type", v)
		}
	} else {
		encoder.AppendObjectKey("type")
		encoder.AppendNil()
	}
	// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_seat | kind: StringKind | GoName: TSeat | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_seat")
	encoder.AppendString(this.TSeat)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *UnmarshalOneofNotHide) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*UnmarshalOneofNotHide) is nil")
	}
	var oneofTypeisStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "type":
			// decode filed type of oneof; | field: gojsontest.UnmarshalOneofNotHide.Type | GoName: Type
			if decoder.OpCode == jsondecoder.ScanBeginLiteral {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanBeginObject {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), objKey)
				}
			LOOP_ONEOF_type:
				for {
					if decoder.ObjectBeforeReadKey() { // before read object key
						break LOOP_ONEOF_type
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ObjectBeforeReadValue()     // Before read object value
					switch {
					case oneofKey == "t_string":
						value := decoder.ReadItem()
						var x string
						if value[0] != 'n' { // 'n' means null
							var ok bool
							x, ok = jsondecoder.UnquoteString(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
							}
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TString)
						ot.TString = x
						this.Type = ot
					case oneofKey == "t_int32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TInt32)
						ot.TInt32 = x
						this.Type = ot
					case oneofKey == "t_int64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TInt64)
						ot.TInt64 = x
						this.Type = ot
					case oneofKey == "t_uint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TUint32)
						ot.TUint32 = x
						this.Type = ot
					case oneofKey == "t_uint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TUint64)
						ot.TUint64 = x
						this.Type = ot
					case oneofKey == "t_sint32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TSint32)
						ot.TSint32 = x
						this.Type = ot
					case oneofKey == "t_sint64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TSint64)
						ot.TSint64 = x
						this.Type = ot
					case oneofKey == "t_sfixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TSfixed32)
						ot.TSfixed32 = x
						this.Type = ot
					case oneofKey == "t_sfixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseInt64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TSfixed64)
						ot.TSfixed64 = x
						this.Type = ot
					case oneofKey == "t_fixed32":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TFixed32)
						ot.TFixed32 = x
						this.Type = ot
					case oneofKey == "t_fixed64":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseUint64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TFixed64)
						ot.TFixed64 = x
						this.Type = ot
					case oneofKey == "t_float":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TFloat)
						ot.TFloat = x
						this.Type = ot
					case oneofKey == "t_double":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseFloat64(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TDouble)
						ot.TDouble = x
						this.Type = ot
					case oneofKey == "t_bool":
						value := decoder.ReadItem()
						x, err := jsondecoder.ParseBool(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TBool)
						ot.TBool = x
						this.Type = ot
					case oneofKey == "t_enum1":
						value := decoder.ReadItem()
						x1, err := jsondecoder.ParseInt32(value)
						if err != nil {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type UnmarshalOneofNotHide_Enum", string(value), objKey)
						}
						_, ok := UnmarshalOneofNotHide_Enum_name[x1]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := UnmarshalOneofNotHide_Enum(x1)
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TEnum1)
						ot.TEnum1 = x
						this.Type = ot
					case oneofKey == "t_enum2":
						value := decoder.ReadItem()
						s, ok := jsondecoder.UnquoteString(value)
						if !ok {
							return fmt.Errorf("json: cannot unmarshal %s into field %s of type UnmarshalOneofNotHide_Enum", string(value), objKey)
						}
						x1, ok := UnmarshalOneofNotHide_Enum_value[s]
						if !ok {
							return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
						}
						x := UnmarshalOneofNotHide_Enum(x1)
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TEnum2)
						ot.TEnum2 = x
						this.Type = ot
					case oneofKey == "t_bytes":
						value := decoder.ReadItem()
						var x []byte
						if value[0] != 'n' { // value[0] == 'n' means null
							s, ok := jsondecoder.UnquoteBytes(value)
							if !ok {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
							n, err := base64.StdEncoding.Decode(dst, s)
							if err != nil {
								return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
							}
							x = dst[:n]
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TBytes)
						ot.TBytes = x
						this.Type = ot
					case oneofKey == "t_aliases":
						value := decoder.ReadItem()
						var x *UnmarshalOneofNotHide_Aliases
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(UnmarshalOneofNotHide_Aliases)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TAliases)
						ot.TAliases = x
						this.Type = ot
					case oneofKey == "t_config":
						value := decoder.ReadItem()
						var x *UnmarshalOneofNotHide_Config
						if value[0] != 'n' { // value[0] == 'n' means null
							x = new(UnmarshalOneofNotHide_Config)
							if um, ok := interface{}(x).(json.Unmarshaler); ok {
								err = um.UnmarshalJSON(value)
							} else {
								err = json.Unmarshal(value, x)
							}
							if err != nil {
								return err
							}
						}
						if oneofTypeisStore {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
						}
						oneofTypeisStore = true
						ot := new(UnmarshalOneofNotHide_TConfig)
						ot.TConfig = x
						this.Type = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ObjectAfterReadValue() { // After read object value
						break LOOP_ONEOF_type
					}
				}
				decoder.ScanNext()
			}
		case objKey == "t_seat":
			// decode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.t_seat | kind: StringKind | GoName: TSeat
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TSeat = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *UnmarshalOneofNotHide_Aliases) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(2)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *UnmarshalOneofNotHide_Aliases) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*UnmarshalOneofNotHide_Aliases) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *UnmarshalOneofNotHide_Config) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(22)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.Config.ip | kind: StringKind | GoName: Ip | omitempty: false | ignore: false
	encoder.AppendObjectKey("ip")
	encoder.AppendString(this.Ip)
	// encode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.Config.port | kind: Int32Kind | GoName: Port | omitempty: false | ignore: false
	encoder.AppendObjectKey("port")
	encoder.AppendInt32(this.Port)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *UnmarshalOneofNotHide_Config) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*UnmarshalOneofNotHide_Config) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ip":
			// decode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.Config.ip | kind: StringKind | GoName: Ip
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Ip = x
		case objKey == "port":
			// decode filed type of basic; | field: gojsontest.UnmarshalOneofNotHide.Config.port | kind: Int32Kind | GoName: Port
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Port = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *UnmarshalOneofHide) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(30)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Encode field type of oneof; | field: gojsontest.UnmarshalOneofHide.Type | GoName: Type | omitempty: false | ignore: false
	if this.Type != nil {
		switch v := this.Type.(type) {
		case *UnmarshalOneofHide_TString:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_string | kind: StringKind | GoName: TString | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_string")
			encoder.AppendString(v.TString)
		case *UnmarshalOneofHide_TInt32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_int32 | kind: Int32Kind | GoName: TInt32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_int32")
			encoder.AppendInt32(v.TInt32)
		case *UnmarshalOneofHide_TInt64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_int64 | kind: Int64Kind | GoName: TInt64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_int64")
			encoder.AppendInt64(v.TInt64)
		case *UnmarshalOneofHide_TUint32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_uint32 | kind: Uint32Kind | GoName: TUint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_uint32")
			encoder.AppendUint32(v.TUint32)
		case *UnmarshalOneofHide_TUint64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_uint64 | kind: Uint64Kind | GoName: TUint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_uint64")
			encoder.AppendUint64(v.TUint64)
		case *UnmarshalOneofHide_TSint32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_sint32 | kind: Sint32Kind | GoName: TSint32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_sint32")
			encoder.AppendInt32(v.TSint32)
		case *UnmarshalOneofHide_TSint64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_sint64 | kind: Sint64Kind | GoName: TSint64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_sint64")
			encoder.AppendInt64(v.TSint64)
		case *UnmarshalOneofHide_TSfixed32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_sfixed32")
			encoder.AppendInt32(v.TSfixed32)
		case *UnmarshalOneofHide_TSfixed64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_sfixed64")
			encoder.AppendInt64(v.TSfixed64)
		case *UnmarshalOneofHide_TFixed32:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_fixed32")
			encoder.AppendUint32(v.TFixed32)
		case *UnmarshalOneofHide_TFixed64:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_fixed64")
			encoder.AppendUint64(v.TFixed64)
		case *UnmarshalOneofHide_TFloat:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_float | kind: FloatKind | GoName: TFloat | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_float")
			encoder.AppendFloat32(v.TFloat)
		case *UnmarshalOneofHide_TDouble:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_double | kind: DoubleKind | GoName: TDouble | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_double")
			encoder.AppendFloat64(v.TDouble)
		case *UnmarshalOneofHide_TBool:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_bool | kind: BoolKind | GoName: TBool | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_bool")
			encoder.AppendBool(v.TBool)
		case *UnmarshalOneofHide_TEnum1:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_enum1 | kind: EnumKind | GoName: TEnum1 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_enum1")
			encoder.AppendInt32(int32(v.TEnum1.Number()))
		case *UnmarshalOneofHide_TEnum2:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_enum2 | kind: EnumKind | GoName: TEnum2 | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_enum2")
			encoder.AppendString(v.TEnum2.String())
		case *UnmarshalOneofHide_TBytes:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_bytes | kind: BytesKind | GoName: TBytes | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_bytes")
			encoder.AppendBytes(v.TBytes)
		case *UnmarshalOneofHide_TAliases:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_aliases | kind: MessageKind | GoName: TAliases | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_aliases")
			err = encoder.AppendInterface(v.TAliases)
			if err != nil {
				return nil, err
			}
		case *UnmarshalOneofHide_TConfig:
			// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_config | kind: MessageKind | GoName: TConfig | omitempty: false | ignore: false
			encoder.AppendObjectKey("t_config")
			err = encoder.AppendInterface(v.TConfig)
			if err != nil {
				return nil, err
			}
		default:
			return nil, fmt.Errorf("invalid oneof field type: %v, jsonKey: type, goName: Type, field: gojsontest.UnmarshalOneofHide.Type", v)
		}
	}
	// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_seat | kind: StringKind | GoName: TSeat | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_seat")
	encoder.AppendString(this.TSeat)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *UnmarshalOneofHide) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*UnmarshalOneofHide) is nil")
	}
	var oneofTypeisStore bool

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_string":
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TString)
			ot.TString = x
			this.Type = ot
		case objKey == "t_int32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TInt32)
			ot.TInt32 = x
			this.Type = ot
		case objKey == "t_int64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TInt64)
			ot.TInt64 = x
			this.Type = ot
		case objKey == "t_uint32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TUint32)
			ot.TUint32 = x
			this.Type = ot
		case objKey == "t_uint64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TUint64)
			ot.TUint64 = x
			this.Type = ot
		case objKey == "t_sint32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TSint32)
			ot.TSint32 = x
			this.Type = ot
		case objKey == "t_sint64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TSint64)
			ot.TSint64 = x
			this.Type = ot
		case objKey == "t_sfixed32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TSfixed32)
			ot.TSfixed32 = x
			this.Type = ot
		case objKey == "t_sfixed64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TSfixed64)
			ot.TSfixed64 = x
			this.Type = ot
		case objKey == "t_fixed32":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TFixed32)
			ot.TFixed32 = x
			this.Type = ot
		case objKey == "t_fixed64":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TFixed64)
			ot.TFixed64 = x
			this.Type = ot
		case objKey == "t_float":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TFloat)
			ot.TFloat = x
			this.Type = ot
		case objKey == "t_double":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TDouble)
			ot.TDouble = x
			this.Type = ot
		case objKey == "t_bool":
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TBool)
			ot.TBool = x
			this.Type = ot
		case objKey == "t_enum1":
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type UnmarshalOneofHide_Enum", string(value), objKey)
			}
			_, ok := UnmarshalOneofHide_Enum_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := UnmarshalOneofHide_Enum(x1)
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TEnum1)
			ot.TEnum1 = x
			this.Type = ot
		case objKey == "t_enum2":
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type UnmarshalOneofHide_Enum", string(value), objKey)
			}
			x1, ok := UnmarshalOneofHide_Enum_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := UnmarshalOneofHide_Enum(x1)
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TEnum2)
			ot.TEnum2 = x
			this.Type = ot
		case objKey == "t_bytes":
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TBytes)
			ot.TBytes = x
			this.Type = ot
		case objKey == "t_aliases":
			value := decoder.ReadItem()
			var x *UnmarshalOneofHide_Aliases
			if value[0] != 'n' { // value[0] == 'n' means null
				x = new(UnmarshalOneofHide_Aliases)
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TAliases)
			ot.TAliases = x
			this.Type = ot
		case objKey == "t_config":
			value := decoder.ReadItem()
			var x *UnmarshalOneofHide_Config
			if value[0] != 'n' { // value[0] == 'n' means null
				x = new(UnmarshalOneofHide_Config)
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			if oneofTypeisStore {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", objKey)
			}
			oneofTypeisStore = true
			ot := new(UnmarshalOneofHide_TConfig)
			ot.TConfig = x
			this.Type = ot
		case objKey == "t_seat":
			// decode filed type of basic; | field: gojsontest.UnmarshalOneofHide.t_seat | kind: StringKind | GoName: TSeat
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TSeat = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *UnmarshalOneofHide_Aliases) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(2)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *UnmarshalOneofHide_Aliases) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*UnmarshalOneofHide_Aliases) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *UnmarshalOneofHide_Config) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(22)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.Config.ip | kind: StringKind | GoName: Ip | omitempty: false | ignore: false
	encoder.AppendObjectKey("ip")
	encoder.AppendString(this.Ip)
	// encode filed type of basic; | field: gojsontest.UnmarshalOneofHide.Config.port | kind: Int32Kind | GoName: Port | omitempty: false | ignore: false
	encoder.AppendObjectKey("port")
	encoder.AppendInt32(this.Port)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *UnmarshalOneofHide_Config) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*UnmarshalOneofHide_Config) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ip":
			// decode filed type of basic; | field: gojsontest.UnmarshalOneofHide.Config.ip | kind: StringKind | GoName: Ip
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Ip = x
		case objKey == "port":
			// decode filed type of basic; | field: gojsontest.UnmarshalOneofHide.Config.port | kind: Int32Kind | GoName: Port
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Port = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OptionalModel1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(418)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_string | kind: StringKind | GoName: TString | omitempty: true | ignore: false
	if this.TString != nil {
		encoder.AppendObjectKey("t_string")
		encoder.AppendString(*this.TString)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_int32 | kind: Int32Kind | GoName: TInt32 | omitempty: true | ignore: false
	if this.TInt32 != nil {
		encoder.AppendObjectKey("t_int32")
		encoder.AppendInt32(*this.TInt32)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_int64 | kind: Int64Kind | GoName: TInt64 | omitempty: true | ignore: false
	if this.TInt64 != nil {
		encoder.AppendObjectKey("t_int64")
		encoder.AppendInt64(*this.TInt64)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_uint32 | kind: Uint32Kind | GoName: TUint32 | omitempty: true | ignore: false
	if this.TUint32 != nil {
		encoder.AppendObjectKey("t_uint32")
		encoder.AppendUint32(*this.TUint32)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_uint64 | kind: Uint64Kind | GoName: TUint64 | omitempty: true | ignore: false
	if this.TUint64 != nil {
		encoder.AppendObjectKey("t_uint64")
		encoder.AppendUint64(*this.TUint64)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_sint32 | kind: Sint32Kind | GoName: TSint32 | omitempty: true | ignore: false
	if this.TSint32 != nil {
		encoder.AppendObjectKey("t_sint32")
		encoder.AppendInt32(*this.TSint32)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_sint64 | kind: Sint64Kind | GoName: TSint64 | omitempty: true | ignore: false
	if this.TSint64 != nil {
		encoder.AppendObjectKey("t_sint64")
		encoder.AppendInt64(*this.TSint64)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32 | omitempty: true | ignore: false
	if this.TSfixed32 != nil {
		encoder.AppendObjectKey("t_sfixed32")
		encoder.AppendInt32(*this.TSfixed32)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64 | omitempty: true | ignore: false
	if this.TSfixed64 != nil {
		encoder.AppendObjectKey("t_sfixed64")
		encoder.AppendInt64(*this.TSfixed64)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32 | omitempty: true | ignore: false
	if this.TFixed32 != nil {
		encoder.AppendObjectKey("t_fixed32")
		encoder.AppendUint32(*this.TFixed32)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64 | omitempty: true | ignore: false
	if this.TFixed64 != nil {
		encoder.AppendObjectKey("t_fixed64")
		encoder.AppendUint64(*this.TFixed64)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_float | kind: FloatKind | GoName: TFloat | omitempty: true | ignore: false
	if this.TFloat != nil {
		encoder.AppendObjectKey("t_float")
		encoder.AppendFloat32(*this.TFloat)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_double | kind: DoubleKind | GoName: TDouble | omitempty: true | ignore: false
	if this.TDouble != nil {
		encoder.AppendObjectKey("t_double")
		encoder.AppendFloat64(*this.TDouble)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_bool | kind: BoolKind | GoName: TBool | omitempty: true | ignore: false
	if this.TBool != nil {
		encoder.AppendObjectKey("t_bool")
		encoder.AppendBool(*this.TBool)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_enum1 | kind: EnumKind | GoName: TEnum1 | omitempty: true | ignore: false
	if this.TEnum1 != nil {
		encoder.AppendObjectKey("t_enum1")
		encoder.AppendInt32(int32(this.TEnum1.Number()))
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_enum2 | kind: EnumKind | GoName: TEnum2 | omitempty: true | ignore: false
	if this.TEnum2 != nil {
		encoder.AppendObjectKey("t_enum2")
		encoder.AppendString(this.TEnum2.String())
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_bytes | kind: BytesKind | GoName: TBytes | omitempty: true | ignore: false
	if len(this.TBytes) != 0 {
		encoder.AppendObjectKey("t_bytes")
		encoder.AppendBytes(this.TBytes)
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_aliases | kind: MessageKind | GoName: TAliases | omitempty: true | ignore: false
	if this.TAliases != nil {
		encoder.AppendObjectKey("t_aliases")
		err = encoder.AppendInterface(this.TAliases)
		if err != nil {
			return nil, err
		}
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel1.t_config | kind: MessageKind | GoName: TConfig | omitempty: true | ignore: false
	if this.TConfig != nil {
		encoder.AppendObjectKey("t_config")
		err = encoder.AppendInterface(this.TConfig)
		if err != nil {
			return nil, err
		}
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OptionalModel1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OptionalModel1) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_string":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_string | kind: StringKind | GoName: TString
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString = &x
		case objKey == "t_int32":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_int32 | kind: Int32Kind | GoName: TInt32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TInt32 = &x
		case objKey == "t_int64":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_int64 | kind: Int64Kind | GoName: TInt64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TInt64 = &x
		case objKey == "t_uint32":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_uint32 | kind: Uint32Kind | GoName: TUint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TUint32 = &x
		case objKey == "t_uint64":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_uint64 | kind: Uint64Kind | GoName: TUint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TUint64 = &x
		case objKey == "t_sint32":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_sint32 | kind: Sint32Kind | GoName: TSint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSint32 = &x
		case objKey == "t_sint64":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_sint64 | kind: Sint64Kind | GoName: TSint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSint64 = &x
		case objKey == "t_sfixed32":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSfixed32 = &x
		case objKey == "t_sfixed64":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSfixed64 = &x
		case objKey == "t_fixed32":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TFixed32 = &x
		case objKey == "t_fixed64":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TFixed64 = &x
		case objKey == "t_float":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_float | kind: FloatKind | GoName: TFloat
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
			}
			this.TFloat = &x
		case objKey == "t_double":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_double | kind: DoubleKind | GoName: TDouble
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TDouble = &x
		case objKey == "t_bool":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_bool | kind: BoolKind | GoName: TBool
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			this.TBool = &x
		case objKey == "t_enum1":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_enum1 | kind: EnumKind | GoName: TEnum1
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type OptionalModel1_Enum", string(value), objKey)
			}
			_, ok := OptionalModel1_Enum_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := OptionalModel1_Enum(x1)
			this.TEnum1 = &x
		case objKey == "t_enum2":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_enum2 | kind: EnumKind | GoName: TEnum2
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type OptionalModel1_Enum", string(value), objKey)
			}
			x1, ok := OptionalModel1_Enum_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := OptionalModel1_Enum(x1)
			this.TEnum2 = &x
		case objKey == "t_bytes":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_bytes | kind: BytesKind | GoName: TBytes
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.TBytes = x
		case objKey == "t_aliases":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_aliases | kind: MessageKind | GoName: TAliases
			value := decoder.ReadItem()
			var x *OptionalModel1_Aliases
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TAliases == nil {
					x = new(OptionalModel1_Aliases)
				} else {
					x = this.TAliases
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TAliases = x
		case objKey == "t_config":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.t_config | kind: MessageKind | GoName: TConfig
			value := decoder.ReadItem()
			var x *OptionalModel1_Config
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TConfig == nil {
					x = new(OptionalModel1_Config)
				} else {
					x = this.TConfig
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TConfig = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OptionalModel1_Aliases) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(2)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OptionalModel1_Aliases) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OptionalModel1_Aliases) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OptionalModel1_Config) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(26)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.OptionalModel1.Config.ip | kind: StringKind | GoName: Ip | omitempty: false | ignore: false
	encoder.AppendObjectKey("ip")
	encoder.AppendString(*this.Ip)
	// encode filed type of basic; | field: gojsontest.OptionalModel1.Config.port | kind: Int32Kind | GoName: Port | omitempty: false | ignore: false
	encoder.AppendObjectKey("port")
	encoder.AppendInt32(*this.Port)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OptionalModel1_Config) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OptionalModel1_Config) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ip":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.Config.ip | kind: StringKind | GoName: Ip
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Ip = &x
		case objKey == "port":
			// decode filed type of basic; | field: gojsontest.OptionalModel1.Config.port | kind: Int32Kind | GoName: Port
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Port = &x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OptionalModel2) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(418)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_string | kind: StringKind | GoName: TString | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_string")
	encoder.AppendString(*this.TString)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_int32 | kind: Int32Kind | GoName: TInt32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_int32")
	encoder.AppendInt32(*this.TInt32)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_int64 | kind: Int64Kind | GoName: TInt64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_int64")
	encoder.AppendInt64(*this.TInt64)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_uint32 | kind: Uint32Kind | GoName: TUint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_uint32")
	encoder.AppendUint32(*this.TUint32)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_uint64 | kind: Uint64Kind | GoName: TUint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_uint64")
	encoder.AppendUint64(*this.TUint64)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_sint32 | kind: Sint32Kind | GoName: TSint32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sint32")
	encoder.AppendInt32(*this.TSint32)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_sint64 | kind: Sint64Kind | GoName: TSint64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sint64")
	encoder.AppendInt64(*this.TSint64)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sfixed32")
	encoder.AppendInt32(*this.TSfixed32)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_sfixed64")
	encoder.AppendInt64(*this.TSfixed64)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_fixed32")
	encoder.AppendUint32(*this.TFixed32)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_fixed64")
	encoder.AppendUint64(*this.TFixed64)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_float | kind: FloatKind | GoName: TFloat | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_float")
	encoder.AppendFloat32(*this.TFloat)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_double | kind: DoubleKind | GoName: TDouble | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_double")
	encoder.AppendFloat64(*this.TDouble)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_bool | kind: BoolKind | GoName: TBool | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_bool")
	encoder.AppendBool(*this.TBool)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_enum1 | kind: EnumKind | GoName: TEnum1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_enum1")
	encoder.AppendInt32(int32(this.TEnum1.Number()))
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_enum2 | kind: EnumKind | GoName: TEnum2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_enum2")
	encoder.AppendString(this.TEnum2.String())
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_bytes | kind: BytesKind | GoName: TBytes | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_bytes")
	encoder.AppendBytes(this.TBytes)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_aliases | kind: MessageKind | GoName: TAliases | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_aliases")
	err = encoder.AppendInterface(this.TAliases)
	if err != nil {
		return nil, err
	}
	// encode filed type of basic; | field: gojsontest.OptionalModel2.t_config | kind: MessageKind | GoName: TConfig | omitempty: false | ignore: false
	encoder.AppendObjectKey("t_config")
	err = encoder.AppendInterface(this.TConfig)
	if err != nil {
		return nil, err
	}

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OptionalModel2) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OptionalModel2) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "t_string":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_string | kind: StringKind | GoName: TString
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.TString = &x
		case objKey == "t_int32":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_int32 | kind: Int32Kind | GoName: TInt32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TInt32 = &x
		case objKey == "t_int64":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_int64 | kind: Int64Kind | GoName: TInt64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TInt64 = &x
		case objKey == "t_uint32":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_uint32 | kind: Uint32Kind | GoName: TUint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TUint32 = &x
		case objKey == "t_uint64":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_uint64 | kind: Uint64Kind | GoName: TUint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TUint64 = &x
		case objKey == "t_sint32":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_sint32 | kind: Sint32Kind | GoName: TSint32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSint32 = &x
		case objKey == "t_sint64":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_sint64 | kind: Sint64Kind | GoName: TSint64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSint64 = &x
		case objKey == "t_sfixed32":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_sfixed32 | kind: Sfixed32Kind | GoName: TSfixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.TSfixed32 = &x
		case objKey == "t_sfixed64":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_sfixed64 | kind: Sfixed64Kind | GoName: TSfixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int64", string(value), objKey)
			}
			this.TSfixed64 = &x
		case objKey == "t_fixed32":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_fixed32 | kind: Fixed32Kind | GoName: TFixed32
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint32", string(value), objKey)
			}
			this.TFixed32 = &x
		case objKey == "t_fixed64":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_fixed64 | kind: Fixed64Kind | GoName: TFixed64
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseUint64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type uint64", string(value), objKey)
			}
			this.TFixed64 = &x
		case objKey == "t_float":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_float | kind: FloatKind | GoName: TFloat
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float32", string(value), objKey)
			}
			this.TFloat = &x
		case objKey == "t_double":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_double | kind: DoubleKind | GoName: TDouble
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseFloat64(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type float64", string(value), objKey)
			}
			this.TDouble = &x
		case objKey == "t_bool":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_bool | kind: BoolKind | GoName: TBool
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseBool(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type bool", string(value), objKey)
			}
			this.TBool = &x
		case objKey == "t_enum1":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_enum1 | kind: EnumKind | GoName: TEnum1
			value := decoder.ReadItem()
			x1, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type OptionalModel2_Enum", string(value), objKey)
			}
			_, ok := OptionalModel2_Enum_name[x1]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := OptionalModel2_Enum(x1)
			this.TEnum1 = &x
		case objKey == "t_enum2":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_enum2 | kind: EnumKind | GoName: TEnum2
			value := decoder.ReadItem()
			s, ok := jsondecoder.UnquoteString(value)
			if !ok {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type OptionalModel2_Enum", string(value), objKey)
			}
			x1, ok := OptionalModel2_Enum_value[s]
			if !ok {
				return fmt.Errorf("json: unknown enum value %s in field %s", string(value), objKey)
			}
			x := OptionalModel2_Enum(x1)
			this.TEnum2 = &x
		case objKey == "t_bytes":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_bytes | kind: BytesKind | GoName: TBytes
			value := decoder.ReadItem()
			var x []byte
			if value[0] != 'n' { // value[0] == 'n' means null
				s, ok := jsondecoder.UnquoteBytes(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				dst := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
				n, err := base64.StdEncoding.Decode(dst, s)
				if err != nil {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type []byte", string(value), objKey)
				}
				x = dst[:n]
			}
			this.TBytes = x
		case objKey == "t_aliases":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_aliases | kind: MessageKind | GoName: TAliases
			value := decoder.ReadItem()
			var x *OptionalModel2_Aliases
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TAliases == nil {
					x = new(OptionalModel2_Aliases)
				} else {
					x = this.TAliases
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TAliases = x
		case objKey == "t_config":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.t_config | kind: MessageKind | GoName: TConfig
			value := decoder.ReadItem()
			var x *OptionalModel2_Config
			if value[0] != 'n' { // value[0] == 'n' means null
				if this.TConfig == nil {
					x = new(OptionalModel2_Config)
				} else {
					x = this.TConfig
				}
				if um, ok := interface{}(x).(json.Unmarshaler); ok {
					err = um.UnmarshalJSON(value)
				} else {
					err = json.Unmarshal(value, x)
				}
				if err != nil {
					return err
				}
			}
			this.TConfig = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OptionalModel2_Aliases) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(2)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OptionalModel2_Aliases) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OptionalModel2_Aliases) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON for implements interface json.Marshaler.
func (this *OptionalModel2_Config) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(26)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsontest.OptionalModel2.Config.ip | kind: StringKind | GoName: Ip | omitempty: false | ignore: false
	encoder.AppendObjectKey("ip")
	encoder.AppendString(*this.Ip)
	// encode filed type of basic; | field: gojsontest.OptionalModel2.Config.port | kind: Int32Kind | GoName: Port | omitempty: false | ignore: false
	encoder.AppendObjectKey("port")
	encoder.AppendInt32(*this.Port)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *OptionalModel2_Config) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: tests/gojsontest.(*OptionalModel2_Config) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ip":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.Config.ip | kind: StringKind | GoName: Ip
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Ip = &x
		case objKey == "port":
			// decode filed type of basic; | field: gojsontest.OptionalModel2.Config.port | kind: Int32Kind | GoName: Port
			value := decoder.ReadItem()
			x, err := jsondecoder.ParseInt32(value)
			if err != nil {
				return fmt.Errorf("json: cannot unmarshal %s into field %s of type int32", string(value), objKey)
			}
			this.Port = &x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}
