// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: xgo/tests/gojsonexternal/gojson_external.proto

package gojsonexternal

import (
	errors "errors"
	fmt "fmt"
	jsondecoder "github.com/yu31/protoc-plugin/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin/xgo/pkg/jsonencoder"
)

// MarshalJSON for implements interface json.Marshaler.
func (this *ExternalMessage1) MarshalJSON() ([]byte, error) {
	if this == nil {
		return []byte("null"), nil
	}
	var err error

	encoder := jsonencoder.New(32)

	// Add JSON end identifier
	encoder.AppendObjectBegin()

	// encode filed type of basic; | field: gojsonexternal.ExternalMessage1.ip1 | kind: StringKind | GoName: Ip1 | omitempty: false | ignore: false
	encoder.AppendObjectKey("ip1")
	encoder.AppendString(this.Ip1)
	// encode filed type of basic; | field: gojsonexternal.ExternalMessage1.ip2 | kind: StringKind | GoName: Ip2 | omitempty: false | ignore: false
	encoder.AppendObjectKey("ip2")
	encoder.AppendString(this.Ip2)
	// encode filed type of basic; | field: gojsonexternal.ExternalMessage1.ip3 | kind: StringKind | GoName: Ip3 | omitempty: false | ignore: false
	encoder.AppendObjectKey("ip3")
	encoder.AppendString(this.Ip3)

	// Add JSON end identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON for implements json.Unmarshaler.
func (this *ExternalMessage1) UnmarshalJSON(b []byte) error {
	if this == nil {
		return errors.New("json: Unmarshal: github.com/yu31/protoc-plugin/xgo/tests/gojsonexternal.(*ExternalMessage1) is nil")
	}

	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}

	// check null.
	decoder.ScanWhile(jsondecoder.ScanSkipSpace)
	if decoder.OpCode == jsondecoder.ScanBeginLiteral {
		value := decoder.ReadItem()
		if value[0] != 'n' {
			return fmt.Errorf("json: cannot unmarshal %s into object", string(value))
		}
		return nil // value is null
	}
	if decoder.OpCode != jsondecoder.ScanBeginObject {
		panic(jsondecoder.PhasePanicMsg)
	}

	// Scan begin.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ObjectBeforeReadKey() { // before read object key
			break LOOP_OBJECT
		}

		objKey := decoder.ReadObjectKey() // Read key
		_ = objKey                        // avoid objKey not used
		decoder.ObjectBeforeReadValue()   // Before read object value
		switch {                          // process field with key.
		case objKey == "ip1":
			// decode filed type of basic; | field: gojsonexternal.ExternalMessage1.ip1 | kind: StringKind | GoName: Ip1
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Ip1 = x
		case objKey == "ip2":
			// decode filed type of basic; | field: gojsonexternal.ExternalMessage1.ip2 | kind: StringKind | GoName: Ip2
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Ip2 = x
		case objKey == "ip3":
			// decode filed type of basic; | field: gojsonexternal.ExternalMessage1.ip3 | kind: StringKind | GoName: Ip3
			value := decoder.ReadItem()
			var x string
			if value[0] != 'n' { // 'n' means null
				var ok bool
				x, ok = jsondecoder.UnquoteString(value)
				if !ok {
					return fmt.Errorf("json: cannot unmarshal %s into field %s of type string", string(value), objKey)
				}
			}
			this.Ip3 = x
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ObjectAfterReadValue() { // After read object value
			break LOOP_OBJECT
		}
	}

	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}
