package gojson

import (
	"fmt"
	"os"
	"runtime"

	"github.com/yu31/protoc-plugin/xgo/internal/generator"
	"github.com/yu31/protoc-plugin/xgo/internal/utils"
	"github.com/yu31/protoc-plugin/xgo/pb/pbjson"
	"google.golang.org/protobuf/compiler/protogen"
)

const version = "0.0.1"

var (
	fmtPackage     = protogen.GoImportPath("fmt")
	strconvPackage = protogen.GoImportPath("strconv")
	base64Package  = protogen.GoImportPath("encoding/base64")
	jsonPackage    = protogen.GoImportPath("encoding/json")
	errorsPackage  = protogen.GoImportPath("errors")
	encoderPackage = protogen.GoImportPath("github.com/yu31/protoc-plugin/xgo/pkg/jsonencoder")
	decoderPackage = protogen.GoImportPath("github.com/yu31/protoc-plugin/xgo/pkg/jsondecoder")
)

type plugin struct {
	g    *protogen.GeneratedFile
	file *protogen.File

	messages []*protogen.Message

	fileOptions *pbjson.SerializeOptions

	// The message options of currently being processed.
	msgOptions *pbjson.SerializeOptions

	// The message of currently being processed.
	message *protogen.Message

	// The fileds of currently being processed.
	fields []*protogen.Field
}

func New() generator.Plugin {
	return &plugin{}
}

// Name identifies the plugin.
func (p *plugin) Name() string {
	return "json"
}

// Version identifies the plugin version.
func (p *plugin) Version() string {
	return version
}

func (p *plugin) Init(file *protogen.File) bool {
	//p.fileOptions = p.loadFileOptions(file)
	//p.file = file
	//p.messages = utils.LoadValidMessages(file.Messages)
	//return true

	if len(file.Messages) == 0 {
		return false
	}

	p.fileOptions = p.loadFileOptions(file)
	if p.fileOptions.Ignore != nil && *p.fileOptions.Ignore {
		return false
	}
	p.file = file
	p.messages = utils.LoadValidMessages(file.Messages)

	for _, msg := range p.messages {
		options := p.loadMessageOptions(msg)
		if options.Ignore == nil || !(*options.Ignore) {
			return true
		}
	}
	return false
}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (p *plugin) Generate(g *protogen.GeneratedFile) {
	//if p.fileOptions.Ignore != nil && *p.fileOptions.Ignore {
	//	return
	//}
	p.g = g
	for _, msg := range p.messages {
		p.generateMessage(msg)
	}
}

func (p *plugin) generateMessage(msg *protogen.Message) {
	defer func() {
		if r := recover(); r != nil {
			println(fmt.Sprintf(
				"panic on -> file: %s, message: %s",
				p.file.Desc.FullName(), msg.Desc.Name(),
			))

			println(fmt.Sprintf("recover: %v", r))
			buf := make([]byte, 4096)
			_ = runtime.Stack(buf, true)
			println(string(buf))

			os.Exit(1)
		}
	}()

	msgOptions := p.loadMessageOptions(msg)
	if msgOptions.Ignore != nil && *msgOptions.Ignore {
		return
	}
	p.msgOptions = msgOptions
	p.message = msg
	p.fields = utils.LoadFieldList(msg)

	// check whether have duplicate json key.
	p.checkJSONKey()

	// Marshal
	p.generateMarshalCode()

	// Unmarshal
	p.generateUnmarshalCode()
}
