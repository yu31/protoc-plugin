package generator

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"unicode"
	"unicode/utf8"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func generateFile(plugin Plugin, pp *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	name := file.GeneratedFilenamePrefix + "." + plugin.Name() + ".pb.go"
	g := pp.NewGeneratedFile(name, file.GoImportPath)

	// Generate headers.
	genGeneratedHeader(plugin, g, file)

	for i, imps := 0, file.Desc.Imports(); i < imps.Len(); i++ {
		genImport(plugin, pp, g, file, imps.Get(i))
	}

	// Generated by plugin.
	plugin.Generate(g)
	return g
}

func genGeneratedHeader(plugin Plugin, g *protogen.GeneratedFile, file *protogen.File) {
	programName := filepath.Base(os.Args[0])
	g.P(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.", programName))

	// Insert version marker.
	g.P("// versions:")
	g.P("// \t\t"+programName+" ", plugin.Version())

	// Insert source file marker.
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()

	g.P("package ", file.GoPackageName)
	g.P()
}

func genImport(plugin Plugin, pp *protogen.Plugin, g *protogen.GeneratedFile, file *protogen.File, imp protoreflect.FileImport) {
	impFile, ok := pp.FilesByPath[imp.Path()]
	if !ok {
		return
	}
	if impFile.GoImportPath == file.GoImportPath {
		// Don't generate imports or aliases for types in the same Go package.
		return
	}

	// Generate imports for all non-weak dependencies, even if they are not
	// referenced, because other code and tools depend on having the
	// full transitive closure of protocol buffer types in the binary.
	if !imp.IsWeak {
		g.Import(impFile.GoImportPath)
	}
	if !imp.IsPublic {
		return
	}

	// Generate public imports by generating the imported file, parsing it,
	// and extracting every symbol that should receive a forwarding declaration.
	impGen := generateFile(plugin, pp, impFile)
	impGen.Skip()
	b, err := impGen.Content()
	if err != nil {
		pp.Error(err)
		return
	}
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
	if err != nil {
		pp.Error(err)
		return
	}
	genForward := func(tok token.Token, name string, expr ast.Expr) {
		// Don't import unexported symbols.
		r, _ := utf8.DecodeRuneInString(name)
		if !unicode.IsUpper(r) {
			return
		}
		// Don't import the FileDescriptor.
		if name == impFile.GoDescriptorIdent.GoName {
			return
		}
		// Don't import decls referencing a symbol defined in another package.
		// i.e., don't import decls which are themselves public imports:
		//
		//	type T = somepackage.T
		if _, ok := expr.(*ast.SelectorExpr); ok {
			return
		}
		g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
	}
	g.P("// Symbols defined in public import of ", imp.Path(), ".")
	g.P()
	for _, decl := range astFile.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range decl.Specs {
				switch spec := spec.(type) {
				case *ast.TypeSpec:
					genForward(decl.Tok, spec.Name.Name, spec.Type)
				case *ast.ValueSpec:
					for i, name := range spec.Names {
						var expr ast.Expr
						if i < len(spec.Values) {
							expr = spec.Values[i]
						}
						genForward(decl.Tok, name.Name, expr)
					}
				case *ast.ImportSpec:
				default:
					panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
				}
			}
		}
	}
	g.P()
}
